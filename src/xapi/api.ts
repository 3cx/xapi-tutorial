/* tslint:disable */
/* eslint-disable */
/**
 * XAPI
 * This OData service is located at /xapi/v1
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionImportGetDirectoryInfoRequestBody
 */
export interface ActionImportGetDirectoryInfoRequestBody {
    /**
     * 
     * @type {PbxDirectoryParameters}
     * @memberof ActionImportGetDirectoryInfoRequestBody
     */
    'parameters'?: PbxDirectoryParameters;
}
/**
 * 
 * @export
 * @interface ActionImportInstallUpdatesRequestBody
 */
export interface ActionImportInstallUpdatesRequestBody {
    /**
     * 
     * @type {PbxInstallUpdates}
     * @memberof ActionImportInstallUpdatesRequestBody
     */
    'install'?: PbxInstallUpdates;
}
/**
 * 
 * @export
 * @interface ActionImportPurgeCallsRequestBody
 */
export interface ActionImportPurgeCallsRequestBody {
    /**
     * 
     * @type {PbxPurgeSettings}
     * @memberof ActionImportPurgeCallsRequestBody
     */
    'period'?: PbxPurgeSettings;
}
/**
 * 
 * @export
 * @interface ActionImportPurgeChatsRequestBody
 */
export interface ActionImportPurgeChatsRequestBody {
    /**
     * 
     * @type {PbxPurgeSettings}
     * @memberof ActionImportPurgeChatsRequestBody
     */
    'period'?: PbxPurgeSettings;
}
/**
 * 
 * @export
 * @interface ActionImportSetUpdateSettingsRequestBody
 */
export interface ActionImportSetUpdateSettingsRequestBody {
    /**
     * 
     * @type {PbxUpdateSettings}
     * @memberof ActionImportSetUpdateSettingsRequestBody
     */
    'settings'?: PbxUpdateSettings;
}
/**
 * 
 * @export
 * @interface BackupsBackupRequestBody
 */
export interface BackupsBackupRequestBody {
    /**
     * 
     * @type {PbxCreateBackup}
     * @memberof BackupsBackupRequestBody
     */
    'description'?: PbxCreateBackup;
}
/**
 * 
 * @export
 * @interface BackupsBackupsRestoreRequestBody
 */
export interface BackupsBackupsRestoreRequestBody {
    /**
     * 
     * @type {string}
     * @memberof BackupsBackupsRestoreRequestBody
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof BackupsBackupsRestoreRequestBody
     */
    'footprint'?: number;
}
/**
 * 
 * @export
 * @interface BackupsSetBackupFailoverSettingsRequestBody
 */
export interface BackupsSetBackupFailoverSettingsRequestBody {
    /**
     * 
     * @type {PbxBackupFailoverSettings}
     * @memberof BackupsSetBackupFailoverSettingsRequestBody
     */
    'settings'?: PbxBackupFailoverSettings;
}
/**
 * 
 * @export
 * @interface BackupsSetBackupRepositorySettingsRequestBody
 */
export interface BackupsSetBackupRepositorySettingsRequestBody {
    /**
     * 
     * @type {PbxBackupRepositorySettings}
     * @memberof BackupsSetBackupRepositorySettingsRequestBody
     */
    'settings'?: PbxBackupRepositorySettings;
}
/**
 * 
 * @export
 * @interface BackupsSetBackupSettingsRequestBody
 */
export interface BackupsSetBackupSettingsRequestBody {
    /**
     * 
     * @type {PbxBackupSettings}
     * @memberof BackupsSetBackupSettingsRequestBody
     */
    'settings'?: PbxBackupSettings;
}
/**
 * 
 * @export
 * @interface BackupsSetRestoreSettingsRequestBody
 */
export interface BackupsSetRestoreSettingsRequestBody {
    /**
     * 
     * @type {PbxRestoreSettings}
     * @memberof BackupsSetRestoreSettingsRequestBody
     */
    'settings'?: PbxRestoreSettings;
}
/**
 * 
 * @export
 * @interface BaseCollectionPaginationCountResponse
 */
export interface BaseCollectionPaginationCountResponse {
    /**
     * 
     * @type {number}
     * @memberof BaseCollectionPaginationCountResponse
     */
    '@odata.count'?: number | null;
}
/**
 * 
 * @export
 * @interface BatchDelete200Response
 */
export interface BatchDelete200Response {
    /**
     * 
     * @type {number}
     * @memberof BatchDelete200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxUserDeleteError>}
     * @memberof BatchDelete200Response
     */
    'value'?: Array<PbxUserDeleteError>;
}
/**
 * 
 * @export
 * @interface BlackListNumbersBulkNumbersDeleteRequestBody
 */
export interface BlackListNumbersBulkNumbersDeleteRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof BlackListNumbersBulkNumbersDeleteRequestBody
     */
    'ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BlocklistBulkIpsDeleteRequestBody
 */
export interface BlocklistBulkIpsDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof BlocklistBulkIpsDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CallCostSettingsUpdateCostRequestBody
 */
export interface CallCostSettingsUpdateCostRequestBody {
    /**
     * 
     * @type {Array<PbxCallCostSettings>}
     * @memberof CallCostSettingsUpdateCostRequestBody
     */
    'costs'?: Array<PbxCallCostSettings>;
}
/**
 * 
 * @export
 * @interface CallFlowAppsCallFlowAppDeleteAudioFileRequestBody
 */
export interface CallFlowAppsCallFlowAppDeleteAudioFileRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CallFlowAppsCallFlowAppDeleteAudioFileRequestBody
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface CollectionOfAbandonedChatsStatistics
 */
export interface CollectionOfAbandonedChatsStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfAbandonedChatsStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAbandonedChatsStatistics>}
     * @memberof CollectionOfAbandonedChatsStatistics
     */
    'value'?: Array<PbxAbandonedChatsStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfAbandonedQueueCalls
 */
export interface CollectionOfAbandonedQueueCalls {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfAbandonedQueueCalls
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAbandonedQueueCalls>}
     * @memberof CollectionOfAbandonedQueueCalls
     */
    'value'?: Array<PbxAbandonedQueueCalls>;
}
/**
 * 
 * @export
 * @interface CollectionOfActivityLogEvent
 */
export interface CollectionOfActivityLogEvent {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfActivityLogEvent
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxActivityLogEvent>}
     * @memberof CollectionOfActivityLogEvent
     */
    'value'?: Array<PbxActivityLogEvent>;
}
/**
 * 
 * @export
 * @interface CollectionOfAgentLoginHistory
 */
export interface CollectionOfAgentLoginHistory {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfAgentLoginHistory
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAgentLoginHistory>}
     * @memberof CollectionOfAgentLoginHistory
     */
    'value'?: Array<PbxAgentLoginHistory>;
}
/**
 * 
 * @export
 * @interface CollectionOfAgentsInQueueStatistics
 */
export interface CollectionOfAgentsInQueueStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfAgentsInQueueStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAgentsInQueueStatistics>}
     * @memberof CollectionOfAgentsInQueueStatistics
     */
    'value'?: Array<PbxAgentsInQueueStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfAuditLog
 */
export interface CollectionOfAuditLog {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfAuditLog
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAuditLog>}
     * @memberof CollectionOfAuditLog
     */
    'value'?: Array<PbxAuditLog>;
}
/**
 * 
 * @export
 * @interface CollectionOfBreachesSla
 */
export interface CollectionOfBreachesSla {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfBreachesSla
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxBreachesSla>}
     * @memberof CollectionOfBreachesSla
     */
    'value'?: Array<PbxBreachesSla>;
}
/**
 * 
 * @export
 * @interface CollectionOfCallCostByExtensionGroup
 */
export interface CollectionOfCallCostByExtensionGroup {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfCallCostByExtensionGroup
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallCostByExtensionGroup>}
     * @memberof CollectionOfCallCostByExtensionGroup
     */
    'value'?: Array<PbxCallCostByExtensionGroup>;
}
/**
 * 
 * @export
 * @interface CollectionOfCallHistoryView
 */
export interface CollectionOfCallHistoryView {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfCallHistoryView
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallHistoryView>}
     * @memberof CollectionOfCallHistoryView
     */
    'value'?: Array<PbxCallHistoryView>;
}
/**
 * 
 * @export
 * @interface CollectionOfCallLogData
 */
export interface CollectionOfCallLogData {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfCallLogData
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallLogData>}
     * @memberof CollectionOfCallLogData
     */
    'value'?: Array<PbxCallLogData>;
}
/**
 * 
 * @export
 * @interface CollectionOfChatHistoryView
 */
export interface CollectionOfChatHistoryView {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfChatHistoryView
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxChatHistoryView>}
     * @memberof CollectionOfChatHistoryView
     */
    'value'?: Array<PbxChatHistoryView>;
}
/**
 * 
 * @export
 * @interface CollectionOfChatMessagesHistoryView
 */
export interface CollectionOfChatMessagesHistoryView {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfChatMessagesHistoryView
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxChatMessagesHistoryView>}
     * @memberof CollectionOfChatMessagesHistoryView
     */
    'value'?: Array<PbxChatMessagesHistoryView>;
}
/**
 * 
 * @export
 * @interface CollectionOfCrmTemplate
 */
export interface CollectionOfCrmTemplate {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfCrmTemplate
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmTemplate>}
     * @memberof CollectionOfCrmTemplate
     */
    'value'?: Array<PbxCrmTemplate>;
}
/**
 * 
 * @export
 * @interface CollectionOfDNProperty
 */
export interface CollectionOfDNProperty {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfDNProperty
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDNProperty>}
     * @memberof CollectionOfDNProperty
     */
    'value'?: Array<PbxDNProperty>;
}
/**
 * 
 * @export
 * @interface CollectionOfDetailedQueueStatistics
 */
export interface CollectionOfDetailedQueueStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfDetailedQueueStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDetailedQueueStatistics>}
     * @memberof CollectionOfDetailedQueueStatistics
     */
    'value'?: Array<PbxDetailedQueueStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfExtensionStatistics
 */
export interface CollectionOfExtensionStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfExtensionStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionStatistics>}
     * @memberof CollectionOfExtensionStatistics
     */
    'value'?: Array<PbxExtensionStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfExtensionsStatisticsByRingGroups
 */
export interface CollectionOfExtensionsStatisticsByRingGroups {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfExtensionsStatisticsByRingGroups
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionsStatisticsByRingGroups>}
     * @memberof CollectionOfExtensionsStatisticsByRingGroups
     */
    'value'?: Array<PbxExtensionsStatisticsByRingGroups>;
}
/**
 * 
 * @export
 * @interface CollectionOfInboundRuleReport
 */
export interface CollectionOfInboundRuleReport {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfInboundRuleReport
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxInboundRuleReport>}
     * @memberof CollectionOfInboundRuleReport
     */
    'value'?: Array<PbxInboundRuleReport>;
}
/**
 * 
 * @export
 * @interface CollectionOfOutboundRule
 */
export interface CollectionOfOutboundRule {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfOutboundRule
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOutboundRule>}
     * @memberof CollectionOfOutboundRule
     */
    'value'?: Array<PbxOutboundRule>;
}
/**
 * 
 * @export
 * @interface CollectionOfPeer
 */
export interface CollectionOfPeer {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfPeer
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPeer>}
     * @memberof CollectionOfPeer
     */
    'value'?: Array<PbxPeer>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueAgentsChatStatistics
 */
export interface CollectionOfQueueAgentsChatStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueAgentsChatStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAgentsChatStatistics>}
     * @memberof CollectionOfQueueAgentsChatStatistics
     */
    'value'?: Array<PbxQueueAgentsChatStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueAgentsChatStatisticsTotals
 */
export interface CollectionOfQueueAgentsChatStatisticsTotals {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueAgentsChatStatisticsTotals
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAgentsChatStatisticsTotals>}
     * @memberof CollectionOfQueueAgentsChatStatisticsTotals
     */
    'value'?: Array<PbxQueueAgentsChatStatisticsTotals>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueAnsweredCallsByWaitTime
 */
export interface CollectionOfQueueAnsweredCallsByWaitTime {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueAnsweredCallsByWaitTime
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAnsweredCallsByWaitTime>}
     * @memberof CollectionOfQueueAnsweredCallsByWaitTime
     */
    'value'?: Array<PbxQueueAnsweredCallsByWaitTime>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueCallbacks
 */
export interface CollectionOfQueueCallbacks {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueCallbacks
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueCallbacks>}
     * @memberof CollectionOfQueueCallbacks
     */
    'value'?: Array<PbxQueueCallbacks>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueChatPerformance
 */
export interface CollectionOfQueueChatPerformance {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueChatPerformance
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueChatPerformance>}
     * @memberof CollectionOfQueueChatPerformance
     */
    'value'?: Array<PbxQueueChatPerformance>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueueFailedCallbacks
 */
export interface CollectionOfQueueFailedCallbacks {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueueFailedCallbacks
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueFailedCallbacks>}
     * @memberof CollectionOfQueueFailedCallbacks
     */
    'value'?: Array<PbxQueueFailedCallbacks>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueuePerformanceOverview
 */
export interface CollectionOfQueuePerformanceOverview {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueuePerformanceOverview
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueuePerformanceOverview>}
     * @memberof CollectionOfQueuePerformanceOverview
     */
    'value'?: Array<PbxQueuePerformanceOverview>;
}
/**
 * 
 * @export
 * @interface CollectionOfQueuePerformanceTotals
 */
export interface CollectionOfQueuePerformanceTotals {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfQueuePerformanceTotals
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueuePerformanceTotals>}
     * @memberof CollectionOfQueuePerformanceTotals
     */
    'value'?: Array<PbxQueuePerformanceTotals>;
}
/**
 * 
 * @export
 * @interface CollectionOfReportExtensionStatisticsByGroup
 */
export interface CollectionOfReportExtensionStatisticsByGroup {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfReportExtensionStatisticsByGroup
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxReportExtensionStatisticsByGroup>}
     * @memberof CollectionOfReportExtensionStatisticsByGroup
     */
    'value'?: Array<PbxReportExtensionStatisticsByGroup>;
}
/**
 * 
 * @export
 * @interface CollectionOfRingGroupStatistics
 */
export interface CollectionOfRingGroupStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfRingGroupStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRingGroupStatistics>}
     * @memberof CollectionOfRingGroupStatistics
     */
    'value'?: Array<PbxRingGroupStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfStatisticSla
 */
export interface CollectionOfStatisticSla {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfStatisticSla
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxStatisticSla>}
     * @memberof CollectionOfStatisticSla
     */
    'value'?: Array<PbxStatisticSla>;
}
/**
 * 
 * @export
 * @interface CollectionOfTeamQueueGeneralStatistics
 */
export interface CollectionOfTeamQueueGeneralStatistics {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfTeamQueueGeneralStatistics
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTeamQueueGeneralStatistics>}
     * @memberof CollectionOfTeamQueueGeneralStatistics
     */
    'value'?: Array<PbxTeamQueueGeneralStatistics>;
}
/**
 * 
 * @export
 * @interface CollectionOfTimeReportData
 */
export interface CollectionOfTimeReportData {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfTimeReportData
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTimeReportData>}
     * @memberof CollectionOfTimeReportData
     */
    'value'?: Array<PbxTimeReportData>;
}
/**
 * 
 * @export
 * @interface CollectionOfUser
 */
export interface CollectionOfUser {
    /**
     * 
     * @type {number}
     * @memberof CollectionOfUser
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxUser>}
     * @memberof CollectionOfUser
     */
    'value'?: Array<PbxUser>;
}
/**
 * 
 * @export
 * @interface ConferenceSettingsUpdateMCURequestStatusRequestBody
 */
export interface ConferenceSettingsUpdateMCURequestStatusRequestBody {
    /**
     * 
     * @type {PbxMCURequestStatus}
     * @memberof ConferenceSettingsUpdateMCURequestStatusRequestBody
     */
    'request'?: PbxMCURequestStatus;
}
/**
 * 
 * @export
 * @interface ContactsBatchContactsDeleteRequestBody
 */
export interface ContactsBatchContactsDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof ContactsBatchContactsDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ContactsSetDirSearchSettingsRequestBody
 */
export interface ContactsSetDirSearchSettingsRequestBody {
    /**
     * 
     * @type {PbxContactsDirSearchSettings}
     * @memberof ContactsSetDirSearchSettingsRequestBody
     */
    'dirSearchSettings'?: PbxContactsDirSearchSettings;
}
/**
 * 
 * @export
 * @interface CrmIntegrationSetOAuthStateRequestBody
 */
export interface CrmIntegrationSetOAuthStateRequestBody {
    /**
     * 
     * @type {PbxOauthStateParam}
     * @memberof CrmIntegrationSetOAuthStateRequestBody
     */
    'state'?: PbxOauthStateParam;
}
/**
 * 
 * @export
 * @interface CrmIntegrationTestRequestBody
 */
export interface CrmIntegrationTestRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CrmIntegrationTestRequestBody
     */
    'number'?: string;
}
/**
 * 
 * @export
 * @interface CustomPromptsMakeCallRecordCustomPromptRequestBody
 */
export interface CustomPromptsMakeCallRecordCustomPromptRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CustomPromptsMakeCallRecordCustomPromptRequestBody
     */
    'dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPromptsMakeCallRecordCustomPromptRequestBody
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface DNPropertiesCreateDNPropertyRequestBody
 */
export interface DNPropertiesCreateDNPropertyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DNPropertiesCreateDNPropertyRequestBody
     */
    'dnNumber'?: string;
    /**
     * 
     * @type {PbxDNProperty}
     * @memberof DNPropertiesCreateDNPropertyRequestBody
     */
    'property'?: PbxDNProperty;
}
/**
 * 
 * @export
 * @interface DNPropertiesDeleteDNPropertyRequestBody
 */
export interface DNPropertiesDeleteDNPropertyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DNPropertiesDeleteDNPropertyRequestBody
     */
    'dnNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof DNPropertiesDeleteDNPropertyRequestBody
     */
    'propertyName'?: string;
}
/**
 * 
 * @export
 * @interface DNPropertiesUpdateDNPropertyRequestBody
 */
export interface DNPropertiesUpdateDNPropertyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof DNPropertiesUpdateDNPropertyRequestBody
     */
    'dnNumber'?: string;
    /**
     * 
     * @type {PbxDNProperty}
     * @memberof DNPropertiesUpdateDNPropertyRequestBody
     */
    'property'?: PbxDNProperty;
}
/**
 * 
 * @export
 * @interface DefsGetRoutesRequestBody
 */
export interface DefsGetRoutesRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof DefsGetRoutesRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeviceInfosDeviceInfoProvisionRequestBody
 */
export interface DeviceInfosDeviceInfoProvisionRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceInfosDeviceInfoProvisionRequestBody
     */
    'reprovision'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeviceInfosDeviceInfoProvisionRequestBody
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface EmergencyGeoLocationsUpdateRequestBody
 */
export interface EmergencyGeoLocationsUpdateRequestBody {
    /**
     * 
     * @type {Array<PbxEmergencyGeoLocation>}
     * @memberof EmergencyGeoLocationsUpdateRequestBody
     */
    'locations'?: Array<PbxEmergencyGeoLocation>;
}
/**
 * 
 * @export
 * @interface FaxBulkFaxDeleteRequestBody
 */
export interface FaxBulkFaxDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof FaxBulkFaxDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface GenerateApiKey200Response
 */
export interface GenerateApiKey200Response {
    /**
     * 
     * @type {string}
     * @memberof GenerateApiKey200Response
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface GetActive200Response
 */
export interface GetActive200Response {
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'CultureCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'Folder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetActive200Response
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'LanguageCode'?: string | null;
    /**
     * 
     * @type {Array<PbxPrompt>}
     * @memberof GetActive200Response
     */
    'Prompts'?: Array<PbxPrompt>;
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'PromptSetName'?: string | null;
    /**
     * 
     * @type {PbxPromptSetType}
     * @memberof GetActive200Response
     */
    'PromptSetType'?: PbxPromptSetType | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetActive200Response
     */
    'UseAlternateNumberPronunciation'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GetActive200Response
     */
    'Version'?: string | null;
}


/**
 * 
 * @export
 * @interface GetAudioFiles200Response
 */
export interface GetAudioFiles200Response {
    /**
     * 
     * @type {number}
     * @memberof GetAudioFiles200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAudioFiles200Response
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetCallQualityReport200Response
 */
export interface GetCallQualityReport200Response {
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof GetCallQualityReport200Response
     */
    'MOS'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {number}
     * @memberof GetCallQualityReport200Response
     */
    'OverallScore'?: number | null;
    /**
     * 
     * @type {PbxQualityParty}
     * @memberof GetCallQualityReport200Response
     */
    'Party1'?: PbxQualityParty | null;
    /**
     * 
     * @type {PbxQualityParty}
     * @memberof GetCallQualityReport200Response
     */
    'Party2'?: PbxQualityParty | null;
    /**
     * 
     * @type {number}
     * @memberof GetCallQualityReport200Response
     */
    'Summary'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetCallQualityReport200Response
     */
    'Transcoding'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GetCanCreateBackup200Response
 */
export interface GetCanCreateBackup200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetCanCreateBackup200Response
     */
    'value'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCrmTemplateSource200Response
 */
export interface GetCrmTemplateSource200Response {
    /**
     * 
     * @type {string}
     * @memberof GetCrmTemplateSource200Response
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface GetDirectoryInfo200Response
 */
export interface GetDirectoryInfo200Response {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof GetDirectoryInfo200Response
     */
    'Dirs'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof GetDirectoryInfo200Response
     */
    'Path'?: string | null;
}
/**
 * 
 * @export
 * @interface GetFailoverScripts200Response
 */
export interface GetFailoverScripts200Response {
    /**
     * 
     * @type {number}
     * @memberof GetFailoverScripts200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFailoverScriptFile>}
     * @memberof GetFailoverScripts200Response
     */
    'value'?: Array<PbxFailoverScriptFile>;
}
/**
 * 
 * @export
 * @interface GetFaxFilesSize200Response
 */
export interface GetFaxFilesSize200Response {
    /**
     * 
     * @type {number}
     * @memberof GetFaxFilesSize200Response
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface GetMCURows200Response
 */
export interface GetMCURows200Response {
    /**
     * 
     * @type {number}
     * @memberof GetMCURows200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOnBoardMcuRow>}
     * @memberof GetMCURows200Response
     */
    'value'?: Array<PbxOnBoardMcuRow>;
}
/**
 * 
 * @export
 * @interface GetMonitorStatus200Response
 */
export interface GetMonitorStatus200Response {
    /**
     * 
     * @type {number}
     * @memberof GetMonitorStatus200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxMonitoringState>}
     * @memberof GetMonitorStatus200Response
     */
    'value'?: Array<PbxMonitoringState>;
}
/**
 * 
 * @export
 * @interface GetMultiEditGreetings200Response
 */
export interface GetMultiEditGreetings200Response {
    /**
     * 
     * @type {number}
     * @memberof GetMultiEditGreetings200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGreetingFile>}
     * @memberof GetMultiEditGreetings200Response
     */
    'value'?: Array<PbxGreetingFile>;
}
/**
 * 
 * @export
 * @interface GetOAuth200Response
 */
export interface GetOAuth200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOAuth200Response
     */
    'Key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOAuth200Response
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface GetOnboardMcuData200Response
 */
export interface GetOnboardMcuData200Response {
    /**
     * 
     * @type {number}
     * @memberof GetOnboardMcuData200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOnBoardMcuData>}
     * @memberof GetOnboardMcuData200Response
     */
    'value'?: Array<PbxOnBoardMcuData>;
}
/**
 * 
 * @export
 * @interface GetOnboardMeetings200Response
 */
export interface GetOnboardMeetings200Response {
    /**
     * 
     * @type {number}
     * @memberof GetOnboardMeetings200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOnBoardMeeting>}
     * @memberof GetOnboardMeetings200Response
     */
    'value'?: Array<PbxOnBoardMeeting>;
}
/**
 * 
 * @export
 * @interface GetPhoneRegistrars200Response
 */
export interface GetPhoneRegistrars200Response {
    /**
     * 
     * @type {number}
     * @memberof GetPhoneRegistrars200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneRegistrar>}
     * @memberof GetPhoneRegistrars200Response
     */
    'value'?: Array<PbxPhoneRegistrar>;
}
/**
 * 
 * @export
 * @interface GetRoutes200Response
 */
export interface GetRoutes200Response {
    /**
     * 
     * @type {number}
     * @memberof GetRoutes200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxSetRouteRequest>}
     * @memberof GetRoutes200Response
     */
    'value'?: Array<PbxSetRouteRequest>;
}
/**
 * 
 * @export
 * @interface GetTranscribeLanguages200Response
 */
export interface GetTranscribeLanguages200Response {
    /**
     * 
     * @type {number}
     * @memberof GetTranscribeLanguages200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxLanguageItem>}
     * @memberof GetTranscribeLanguages200Response
     */
    'value'?: Array<PbxLanguageItem>;
}
/**
 * 
 * @export
 * @interface GetUsersByPrincipalNames200Response
 */
export interface GetUsersByPrincipalNames200Response {
    /**
     * 
     * @type {number}
     * @memberof GetUsersByPrincipalNames200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxMicrosoft365User>}
     * @memberof GetUsersByPrincipalNames200Response
     */
    'value'?: Array<PbxMicrosoft365User>;
}
/**
 * 
 * @export
 * @interface GroupsDeleteCompanyByIdRequestBody
 */
export interface GroupsDeleteCompanyByIdRequestBody {
    /**
     * 
     * @type {number}
     * @memberof GroupsDeleteCompanyByIdRequestBody
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface GroupsDeleteCompanyByNumberRequestBody
 */
export interface GroupsDeleteCompanyByNumberRequestBody {
    /**
     * 
     * @type {string}
     * @memberof GroupsDeleteCompanyByNumberRequestBody
     */
    'number'?: string;
}
/**
 * 
 * @export
 * @interface GroupsLinkGroupPartnerRequestBody
 */
export interface GroupsLinkGroupPartnerRequestBody {
    /**
     * 
     * @type {string}
     * @memberof GroupsLinkGroupPartnerRequestBody
     */
    'resellerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsLinkGroupPartnerRequestBody
     */
    'groupId'?: string;
}
/**
 * 
 * @export
 * @interface GroupsReplaceGroupLicenseKeyRequestBody
 */
export interface GroupsReplaceGroupLicenseKeyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof GroupsReplaceGroupLicenseKeyRequestBody
     */
    'licenseKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsReplaceGroupLicenseKeyRequestBody
     */
    'groupId'?: string;
}
/**
 * 
 * @export
 * @interface InboundRulesBulkInboundRulesDeleteRequestBody
 */
export interface InboundRulesBulkInboundRulesDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof InboundRulesBulkInboundRulesDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface LicenseStatusEditLicenseInfoRequestBody
 */
export interface LicenseStatusEditLicenseInfoRequestBody {
    /**
     * 
     * @type {PbxXLicenseParams}
     * @memberof LicenseStatusEditLicenseInfoRequestBody
     */
    'licenseParams'?: PbxXLicenseParams;
}
/**
 * 
 * @export
 * @interface LicenseStatusLinkPartnerRequestBody
 */
export interface LicenseStatusLinkPartnerRequestBody {
    /**
     * 
     * @type {string}
     * @memberof LicenseStatusLinkPartnerRequestBody
     */
    'resellerId'?: string;
}
/**
 * 
 * @export
 * @interface LicenseStatusReplaceLicenseKeyRequestBody
 */
export interface LicenseStatusReplaceLicenseKeyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof LicenseStatusReplaceLicenseKeyRequestBody
     */
    'licenseKey'?: string;
}
/**
 * 
 * @export
 * @interface LinkMyGroupPartnerRequestBody
 */
export interface LinkMyGroupPartnerRequestBody {
    /**
     * 
     * @type {string}
     * @memberof LinkMyGroupPartnerRequestBody
     */
    'resellerId'?: string;
}
/**
 * 
 * @export
 * @interface MakeCall200Response
 */
export interface MakeCall200Response {
    /**
     * 
     * @type {string}
     * @memberof MakeCall200Response
     */
    'FinalStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof MakeCall200Response
     */
    'Reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof MakeCall200Response
     */
    'ReasonText'?: string;
    /**
     * 
     * @type {PbxCallParticipant}
     * @memberof MakeCall200Response
     */
    'Result'?: PbxCallParticipant | null;
}
/**
 * 
 * @export
 * @interface MakeCallUserRecordGreetingRequestBody
 */
export interface MakeCallUserRecordGreetingRequestBody {
    /**
     * 
     * @type {string}
     * @memberof MakeCallUserRecordGreetingRequestBody
     */
    'dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof MakeCallUserRecordGreetingRequestBody
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface Microsoft365IntegrationAuthorizePresenceRequestBody
 */
export interface Microsoft365IntegrationAuthorizePresenceRequestBody {
    /**
     * 
     * @type {string}
     * @memberof Microsoft365IntegrationAuthorizePresenceRequestBody
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody
 */
export interface Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody
     */
    'principalNames'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Microsoft365IntegrationGetUsersRequestBody
 */
export interface Microsoft365IntegrationGetUsersRequestBody {
    /**
     * 
     * @type {Microsoft365IntegrationGetUsersRequestBodyOptions}
     * @memberof Microsoft365IntegrationGetUsersRequestBody
     */
    'options'?: Microsoft365IntegrationGetUsersRequestBodyOptions;
}
/**
 * 
 * @export
 * @interface Microsoft365IntegrationGetUsersRequestBodyOptions
 */
export interface Microsoft365IntegrationGetUsersRequestBodyOptions {
    /**
     * 
     * @type {number}
     * @memberof Microsoft365IntegrationGetUsersRequestBodyOptions
     */
    'Count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Microsoft365IntegrationGetUsersRequestBodyOptions
     */
    'Search'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Microsoft365IntegrationGetUsersRequestBodyOptions
     */
    'Start'?: number;
    /**
     * 
     * @type {PbxTypeOfUser}
     * @memberof Microsoft365IntegrationGetUsersRequestBodyOptions
     */
    'TypeOfUser'?: PbxTypeOfUser;
}


/**
 * 
 * @export
 * @interface NotificationSettingsTestEmailRequestBody
 */
export interface NotificationSettingsTestEmailRequestBody {
    /**
     * 
     * @type {PbxNotificationSettings}
     * @memberof NotificationSettingsTestEmailRequestBody
     */
    'settings'?: PbxNotificationSettings;
}
/**
 * 
 * @export
 * @interface OutboundRulesMoveUpDownRequestBody
 */
export interface OutboundRulesMoveUpDownRequestBody {
    /**
     * 
     * @type {number}
     * @memberof OutboundRulesMoveUpDownRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OutboundRulesMoveUpDownRequestBody
     */
    'up'?: boolean;
}
/**
 * 
 * @export
 * @interface OutboundRulesPurgeRequestBody
 */
export interface OutboundRulesPurgeRequestBody {
    /**
     * 
     * @type {OutboundRulesPurgeRequestBodyPurgeObject}
     * @memberof OutboundRulesPurgeRequestBody
     */
    'purgeObject'?: OutboundRulesPurgeRequestBodyPurgeObject;
}
/**
 * 
 * @export
 * @interface OutboundRulesPurgeRequestBodyPurgeObject
 */
export interface OutboundRulesPurgeRequestBodyPurgeObject {
    /**
     * 
     * @type {Array<number>}
     * @memberof OutboundRulesPurgeRequestBodyPurgeObject
     */
    'Ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PbxADUsersSyncConfiguration
 */
export interface PbxADUsersSyncConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'EnableSSO'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'IsEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'IsSyncOfficePhone'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'IsSyncPhoto'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SelectedUsers'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SetTeamsPresence'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxADUsersSyncConfiguration
     */
    'StartingExtensionNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SyncEvents'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SyncGuestUsers'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SyncPersonalContacts'?: boolean | null;
    /**
     * 
     * @type {PbxIntegrationSyncType}
     * @memberof PbxADUsersSyncConfiguration
     */
    'SyncType'?: PbxIntegrationSyncType | null;
}


/**
 * 
 * @export
 * @interface PbxAbandonedChatsStatistics
 */
export interface PbxAbandonedChatsStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ChatId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'DateOfRequest'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ParticipantEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ParticipantMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ParticipantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ParticipantNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'QueueDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'QueueNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ReasonForAbandoned'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'ReasonForDealtWith'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedChatsStatistics
     */
    'Source'?: string;
}
/**
 * 
 * @export
 * @interface PbxAbandonedChatsStatisticsCollectionResponse
 */
export interface PbxAbandonedChatsStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxAbandonedChatsStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAbandonedChatsStatistics>}
     * @memberof PbxAbandonedChatsStatisticsCollectionResponse
     */
    'value'?: Array<PbxAbandonedChatsStatistics>;
}
/**
 * 
 * @export
 * @interface PbxAbandonedQueueCalls
 */
export interface PbxAbandonedQueueCalls {
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'CallerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'CallHistoryId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'CallTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'CallTimeForCsv'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'ExtensionDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'ExtensionDn'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxAbandonedQueueCalls
     */
    'IsLoggedIn'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAbandonedQueueCalls
     */
    'PollingAttempts'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'QueueDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'QueueDn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAbandonedQueueCalls
     */
    'WaitTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxAbandonedQueueCallsCollectionResponse
 */
export interface PbxAbandonedQueueCallsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxAbandonedQueueCallsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAbandonedQueueCalls>}
     * @memberof PbxAbandonedQueueCallsCollectionResponse
     */
    'value'?: Array<PbxAbandonedQueueCalls>;
}
/**
 * 
 * @export
 * @interface PbxActiveCall
 */
export interface PbxActiveCall {
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'Callee'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'Caller'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'EstablishedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxActiveCall
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'LastChangeStatus'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'ServerNow'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxActiveCall
     */
    'Status'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxActiveCallCollectionResponse
 */
export interface PbxActiveCallCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxActiveCallCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxActiveCall>}
     * @memberof PbxActiveCallCollectionResponse
     */
    'value'?: Array<PbxActiveCall>;
}
/**
 * 
 * @export
 * @interface PbxActivityLogEvent
 */
export interface PbxActivityLogEvent {
    /**
     * 
     * @type {number}
     * @memberof PbxActivityLogEvent
     */
    'Index'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxActivityLogEvent
     */
    'Message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxActivityLogEvent
     */
    'TimeStamp'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxActivityLogEventCollectionResponse
 */
export interface PbxActivityLogEventCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxActivityLogEventCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxActivityLogEvent>}
     * @memberof PbxActivityLogEventCollectionResponse
     */
    'value'?: Array<PbxActivityLogEvent>;
}
/**
 * 
 * @export
 * @interface PbxActivityLogsFilter
 */
export interface PbxActivityLogsFilter {
    /**
     * 
     * @type {Array<PbxExtensionFilter>}
     * @memberof PbxActivityLogsFilter
     */
    'Extensions'?: Array<PbxExtensionFilter>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxAddedBy = {
    Manual: 'Manual',
    Mcu: 'Mcu',
    Webmeeting: 'Webmeeting',
    AutoBlacklist: 'AutoBlacklist',
    Whitelist: 'Whitelist'
} as const;

export type PbxAddedBy = typeof PbxAddedBy[keyof typeof PbxAddedBy];


/**
 * 
 * @export
 * @interface PbxAgentLoginHistory
 */
export interface PbxAgentLoginHistory {
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'Agent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'AgentNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'Day'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'LoggedInDayInterval'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'loggedInDt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'LoggedInInterval'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'LoggedInTotalInterval'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'LoggedOutDt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'QueueNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'TalkingDayInterval'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'TalkingInterval'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentLoginHistory
     */
    'TalkingTotalInterval'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxAgentLoginHistoryCollectionResponse
 */
export interface PbxAgentLoginHistoryCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxAgentLoginHistoryCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAgentLoginHistory>}
     * @memberof PbxAgentLoginHistoryCollectionResponse
     */
    'value'?: Array<PbxAgentLoginHistory>;
}
/**
 * 
 * @export
 * @interface PbxAgentsInQueueStatistics
 */
export interface PbxAgentsInQueueStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxAgentsInQueueStatistics
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAgentsInQueueStatistics
     */
    'AnsweredPercent'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAgentsInQueueStatistics
     */
    'AnsweredPerHourCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'AvgRingTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'AvgTalkTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'Dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'DnDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'LoggedInTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAgentsInQueueStatistics
     */
    'LostCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'Queue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'QueueDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'RingTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAgentsInQueueStatistics
     */
    'TalkTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxAgentsInQueueStatisticsCollectionResponse
 */
export interface PbxAgentsInQueueStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxAgentsInQueueStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAgentsInQueueStatistics>}
     * @memberof PbxAgentsInQueueStatisticsCollectionResponse
     */
    'value'?: Array<PbxAgentsInQueueStatistics>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxAnimationStyle = {
    SlideUp: 'SlideUp',
    SlideFromSide: 'SlideFromSide',
    FadeIn: 'FadeIn',
    NoAnimation: 'NoAnimation'
} as const;

export type PbxAnimationStyle = typeof PbxAnimationStyle[keyof typeof PbxAnimationStyle];


/**
 * 
 * @export
 * @interface PbxAntiHackingSettings
 */
export interface PbxAntiHackingSettings {
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackAuthRequests'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackBarrierAmber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackBarrierGreen'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackBarrierRed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackBlacklistDuration'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'HackChallengeRequests'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'MaxRequestPerPeriod'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxAntiHackingSettings
     */
    'SecurityDefenseProgram'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAntiHackingSettings
     */
    'ThrottlePeriodLength'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxArchiveSubsystem
 */
export interface PbxArchiveSubsystem {
    /**
     * 
     * @type {boolean}
     * @memberof PbxArchiveSubsystem
     */
    'Archiving'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxArchiveSubsystem
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxArchiveSubsystem
     */
    'Folder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxArchiveSubsystem
     */
    'ScheduleDays'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxAuditLog
 */
export interface PbxAuditLog {
    /**
     * 
     * @type {number}
     * @memberof PbxAuditLog
     */
    'Action'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAuditLog
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'Ip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'NewData'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'ObjectName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAuditLog
     */
    'ObjectType'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'PrevData'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxAuditLog
     */
    'Source'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'Timestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAuditLog
     */
    'UserName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxAuditLogCollectionResponse
 */
export interface PbxAuditLogCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxAuditLogCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxAuditLog>}
     * @memberof PbxAuditLogCollectionResponse
     */
    'value'?: Array<PbxAuditLog>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxAuthentication = {
    Both: 'Both',
    Name: 'Name',
    Email: 'Email',
    None: 'None'
} as const;

export type PbxAuthentication = typeof PbxAuthentication[keyof typeof PbxAuthentication];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxAuthenticationType = {
    False: 'false',
    Basic: 'Basic',
    Scenario: 'Scenario'
} as const;

export type PbxAuthenticationType = typeof PbxAuthenticationType[keyof typeof PbxAuthenticationType];


/**
 * 
 * @export
 * @interface PbxAutoSchedulerSettings
 */
export interface PbxAutoSchedulerSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxAutoSchedulerSettings
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAutoSchedulerSettings
     */
    'ProfileAvailable'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAutoSchedulerSettings
     */
    'ProfileAway'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxAutoSchedulerSettings
     */
    'ProfileDND'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxAvailableRouting
 */
export interface PbxAvailableRouting {
    /**
     * 
     * @type {boolean}
     * @memberof PbxAvailableRouting
     */
    'BusyAllCalls'?: boolean | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'BusyExternal'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'BusyInternal'?: PbxDestination | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxAvailableRouting
     */
    'NoAnswerAllCalls'?: boolean | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'NoAnswerExternal'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'NoAnswerInternal'?: PbxDestination | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxAvailableRouting
     */
    'NotRegisteredAllCalls'?: boolean | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'NotRegisteredExternal'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAvailableRouting
     */
    'NotRegisteredInternal'?: PbxDestination | null;
}
/**
 * 
 * @export
 * @interface PbxAwayRouting
 */
export interface PbxAwayRouting {
    /**
     * 
     * @type {boolean}
     * @memberof PbxAwayRouting
     */
    'AllHoursExternal'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxAwayRouting
     */
    'AllHoursInternal'?: boolean | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAwayRouting
     */
    'External'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxAwayRouting
     */
    'Internal'?: PbxDestination | null;
}
/**
 * 
 * @export
 * @interface PbxBackupContents
 */
export interface PbxBackupContents {
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'CallHistory'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'DisableBackupCompression'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'EncryptBackup'?: boolean | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxBackupContents
     */
    'EncryptBackupPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'FQDN'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'License'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'PhoneProvisioning'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'Prompts'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'Recordings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupContents
     */
    'VoiceMails'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxBackupExtras
 */
export interface PbxBackupExtras {
    /**
     * 
     * @type {number}
     * @memberof PbxBackupExtras
     */
    'Footprint'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupExtras
     */
    'IsEncrypted'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackupExtras
     */
    'Version'?: string;
}
/**
 * 
 * @export
 * @interface PbxBackupFailoverSettings
 */
export interface PbxBackupFailoverSettings {
    /**
     * 
     * @type {PbxFailoverCondition}
     * @memberof PbxBackupFailoverSettings
     */
    'Condition'?: PbxFailoverCondition | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupFailoverSettings
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxBackupFailoverSettings
     */
    'Interval'?: number | null;
    /**
     * 
     * @type {PbxFailoverMode}
     * @memberof PbxBackupFailoverSettings
     */
    'Mode'?: PbxFailoverMode | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackupFailoverSettings
     */
    'PostStartScript'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackupFailoverSettings
     */
    'PreStartScript'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackupFailoverSettings
     */
    'RemoteServer'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupFailoverSettings
     */
    'TestSIPServer'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupFailoverSettings
     */
    'TestTunnel'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupFailoverSettings
     */
    'TestWebServer'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxBackupRepositorySettings
 */
export interface PbxBackupRepositorySettings {
    /**
     * 
     * @type {PbxLocationSettings}
     * @memberof PbxBackupRepositorySettings
     */
    'Location'?: PbxLocationSettings | null;
}
/**
 * 
 * @export
 * @interface PbxBackupSchedule
 */
export interface PbxBackupSchedule {
    /**
     * 
     * @type {PbxDayOfWeek}
     * @memberof PbxBackupSchedule
     */
    'Day'?: PbxDayOfWeek | null;
    /**
     * 
     * @type {number}
     * @memberof PbxBackupSchedule
     */
    'RepeatHours'?: number | null;
    /**
     * 
     * @type {PbxScheduleType}
     * @memberof PbxBackupSchedule
     */
    'ScheduleType'?: PbxScheduleType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackupSchedule
     */
    'Time'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxBackupSettings
 */
export interface PbxBackupSettings {
    /**
     * 
     * @type {PbxBackupContents}
     * @memberof PbxBackupSettings
     */
    'Contents'?: PbxBackupContents | null;
    /**
     * 
     * @type {number}
     * @memberof PbxBackupSettings
     */
    'Rotation'?: number | null;
    /**
     * 
     * @type {PbxBackupSchedule}
     * @memberof PbxBackupSettings
     */
    'Schedule'?: PbxBackupSchedule | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxBackupSettings
     */
    'ScheduleEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxBackups
 */
export interface PbxBackups {
    /**
     * 
     * @type {string}
     * @memberof PbxBackups
     */
    'CreationTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBackups
     */
    'DownloadLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxBackups
     */
    'FileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxBackups
     */
    'Size'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxBackupsCollectionResponse
 */
export interface PbxBackupsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxBackupsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxBackups>}
     * @memberof PbxBackupsCollectionResponse
     */
    'value'?: Array<PbxBackups>;
}
/**
 * 
 * @export
 * @interface PbxBlackListNumber
 */
export interface PbxBlackListNumber {
    /**
     * 
     * @type {string}
     * @memberof PbxBlackListNumber
     */
    'CallerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxBlackListNumber
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBlackListNumber
     */
    'Id'?: string;
}
/**
 * 
 * @export
 * @interface PbxBlackListNumberCollectionResponse
 */
export interface PbxBlackListNumberCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxBlackListNumberCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxBlackListNumber>}
     * @memberof PbxBlackListNumberCollectionResponse
     */
    'value'?: Array<PbxBlackListNumber>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxBlockType = {
    Block: 'Block',
    Allow: 'Allow'
} as const;

export type PbxBlockType = typeof PbxBlockType[keyof typeof PbxBlockType];


/**
 * 
 * @export
 * @interface PbxBlocklistAddr
 */
export interface PbxBlocklistAddr {
    /**
     * 
     * @type {PbxAddedBy}
     * @memberof PbxBlocklistAddr
     */
    'AddedBy'?: PbxAddedBy | null;
    /**
     * 
     * @type {PbxBlockType}
     * @memberof PbxBlocklistAddr
     */
    'BlockType'?: PbxBlockType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBlocklistAddr
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBlocklistAddr
     */
    'ExpiresAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxBlocklistAddr
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxBlocklistAddr
     */
    'IPAddrMask'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxBlocklistAddrCollectionResponse
 */
export interface PbxBlocklistAddrCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxBlocklistAddrCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxBlocklistAddr>}
     * @memberof PbxBlocklistAddrCollectionResponse
     */
    'value'?: Array<PbxBlocklistAddr>;
}
/**
 * 
 * @export
 * @interface PbxBreachesSla
 */
export interface PbxBreachesSla {
    /**
     * 
     * @type {string}
     * @memberof PbxBreachesSla
     */
    'CallerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxBreachesSla
     */
    'CallTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxBreachesSla
     */
    'Queue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxBreachesSla
     */
    'QueueDnNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxBreachesSla
     */
    'WaitingTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxBreachesSlaCollectionResponse
 */
export interface PbxBreachesSlaCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxBreachesSlaCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxBreachesSla>}
     * @memberof PbxBreachesSlaCollectionResponse
     */
    'value'?: Array<PbxBreachesSla>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxButtonIconType = {
    Url: 'Url',
    Default: 'Default',
    Bubble: 'Bubble',
    DoubleBubble: 'DoubleBubble'
} as const;

export type PbxButtonIconType = typeof PbxButtonIconType[keyof typeof PbxButtonIconType];


/**
 * 
 * @export
 * @interface PbxCDRSettings
 */
export interface PbxCDRSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxCDRSettings
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {Array<PbxCDRSettingsField>}
     * @memberof PbxCDRSettings
     */
    'EnabledFields'?: Array<PbxCDRSettingsField>;
    /**
     * 
     * @type {number}
     * @memberof PbxCDRSettings
     */
    'LogSize'?: number | null;
    /**
     * 
     * @type {PbxTypeOfCDRLog}
     * @memberof PbxCDRSettings
     */
    'LogType'?: PbxTypeOfCDRLog | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCDRSettings
     */
    'PossibleFields'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCDRSettings
     */
    'RemoveCommaDelimiters'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCDRSettings
     */
    'SocketIpAddress'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCDRSettings
     */
    'SocketPort'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxCDRSettingsField
 */
export interface PbxCDRSettingsField {
    /**
     * 
     * @type {number}
     * @memberof PbxCDRSettingsField
     */
    'Length'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCDRSettingsField
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCDRSettingsFieldCollectionResponse
 */
export interface PbxCDRSettingsFieldCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCDRSettingsFieldCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCDRSettingsField>}
     * @memberof PbxCDRSettingsFieldCollectionResponse
     */
    'value'?: Array<PbxCDRSettingsField>;
}
/**
 * 
 * @export
 * @interface PbxCIDFormatting
 */
export interface PbxCIDFormatting {
    /**
     * 
     * @type {number}
     * @memberof PbxCIDFormatting
     */
    'Priority'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCIDFormatting
     */
    'ReplacePattern'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCIDFormatting
     */
    'SourcePattern'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCIDFormattingCollectionResponse
 */
export interface PbxCIDFormattingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCIDFormattingCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCIDFormatting>}
     * @memberof PbxCIDFormattingCollectionResponse
     */
    'value'?: Array<PbxCIDFormatting>;
}
/**
 * 
 * @export
 * @interface PbxCallControlResultResponse
 */
export interface PbxCallControlResultResponse {
    /**
     * 
     * @type {string}
     * @memberof PbxCallControlResultResponse
     */
    'FinalStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallControlResultResponse
     */
    'Reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallControlResultResponse
     */
    'ReasonText'?: string;
    /**
     * 
     * @type {PbxCallParticipant}
     * @memberof PbxCallControlResultResponse
     */
    'Result'?: PbxCallParticipant | null;
}
/**
 * 
 * @export
 * @interface PbxCallCostByExtensionGroup
 */
export interface PbxCallCostByExtensionGroup {
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostByExtensionGroup
     */
    'BillingCost'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'CallType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'DstDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostByExtensionGroup
     */
    'DstDnClass'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'GroupName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallCostByExtensionGroup
     */
    'IsAnswered'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'RingingDur'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostByExtensionGroup
     */
    'SegId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'SrcDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'SrcDn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'StartTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostByExtensionGroup
     */
    'TalkingDur'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCallCostByExtensionGroupCollectionResponse
 */
export interface PbxCallCostByExtensionGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostByExtensionGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallCostByExtensionGroup>}
     * @memberof PbxCallCostByExtensionGroupCollectionResponse
     */
    'value'?: Array<PbxCallCostByExtensionGroup>;
}
/**
 * 
 * @export
 * @interface PbxCallCostSettings
 */
export interface PbxCallCostSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostSettings
     */
    'CountryName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostSettings
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallCostSettings
     */
    'Invalid'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallCostSettings
     */
    'Prefix'?: string | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxCallCostSettings
     */
    'Rate'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallCostSettings
     */
    'ReadOnly'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxCallCostSettingsCollectionResponse
 */
export interface PbxCallCostSettingsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallCostSettingsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallCostSettings>}
     * @memberof PbxCallCostSettingsCollectionResponse
     */
    'value'?: Array<PbxCallCostSettings>;
}
/**
 * @type PbxCallCostSettingsRate
 * @export
 */
export type PbxCallCostSettingsRate = ReferenceNumeric | number | string;

/**
 * 
 * @export
 * @interface PbxCallFlowApp
 */
export interface PbxCallFlowApp {
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'CompilationLastSuccess'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'CompilationResult'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallFlowApp
     */
    'CompilationSucceeded'?: boolean | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxCallFlowApp
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {number}
     * @memberof PbxCallFlowApp
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallFlowApp
     */
    'InvalidScript'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallFlowApp
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'Number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'RejectedCode'?: string | null;
    /**
     * 
     * @type {PbxCfaRoutingType}
     * @memberof PbxCallFlowApp
     */
    'RoutingType'?: PbxCfaRoutingType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowApp
     */
    'ScriptCode'?: string | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxCallFlowApp
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {PbxTrunk}
     * @memberof PbxCallFlowApp
     */
    'Trunk'?: PbxTrunk | null;
}


/**
 * 
 * @export
 * @interface PbxCallFlowAppCollectionResponse
 */
export interface PbxCallFlowAppCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallFlowAppCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallFlowApp>}
     * @memberof PbxCallFlowAppCollectionResponse
     */
    'value'?: Array<PbxCallFlowApp>;
}
/**
 * 
 * @export
 * @interface PbxCallFlowScript
 */
export interface PbxCallFlowScript {
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowScript
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowScript
     */
    'Help'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallFlowScript
     */
    'Id'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCallFlowScript
     */
    'Versions'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface PbxCallFlowScriptCollectionResponse
 */
export interface PbxCallFlowScriptCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallFlowScriptCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallFlowScript>}
     * @memberof PbxCallFlowScriptCollectionResponse
     */
    'value'?: Array<PbxCallFlowScript>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxCallHandlingFlags = {
    WelcomeMessageForIncomingCalls: 'WelcomeMessageForIncomingCalls',
    HoldCall: 'HoldCall'
} as const;

export type PbxCallHandlingFlags = typeof PbxCallHandlingFlags[keyof typeof PbxCallHandlingFlags];


/**
 * 
 * @export
 * @interface PbxCallHistoryView
 */
export interface PbxCallHistoryView {
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallHistoryView
     */
    'CallAnswered'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'CallTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'DstCallerNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'DstDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'DstDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'DstDnType'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'DstExtendedDisplayName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallHistoryView
     */
    'DstExternal'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'DstId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallHistoryView
     */
    'DstInternal'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'DstParticipantId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'DstRecId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SegmentActionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SegmentEndTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SegmentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SegmentStartTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SegmentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SrcCallerNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SrcDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SrcDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SrcDnType'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallHistoryView
     */
    'SrcExtendedDisplayName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallHistoryView
     */
    'SrcExternal'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SrcId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallHistoryView
     */
    'SrcInternal'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SrcParticipantId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryView
     */
    'SrcRecId'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxCallHistoryViewCollectionResponse
 */
export interface PbxCallHistoryViewCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallHistoryViewCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallHistoryView>}
     * @memberof PbxCallHistoryViewCollectionResponse
     */
    'value'?: Array<PbxCallHistoryView>;
}
/**
 * 
 * @export
 * @interface PbxCallLogData
 */
export interface PbxCallLogData {
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'ActionDnCallerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'ActionDnDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'actionDnDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'ActionDnType'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'ActionType'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallLogData
     */
    'Answered'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'CallCost'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'CallId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'DestinationCallerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'DestinationDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'DestinationDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'DestinationType'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'DstRecId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'Indent'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallLogData
     */
    'QualityReport'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'Reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'RecordingUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'RingingDuration'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'SegmentId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'SentimentScore'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'SourceCallerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'SourceDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'SourceDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'SourceType'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'SrcRecId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'StartTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogData
     */
    'SubrowDescNumber'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'Summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'TalkingDuration'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallLogData
     */
    'Transcription'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCallLogDataCollectionResponse
 */
export interface PbxCallLogDataCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCallLogDataCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCallLogData>}
     * @memberof PbxCallLogDataCollectionResponse
     */
    'value'?: Array<PbxCallLogData>;
}
/**
 * 
 * @export
 * @interface PbxCallParkingSettings
 */
export interface PbxCallParkingSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallParkingSettings
     */
    'AutoPickupEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParkingSettings
     */
    'AutoPickupForwardDN'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParkingSettings
     */
    'AutoPickupForwardExternalNumber'?: string | null;
    /**
     * 
     * @type {PbxTypeOfAutoPickupForward}
     * @memberof PbxCallParkingSettings
     */
    'AutoPickupForwardType'?: PbxTypeOfAutoPickupForward | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallParkingSettings
     */
    'AutoPickupTimeout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCallParkingSettings
     */
    'MaximumParkedCalls'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParkingSettings
     */
    'MusicOnHold'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxCallParticipant
 */
export interface PbxCallParticipant {
    /**
     * 
     * @type {number}
     * @memberof PbxCallParticipant
     */
    'CallId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'DeviceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCallParticipant
     */
    'DirectControl'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'DN'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxCallParticipant
     */
    'Id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxCallParticipant
     */
    'LegId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'PartyCallerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'PartyCallerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'PartyDn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'PartyDnType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCallParticipant
     */
    'Status'?: string;
}
/**
 * 
 * @export
 * @interface PbxCallTypeInfo
 */
export interface PbxCallTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof PbxCallTypeInfo
     */
    'DigitsLength'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCallTypeInfo
     */
    'Prefix'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCallTypesSettings
 */
export interface PbxCallTypesSettings {
    /**
     * 
     * @type {PbxCallTypeInfo}
     * @memberof PbxCallTypesSettings
     */
    'International'?: PbxCallTypeInfo | null;
    /**
     * 
     * @type {PbxCallTypeInfo}
     * @memberof PbxCallTypesSettings
     */
    'Local'?: PbxCallTypeInfo | null;
    /**
     * 
     * @type {PbxCallTypeInfo}
     * @memberof PbxCallTypesSettings
     */
    'Mobile'?: PbxCallTypeInfo | null;
    /**
     * 
     * @type {PbxCallTypeInfo}
     * @memberof PbxCallTypesSettings
     */
    'National'?: PbxCallTypeInfo | null;
}
/**
 * 
 * @export
 * @interface PbxCategoryUpdate
 */
export interface PbxCategoryUpdate {
    /**
     * 
     * @type {string}
     * @memberof PbxCategoryUpdate
     */
    'Category'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxCategoryUpdate
     */
    'Count'?: number;
}
/**
 * 
 * @export
 * @interface PbxCategoryUpdateCollectionResponse
 */
export interface PbxCategoryUpdateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCategoryUpdateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCategoryUpdate>}
     * @memberof PbxCategoryUpdateCollectionResponse
     */
    'value'?: Array<PbxCategoryUpdate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxCfaRoutingType = {
    DialCode: 'DialCode',
    Forward: 'Forward',
    Trunk: 'Trunk'
} as const;

export type PbxCfaRoutingType = typeof PbxCfaRoutingType[keyof typeof PbxCfaRoutingType];


/**
 * 
 * @export
 * @interface PbxChatHistoryView
 */
export interface PbxChatHistoryView {
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'ChatName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxChatHistoryView
     */
    'ConversationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'FromName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'FromNo'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxChatHistoryView
     */
    'IsExternal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'Message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'ParticipantEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'ParticipantIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'ParticipantPhone'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxChatHistoryView
     */
    'ParticipantsGroupsArray'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'ProviderName'?: string | null;
    /**
     * 
     * @type {PbxChatType}
     * @memberof PbxChatHistoryView
     */
    'ProviderType'?: PbxChatType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'QueueNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'Source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatHistoryView
     */
    'TimeSent'?: string;
}


/**
 * 
 * @export
 * @interface PbxChatHistoryViewCollectionResponse
 */
export interface PbxChatHistoryViewCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxChatHistoryViewCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxChatHistoryView>}
     * @memberof PbxChatHistoryViewCollectionResponse
     */
    'value'?: Array<PbxChatHistoryView>;
}
/**
 * 
 * @export
 * @interface PbxChatLinkNameValidation
 */
export interface PbxChatLinkNameValidation {
    /**
     * 
     * @type {string}
     * @memberof PbxChatLinkNameValidation
     */
    'FriendlyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxChatLinkNameValidation
     */
    'Pair'?: string;
}
/**
 * 
 * @export
 * @interface PbxChatLogSettings
 */
export interface PbxChatLogSettings {
    /**
     * 
     * @type {number}
     * @memberof PbxChatLogSettings
     */
    'AutoClearMonths'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxChatLogSettings
     */
    'AutoCloseDays'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxChatLogSettings
     */
    'RemoteStorageEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxChatMessagesHistoryView
 */
export interface PbxChatMessagesHistoryView {
    /**
     * 
     * @type {number}
     * @memberof PbxChatMessagesHistoryView
     */
    'ConversationId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxChatMessagesHistoryView
     */
    'IsExternal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'Message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxChatMessagesHistoryView
     */
    'MessageId'?: number;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxChatMessagesHistoryView
     */
    'ParticipantsGroupsArray'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'QueueNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'Recipients'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantNo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantPbx'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'SenderParticipantPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxChatMessagesHistoryView
     */
    'TimeSent'?: string;
}
/**
 * 
 * @export
 * @interface PbxChatMessagesHistoryViewCollectionResponse
 */
export interface PbxChatMessagesHistoryViewCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxChatMessagesHistoryViewCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxChatMessagesHistoryView>}
     * @memberof PbxChatMessagesHistoryViewCollectionResponse
     */
    'value'?: Array<PbxChatMessagesHistoryView>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxChatRecipientsType = {
    None: 'None',
    MyGroupManagers: 'MyGroupManagers',
    MyGroupAllMembers: 'MyGroupAllMembers',
    AllGroupsManagers: 'AllGroupsManagers'
} as const;

export type PbxChatRecipientsType = typeof PbxChatRecipientsType[keyof typeof PbxChatRecipientsType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxChatType = {
    Sms: 'SMS',
    LiveChat: 'LiveChat',
    Facebook: 'Facebook',
    Internal: 'Internal',
    Rcs: 'RCS'
} as const;

export type PbxChatType = typeof PbxChatType[keyof typeof PbxChatType];


/**
 * 
 * @export
 * @interface PbxChoice
 */
export interface PbxChoice {
    /**
     * 
     * @type {string}
     * @memberof PbxChoice
     */
    'Key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxChoice
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface PbxChoiceCollectionResponse
 */
export interface PbxChoiceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxChoiceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxChoice>}
     * @memberof PbxChoiceCollectionResponse
     */
    'value'?: Array<PbxChoice>;
}
/**
 * 
 * @export
 * @interface PbxCodec
 */
export interface PbxCodec {
    /**
     * 
     * @type {number}
     * @memberof PbxCodec
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCodec
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCodec
     */
    'RfcName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCodecCollectionResponse
 */
export interface PbxCodecCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCodecCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCodec>}
     * @memberof PbxCodecCollectionResponse
     */
    'value'?: Array<PbxCodec>;
}
/**
 * 
 * @export
 * @interface PbxCodecsSettings
 */
export interface PbxCodecsSettings {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCodecsSettings
     */
    'ExternalCodecList'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCodecsSettings
     */
    'LocalCodecList'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface PbxConcealedDataFile
 */
export interface PbxConcealedDataFile {
    /**
     * 
     * @type {boolean}
     * @memberof PbxConcealedDataFile
     */
    'Concealed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConcealedDataFile
     */
    'Contents'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConcealedDataFile
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxConcealedPassword
 */
export interface PbxConcealedPassword {
    /**
     * 
     * @type {boolean}
     * @memberof PbxConcealedPassword
     */
    'Concealed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConcealedPassword
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxConferenceSettings
 */
export interface PbxConferenceSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'ApiKey'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxConferenceSettings
     */
    'AutoCallParticipants'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxConferenceSettings
     */
    'EnableLocalMCU'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxConferenceSettings
     */
    'EnablePin'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'Extension'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'ExternalNumbers'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxConferenceSettings
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'LogoPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'MusicOnHold'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'PinNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConferenceSettings
     */
    'Zone'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxConsoleRestrictions
 */
export interface PbxConsoleRestrictions {
    /**
     * 
     * @type {boolean}
     * @memberof PbxConsoleRestrictions
     */
    'AccessRestricted'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxConsoleRestrictions
     */
    'Id'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxConsoleRestrictions
     */
    'IpWhitelist'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxConsoleRestrictions
     */
    'MyIpAddress'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxContact
 */
export interface PbxContact {
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Business'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Business2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'BusinessFax'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'CompanyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'ContactType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Department'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'FirstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Home'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxContact
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'LastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Mobile2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Pager'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'PhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Tag'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContact
     */
    'Title'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxContactCollectionResponse
 */
export interface PbxContactCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxContactCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxContact>}
     * @memberof PbxContactCollectionResponse
     */
    'value'?: Array<PbxContact>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxContactType = {
    Company: 'Company',
    Personal: 'Personal'
} as const;

export type PbxContactType = typeof PbxContactType[keyof typeof PbxContactType];


/**
 * 
 * @export
 * @interface PbxContactsDirSearchSettings
 */
export interface PbxContactsDirSearchSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangeCalendarProfileSwitching'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangeEmailAddresses'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangeFolders'?: Array<string | null>;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangePassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangeServerUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxContactsDirSearchSettings
     */
    'ExchangeUser'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCountry
 */
export interface PbxCountry {
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'Continent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'CountryCode'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCountry
     */
    'CountryCodes'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'DownloadUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'ErpCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'ExitCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'ParentErpCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'StunServer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'VoicemailNo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCountry
     */
    'WebMeetingZone'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCountryCodes
 */
export interface PbxCountryCodes {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCountryCodes
     */
    'CountryCodes'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface PbxCountryCollectionResponse
 */
export interface PbxCountryCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCountryCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCountry>}
     * @memberof PbxCountryCollectionResponse
     */
    'value'?: Array<PbxCountry>;
}
/**
 * 
 * @export
 * @interface PbxCreateBackup
 */
export interface PbxCreateBackup {
    /**
     * 
     * @type {PbxBackupContents}
     * @memberof PbxCreateBackup
     */
    'Contents'?: PbxBackupContents | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCreateBackup
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface PbxCreateTrunk
 */
export interface PbxCreateTrunk {
    /**
     * 
     * @type {string}
     * @memberof PbxCreateTrunk
     */
    'Name'?: string;
    /**
     * 
     * @type {PbxTrunkType}
     * @memberof PbxCreateTrunk
     */
    'TrunkType'?: PbxTrunkType;
}


/**
 * 
 * @export
 * @interface PbxCrmAuthentication
 */
export interface PbxCrmAuthentication {
    /**
     * 
     * @type {PbxAuthenticationType}
     * @memberof PbxCrmAuthentication
     */
    'Type'?: PbxAuthenticationType | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCrmAuthentication
     */
    'Values'?: Array<string | null>;
}


/**
 * 
 * @export
 * @interface PbxCrmChoice
 */
export interface PbxCrmChoice {
    /**
     * 
     * @type {string}
     * @memberof PbxCrmChoice
     */
    'Key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmChoice
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCrmChoiceCollectionResponse
 */
export interface PbxCrmChoiceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmChoiceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmChoice>}
     * @memberof PbxCrmChoiceCollectionResponse
     */
    'value'?: Array<PbxCrmChoice>;
}
/**
 * 
 * @export
 * @interface PbxCrmContact
 */
export interface PbxCrmContact {
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'CompanyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'ContactRawData'?: string | null;
    /**
     * 
     * @type {PbxContactType}
     * @memberof PbxCrmContact
     */
    'ContactType'?: PbxContactType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'ContactUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'Department'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'Email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'FaxBusiness'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'FirstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'LastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'Pager'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneBusiness'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneBusiness2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneHome'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneMobile'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneMobile2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhoneOther'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'PhotoUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmContact
     */
    'Title'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxCrmContactCollectionResponse
 */
export interface PbxCrmContactCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmContactCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmContact>}
     * @memberof PbxCrmContactCollectionResponse
     */
    'value'?: Array<PbxCrmContact>;
}
/**
 * 
 * @export
 * @interface PbxCrmIntegration
 */
export interface PbxCrmIntegration {
    /**
     * 
     * @type {string}
     * @memberof PbxCrmIntegration
     */
    'Country'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCrmIntegration
     */
    'EnabledForDidCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCrmIntegration
     */
    'EnabledForExternalCalls'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmIntegration
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmIntegration
     */
    'Name'?: string;
    /**
     * 
     * @type {PbxPhonebookPriorityOptions}
     * @memberof PbxCrmIntegration
     */
    'PhonebookPriorityOptions'?: PbxPhonebookPriorityOptions | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxCrmIntegration
     */
    'PhonebookSynchronization'?: boolean | null;
    /**
     * 
     * @type {Array<PbxCrmSelectableValue>}
     * @memberof PbxCrmIntegration
     */
    'PossibleValues'?: Array<PbxCrmSelectableValue>;
    /**
     * 
     * @type {Array<PbxCrmChoice>}
     * @memberof PbxCrmIntegration
     */
    'VariableChoices'?: Array<PbxCrmChoice>;
}


/**
 * 
 * @export
 * @interface PbxCrmParameter
 */
export interface PbxCrmParameter {
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'Default'?: string | null;
    /**
     * 
     * @type {PbxEditorType}
     * @memberof PbxCrmParameter
     */
    'Editor'?: PbxEditorType | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxCrmParameter
     */
    'ListValues'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'ListValuesText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'Parent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'RequestUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'RequestUrlParameters'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'ResponseScenario'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'Title'?: string | null;
    /**
     * 
     * @type {PbxParameterType}
     * @memberof PbxCrmParameter
     */
    'Type'?: PbxParameterType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmParameter
     */
    'Validation'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxCrmParameterCollectionResponse
 */
export interface PbxCrmParameterCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmParameterCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmParameter>}
     * @memberof PbxCrmParameterCollectionResponse
     */
    'value'?: Array<PbxCrmParameter>;
}
/**
 * 
 * @export
 * @interface PbxCrmSelectableValue
 */
export interface PbxCrmSelectableValue {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmSelectableValue
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmSelectableValue
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCrmSelectableValueCollectionResponse
 */
export interface PbxCrmSelectableValueCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmSelectableValueCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmSelectableValue>}
     * @memberof PbxCrmSelectableValueCollectionResponse
     */
    'value'?: Array<PbxCrmSelectableValue>;
}
/**
 * 
 * @export
 * @interface PbxCrmTemplate
 */
export interface PbxCrmTemplate {
    /**
     * 
     * @type {PbxCrmAuthentication}
     * @memberof PbxCrmTemplate
     */
    'Authentication'?: PbxCrmAuthentication | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmTemplate
     */
    'Name'?: string;
    /**
     * 
     * @type {Array<PbxCrmParameter>}
     * @memberof PbxCrmTemplate
     */
    'Parameters'?: Array<PbxCrmParameter>;
}
/**
 * 
 * @export
 * @interface PbxCrmTemplateCollectionResponse
 */
export interface PbxCrmTemplateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCrmTemplateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCrmTemplate>}
     * @memberof PbxCrmTemplateCollectionResponse
     */
    'value'?: Array<PbxCrmTemplate>;
}
/**
 * 
 * @export
 * @interface PbxCrmTemplateSource
 */
export interface PbxCrmTemplateSource {
    /**
     * 
     * @type {string}
     * @memberof PbxCrmTemplateSource
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCrmTestResult
 */
export interface PbxCrmTestResult {
    /**
     * 
     * @type {boolean}
     * @memberof PbxCrmTestResult
     */
    'IsError'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmTestResult
     */
    'Log'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCrmTestResult
     */
    'Message'?: string | null;
    /**
     * 
     * @type {Array<PbxCrmContact>}
     * @memberof PbxCrmTestResult
     */
    'SearchResult'?: Array<PbxCrmContact>;
}
/**
 * 
 * @export
 * @interface PbxCustomPrompt
 */
export interface PbxCustomPrompt {
    /**
     * 
     * @type {boolean}
     * @memberof PbxCustomPrompt
     */
    'CanBeDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxCustomPrompt
     */
    'DisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCustomPrompt
     */
    'FileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCustomPrompt
     */
    'Filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxCustomPrompt
     */
    'Fullpath'?: string | null;
    /**
     * 
     * @type {PbxPromptType}
     * @memberof PbxCustomPrompt
     */
    'PromptType'?: PbxPromptType;
}


/**
 * 
 * @export
 * @interface PbxCustomPromptCollectionResponse
 */
export interface PbxCustomPromptCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCustomPromptCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCustomPrompt>}
     * @memberof PbxCustomPromptCollectionResponse
     */
    'value'?: Array<PbxCustomPrompt>;
}
/**
 * 
 * @export
 * @interface PbxCustomQueueRingtone
 */
export interface PbxCustomQueueRingtone {
    /**
     * 
     * @type {string}
     * @memberof PbxCustomQueueRingtone
     */
    'Queue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxCustomQueueRingtone
     */
    'Ringtone'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxCustomQueueRingtoneCollectionResponse
 */
export interface PbxCustomQueueRingtoneCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxCustomQueueRingtoneCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxCustomQueueRingtone>}
     * @memberof PbxCustomQueueRingtoneCollectionResponse
     */
    'value'?: Array<PbxCustomQueueRingtone>;
}
/**
 * 
 * @export
 * @interface PbxDNProperty
 */
export interface PbxDNProperty {
    /**
     * 
     * @type {string}
     * @memberof PbxDNProperty
     */
    'Description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxDNProperty
     */
    'Id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDNProperty
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxDNProperty
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface PbxDNPropertyCollectionResponse
 */
export interface PbxDNPropertyCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDNPropertyCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDNProperty>}
     * @memberof PbxDNPropertyCollectionResponse
     */
    'value'?: Array<PbxDNProperty>;
}
/**
 * 
 * @export
 * @interface PbxDNRange
 */
export interface PbxDNRange {
    /**
     * 
     * @type {string}
     * @memberof PbxDNRange
     */
    'From'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDNRange
     */
    'To'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxDNRangeCollectionResponse
 */
export interface PbxDNRangeCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDNRangeCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDNRange>}
     * @memberof PbxDNRangeCollectionResponse
     */
    'value'?: Array<PbxDNRange>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxDayOfWeek = {
    Sunday: 'Sunday',
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday'
} as const;

export type PbxDayOfWeek = typeof PbxDayOfWeek[keyof typeof PbxDayOfWeek];


/**
 * 
 * @export
 * @interface PbxDefs
 */
export interface PbxDefs {
    /**
     * 
     * @type {Array<PbxCodec>}
     * @memberof PbxDefs
     */
    'Codecs'?: Array<PbxCodec>;
    /**
     * 
     * @type {Array<PbxGatewayParameter>}
     * @memberof PbxDefs
     */
    'GatewayParameters'?: Array<PbxGatewayParameter>;
    /**
     * 
     * @type {Array<PbxGatewayParameterValue>}
     * @memberof PbxDefs
     */
    'GatewayParameterValues'?: Array<PbxGatewayParameterValue>;
    /**
     * 
     * @type {number}
     * @memberof PbxDefs
     */
    'Id'?: number;
    /**
     * 
     * @type {Array<PbxTimeZone>}
     * @memberof PbxDefs
     */
    'TimeZones'?: Array<PbxTimeZone>;
}
/**
 * 
 * @export
 * @interface PbxDestination
 */
export interface PbxDestination {
    /**
     * 
     * @type {string}
     * @memberof PbxDestination
     */
    'External'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDestination
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDestination
     */
    'Number'?: string | null;
    /**
     * 
     * @type {Array<PbxUserTag>}
     * @memberof PbxDestination
     */
    'Tags'?: Array<PbxUserTag>;
    /**
     * 
     * @type {PbxDestinationType}
     * @memberof PbxDestination
     */
    'To'?: PbxDestinationType;
    /**
     * 
     * @type {PbxPeerType}
     * @memberof PbxDestination
     */
    'Type'?: PbxPeerType | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxDestinationType = {
    None: 'None',
    VoiceMail: 'VoiceMail',
    Extension: 'Extension',
    Queue: 'Queue',
    RingGroup: 'RingGroup',
    Ivr: 'IVR',
    External: 'External',
    Fax: 'Fax',
    Boomerang: 'Boomerang',
    Deflect: 'Deflect',
    VoiceMailOfDestination: 'VoiceMailOfDestination',
    Callback: 'Callback',
    RoutePoint: 'RoutePoint',
    ProceedWithNoExceptions: 'ProceedWithNoExceptions'
} as const;

export type PbxDestinationType = typeof PbxDestinationType[keyof typeof PbxDestinationType];


/**
 * 
 * @export
 * @interface PbxDetailedQueueStatistics
 */
export interface PbxDetailedQueueStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxDetailedQueueStatistics
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'AvgRingTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'AvgTalkTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxDetailedQueueStatistics
     */
    'CallbacksCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxDetailedQueueStatistics
     */
    'CallsCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'QueueDn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'QueueDnNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'RingTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDetailedQueueStatistics
     */
    'TalkTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxDetailedQueueStatisticsCollectionResponse
 */
export interface PbxDetailedQueueStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDetailedQueueStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDetailedQueueStatistics>}
     * @memberof PbxDetailedQueueStatisticsCollectionResponse
     */
    'value'?: Array<PbxDetailedQueueStatistics>;
}
/**
 * 
 * @export
 * @interface PbxDeviceInfo
 */
export interface PbxDeviceInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PbxDeviceInfo
     */
    'Assigned'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'AssignedUser'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'DetectedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'FirmwareVersion'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxDeviceInfo
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'InterfaceLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'MAC'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'Model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'NetworkAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'NetworkPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'Parameters'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'SbcName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'TemplateName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'UserAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceInfo
     */
    'Vendor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxDeviceInfo
     */
    'ViaSBC'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxDeviceInfoCollectionResponse
 */
export interface PbxDeviceInfoCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDeviceInfoCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDeviceInfo>}
     * @memberof PbxDeviceInfoCollectionResponse
     */
    'value'?: Array<PbxDeviceInfo>;
}
/**
 * 
 * @export
 * @interface PbxDeviceLine
 */
export interface PbxDeviceLine {
    /**
     * 
     * @type {number}
     * @memberof PbxDeviceLine
     */
    'Key'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceLine
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDeviceLine
     */
    'Number'?: string;
}
/**
 * 
 * @export
 * @interface PbxDeviceLineCollectionResponse
 */
export interface PbxDeviceLineCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDeviceLineCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDeviceLine>}
     * @memberof PbxDeviceLineCollectionResponse
     */
    'value'?: Array<PbxDeviceLine>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxDeviceType = {
    Fxs: 'Fxs',
    Dect: 'Dect'
} as const;

export type PbxDeviceType = typeof PbxDeviceType[keyof typeof PbxDeviceType];


/**
 * 
 * @export
 * @interface PbxDialCodeSettings
 */
export interface PbxDialCodeSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeBillingCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeHideCallerID'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeHotdesking'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeHotelAccess'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeIntercom'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeLoggedInQueue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeLoggedOutQueue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeOutOffice'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodePark'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodePickup'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeProfileStatus'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeUnpark'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDialCodeSettings
     */
    'DialCodeVMail'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxDidNumber
 */
export interface PbxDidNumber {
    /**
     * 
     * @type {string}
     * @memberof PbxDidNumber
     */
    'Number'?: string;
    /**
     * 
     * @type {PbxInboundRule}
     * @memberof PbxDidNumber
     */
    'RoutingRule'?: PbxInboundRule | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDidNumber
     */
    'TemplateFileName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxDidNumber
     */
    'TrunkId'?: number;
}
/**
 * 
 * @export
 * @interface PbxDidNumberCollectionResponse
 */
export interface PbxDidNumberCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxDidNumberCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxDidNumber>}
     * @memberof PbxDidNumberCollectionResponse
     */
    'value'?: Array<PbxDidNumber>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxDirectionType = {
    None: 'None',
    Inbound: 'Inbound',
    Outbound: 'Outbound',
    Both: 'Both'
} as const;

export type PbxDirectionType = typeof PbxDirectionType[keyof typeof PbxDirectionType];


/**
 * 
 * @export
 * @interface PbxDirectoryParameters
 */
export interface PbxDirectoryParameters {
    /**
     * 
     * @type {PbxFileSystemType}
     * @memberof PbxDirectoryParameters
     */
    'Filesystem'?: PbxFileSystemType;
    /**
     * 
     * @type {string}
     * @memberof PbxDirectoryParameters
     */
    'Json'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxDirectoryParameters
     */
    'Path'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxE164Settings
 */
export interface PbxE164Settings {
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'AreaCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'CountryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'CountryName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxE164Settings
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'InternationalCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'NationalCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxE164Settings
     */
    'Prefix'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxE164Settings
     */
    'RemoveAreaCode'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxE164Settings
     */
    'RemoveCountryCode'?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxEditorType = {
    String: 'String',
    Sql: 'Sql'
} as const;

export type PbxEditorType = typeof PbxEditorType[keyof typeof PbxEditorType];


/**
 * 
 * @export
 * @interface PbxEmailTemplate
 */
export interface PbxEmailTemplate {
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'Body'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'From'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxEmailTemplate
     */
    'IsConference'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxEmailTemplate
     */
    'IsDefault'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'Lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'Subject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmailTemplate
     */
    'TemplatePath'?: string;
}
/**
 * 
 * @export
 * @interface PbxEmailTemplateCollectionResponse
 */
export interface PbxEmailTemplateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxEmailTemplateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxEmailTemplate>}
     * @memberof PbxEmailTemplateCollectionResponse
     */
    'value'?: Array<PbxEmailTemplate>;
}
/**
 * 
 * @export
 * @interface PbxEmergencyGeoLocation
 */
export interface PbxEmergencyGeoLocation {
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyGeoLocation
     */
    'FriendlyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyGeoLocation
     */
    'Id'?: string;
}
/**
 * 
 * @export
 * @interface PbxEmergencyGeoLocationCollectionResponse
 */
export interface PbxEmergencyGeoLocationCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxEmergencyGeoLocationCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxEmergencyGeoLocation>}
     * @memberof PbxEmergencyGeoLocationCollectionResponse
     */
    'value'?: Array<PbxEmergencyGeoLocation>;
}
/**
 * 
 * @export
 * @interface PbxEmergencyGeoTrunkLocation
 */
export interface PbxEmergencyGeoTrunkLocation {
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyGeoTrunkLocation
     */
    'Id'?: string;
    /**
     * 
     * @type {PbxEmergencyGeoLocation}
     * @memberof PbxEmergencyGeoTrunkLocation
     */
    'Location'?: PbxEmergencyGeoLocation;
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyGeoTrunkLocation
     */
    'ProviderUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyGeoTrunkLocation
     */
    'TrunkDn'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxEmergencyGeoTrunkLocationCollectionResponse
 */
export interface PbxEmergencyGeoTrunkLocationCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxEmergencyGeoTrunkLocationCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxEmergencyGeoTrunkLocation>}
     * @memberof PbxEmergencyGeoTrunkLocationCollectionResponse
     */
    'value'?: Array<PbxEmergencyGeoTrunkLocation>;
}
/**
 * 
 * @export
 * @interface PbxEmergencyNotificationsSettings
 */
export interface PbxEmergencyNotificationsSettings {
    /**
     * 
     * @type {PbxChatRecipientsType}
     * @memberof PbxEmergencyNotificationsSettings
     */
    'ChatRecipients'?: PbxChatRecipientsType | null;
    /**
     * 
     * @type {PbxPeer}
     * @memberof PbxEmergencyNotificationsSettings
     */
    'EmergencyDNPrompt'?: PbxPeer | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyNotificationsSettings
     */
    'EmergencyPlayPrompt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEmergencyNotificationsSettings
     */
    'SpecifiedList'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxEntityRestrictions
 */
export interface PbxEntityRestrictions {
    /**
     * 
     * @type {number}
     * @memberof PbxEntityRestrictions
     */
    'Allowed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxEntityRestrictions
     */
    'Unlimited'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxEntityRestrictions
     */
    'Used'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxEventLog
 */
export interface PbxEventLog {
    /**
     * 
     * @type {number}
     * @memberof PbxEventLog
     */
    'EventId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEventLog
     */
    'Group'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEventLog
     */
    'GroupName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxEventLog
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxEventLog
     */
    'Message'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxEventLog
     */
    'Params'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxEventLog
     */
    'Source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxEventLog
     */
    'TimeGenerated'?: string | null;
    /**
     * 
     * @type {PbxEventLogType}
     * @memberof PbxEventLog
     */
    'Type'?: PbxEventLogType | null;
}


/**
 * 
 * @export
 * @interface PbxEventLogCollectionResponse
 */
export interface PbxEventLogCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxEventLogCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxEventLog>}
     * @memberof PbxEventLogCollectionResponse
     */
    'value'?: Array<PbxEventLog>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxEventLogType = {
    Error: 'Error',
    Warning: 'Warning',
    Info: 'Info'
} as const;

export type PbxEventLogType = typeof PbxEventLogType[keyof typeof PbxEventLogType];


/**
 * 
 * @export
 * @interface PbxExtensionFilter
 */
export interface PbxExtensionFilter {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxExtensionFilter
     */
    'CallIds'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionFilter
     */
    'Number'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxExtensionFilterCollectionResponse
 */
export interface PbxExtensionFilterCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionFilterCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionFilter>}
     * @memberof PbxExtensionFilterCollectionResponse
     */
    'value'?: Array<PbxExtensionFilter>;
}
/**
 * 
 * @export
 * @interface PbxExtensionRule
 */
export interface PbxExtensionRule {
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionRule
     */
    'CallerId'?: string | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxExtensionRule
     */
    'Destination'?: PbxDestination | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxExtensionRule
     */
    'Hours'?: PbxSchedule | null;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionRule
     */
    'Id'?: number;
}
/**
 * 
 * @export
 * @interface PbxExtensionRuleCollectionResponse
 */
export interface PbxExtensionRuleCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionRuleCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionRule>}
     * @memberof PbxExtensionRuleCollectionResponse
     */
    'value'?: Array<PbxExtensionRule>;
}
/**
 * 
 * @export
 * @interface PbxExtensionStatistics
 */
export interface PbxExtensionStatistics {
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionStatistics
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionStatistics
     */
    'Dn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionStatistics
     */
    'InboundAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionStatistics
     */
    'InboundAnsweredTalkingDur'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionStatistics
     */
    'InboundUnansweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionStatistics
     */
    'OutboundAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionStatistics
     */
    'OutboundAnsweredTalkingDur'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionStatistics
     */
    'OutboundUnansweredCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxExtensionStatisticsCollectionResponse
 */
export interface PbxExtensionStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionStatistics>}
     * @memberof PbxExtensionStatisticsCollectionResponse
     */
    'value'?: Array<PbxExtensionStatistics>;
}
/**
 * 
 * @export
 * @interface PbxExtensionsStatisticsByRingGroups
 */
export interface PbxExtensionsStatisticsByRingGroups {
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'ExtensionAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'ExtensionDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'ExtensionDn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'RingGroupDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'RingGroupDn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionsStatisticsByRingGroups
     */
    'SentimentScore'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxExtensionsStatisticsByRingGroupsCollectionResponse
 */
export interface PbxExtensionsStatisticsByRingGroupsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxExtensionsStatisticsByRingGroupsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxExtensionsStatisticsByRingGroups>}
     * @memberof PbxExtensionsStatisticsByRingGroupsCollectionResponse
     */
    'value'?: Array<PbxExtensionsStatisticsByRingGroups>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxFailoverCondition = {
    AllService: 'AllService',
    AnyService: 'AnyService'
} as const;

export type PbxFailoverCondition = typeof PbxFailoverCondition[keyof typeof PbxFailoverCondition];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxFailoverMode = {
    Active: 'Active',
    Passive: 'Passive'
} as const;

export type PbxFailoverMode = typeof PbxFailoverMode[keyof typeof PbxFailoverMode];


/**
 * 
 * @export
 * @interface PbxFailoverScriptFile
 */
export interface PbxFailoverScriptFile {
    /**
     * 
     * @type {string}
     * @memberof PbxFailoverScriptFile
     */
    'Filename'?: string;
}
/**
 * 
 * @export
 * @interface PbxFax
 */
export interface PbxFax {
    /**
     * 
     * @type {string}
     * @memberof PbxFax
     */
    'AuthID'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFax
     */
    'AuthPassword'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFax
     */
    'FaxServer'?: boolean | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxFax
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {number}
     * @memberof PbxFax
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxFax
     */
    'Number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFax
     */
    'OutboundCallerId'?: string | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxFax
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
}


/**
 * 
 * @export
 * @interface PbxFaxCollectionResponse
 */
export interface PbxFaxCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFaxCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFax>}
     * @memberof PbxFaxCollectionResponse
     */
    'value'?: Array<PbxFax>;
}
/**
 * 
 * @export
 * @interface PbxFaxServerSettings
 */
export interface PbxFaxServerSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxFaxServerSettings
     */
    'AuthId'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxFaxServerSettings
     */
    'AuthPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFaxServerSettings
     */
    'AutoCleanup'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFaxServerSettings
     */
    'Email'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFaxServerSettings
     */
    'FaxServerId'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFaxServerSettings
     */
    'G711ToT38Fallback'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFaxServerSettings
     */
    'MaxAge'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFaxServerSettings
     */
    'Number'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFaxServerSettings
     */
    'RemoteStorageEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxFileSystemType = {
    Local: 'Local',
    Ftp: 'Ftp',
    GoogleDrive: 'GoogleDrive',
    NetworkShare: 'NetworkShare',
    Logs: 'Logs',
    Sftp: 'Sftp',
    GoogleBucket: 'GoogleBucket',
    SharePoint: 'SharePoint'
} as const;

export type PbxFileSystemType = typeof PbxFileSystemType[keyof typeof PbxFileSystemType];


/**
 * 
 * @export
 * @interface PbxFirewallState
 */
export interface PbxFirewallState {
    /**
     * 
     * @type {string}
     * @memberof PbxFirewallState
     */
    'Html'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFirewallState
     */
    'Id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFirewallState
     */
    'Running'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFirewallState
     */
    'Stopping'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxFirmware
 */
export interface PbxFirmware {
    /**
     * 
     * @type {string}
     * @memberof PbxFirmware
     */
    'Filename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFirmware
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFirmware
     */
    'Model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFirmware
     */
    'Vendor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFirmware
     */
    'Version'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxFirmwareCollectionResponse
 */
export interface PbxFirmwareCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFirmwareCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFirmware>}
     * @memberof PbxFirmwareCollectionResponse
     */
    'value'?: Array<PbxFirmware>;
}
/**
 * 
 * @export
 * @interface PbxFirmwareState
 */
export interface PbxFirmwareState {
    /**
     * 
     * @type {number}
     * @memberof PbxFirmwareState
     */
    'Count'?: number | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxFirmwareState
     */
    'FileNames'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxFirmwareState
     */
    'Id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFirmwareState
     */
    'TotalSize'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxFirstAvailableNumber
 */
export interface PbxFirstAvailableNumber {
    /**
     * 
     * @type {string}
     * @memberof PbxFirstAvailableNumber
     */
    'Number'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxForwardingProfile
 */
export interface PbxForwardingProfile {
    /**
     * 
     * @type {boolean}
     * @memberof PbxForwardingProfile
     */
    'AcceptMultipleCalls'?: boolean | null;
    /**
     * 
     * @type {PbxAvailableRouting}
     * @memberof PbxForwardingProfile
     */
    'AvailableRoute'?: PbxAvailableRouting | null;
    /**
     * 
     * @type {PbxAwayRouting}
     * @memberof PbxForwardingProfile
     */
    'AwayRoute'?: PbxAwayRouting | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxForwardingProfile
     */
    'BlockPushCalls'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxForwardingProfile
     */
    'CustomMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxForwardingProfile
     */
    'CustomName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxForwardingProfile
     */
    'DisableRingGroupCalls'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxForwardingProfile
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxForwardingProfile
     */
    'Name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxForwardingProfile
     */
    'NoAnswerTimeout'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxForwardingProfile
     */
    'OfficeHoursAutoQueueLogOut'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxForwardingProfile
     */
    'RingMyMobile'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxForwardingProfileCollectionResponse
 */
export interface PbxForwardingProfileCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxForwardingProfileCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxForwardingProfile>}
     * @memberof PbxForwardingProfileCollectionResponse
     */
    'value'?: Array<PbxForwardingProfile>;
}
/**
 * 
 * @export
 * @interface PbxFxs
 */
export interface PbxFxs {
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Brand'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxFxs
     */
    'Codecs'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof PbxFxs
     */
    'FxsLineCount'?: number | null;
    /**
     * 
     * @type {Array<PbxDeviceLine>}
     * @memberof PbxFxs
     */
    'FxsLines'?: Array<PbxDeviceLine>;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Group'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'MacAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'ModelName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Password'?: string | null;
    /**
     * 
     * @type {PbxFxsProvisioning}
     * @memberof PbxFxs
     */
    'Provisioning'?: PbxFxsProvisioning | null;
    /**
     * 
     * @type {PbxRegistrarFxs}
     * @memberof PbxFxs
     */
    'Registered'?: PbxRegistrarFxs | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'Secret'?: string | null;
    /**
     * 
     * @type {PbxFxsTemplate}
     * @memberof PbxFxs
     */
    'Template'?: PbxFxsTemplate | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxs
     */
    'TimeZone'?: string | null;
    /**
     * 
     * @type {Array<PbxVariable>}
     * @memberof PbxFxs
     */
    'Variables'?: Array<PbxVariable>;
}
/**
 * 
 * @export
 * @interface PbxFxsCollectionResponse
 */
export interface PbxFxsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFxs>}
     * @memberof PbxFxsCollectionResponse
     */
    'value'?: Array<PbxFxs>;
}
/**
 * 
 * @export
 * @interface PbxFxsModel
 */
export interface PbxFxsModel {
    /**
     * 
     * @type {string}
     * @memberof PbxFxsModel
     */
    'DisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsModel
     */
    'UserAgent'?: string;
}
/**
 * 
 * @export
 * @interface PbxFxsModelCollectionResponse
 */
export interface PbxFxsModelCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsModelCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFxsModel>}
     * @memberof PbxFxsModelCollectionResponse
     */
    'value'?: Array<PbxFxsModel>;
}
/**
 * 
 * @export
 * @interface PbxFxsProvisioning
 */
export interface PbxFxsProvisioning {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsProvisioning
     */
    'LocalAudioPortEnd'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFxsProvisioning
     */
    'LocalAudioPortStart'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsProvisioning
     */
    'LocalInterface'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFxsProvisioning
     */
    'LocalSipPort'?: number | null;
    /**
     * 
     * @type {PbxProvType}
     * @memberof PbxFxsProvisioning
     */
    'Method'?: PbxProvType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsProvisioning
     */
    'ProvLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsProvisioning
     */
    'RemoteFQDN'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxFxsProvisioning
     */
    'RemotePort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsProvisioning
     */
    'SbcName'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxFxsTemplate
 */
export interface PbxFxsTemplate {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxFxsTemplate
     */
    'AllowedNetConfigs'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFxsTemplate
     */
    'AllowSSLProvisioning'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsTemplate
     */
    'Brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsTemplate
     */
    'Content'?: string | null;
    /**
     * 
     * @type {PbxDeviceType}
     * @memberof PbxFxsTemplate
     */
    'DeviceType'?: PbxDeviceType;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsTemplate
     */
    'Id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxFxsTemplate
     */
    'IsCustom'?: boolean;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxFxsTemplate
     */
    'Languages'?: Array<string | null>;
    /**
     * 
     * @type {Array<PbxFxsModel>}
     * @memberof PbxFxsTemplate
     */
    'Models'?: Array<PbxFxsModel>;
    /**
     * 
     * @type {number}
     * @memberof PbxFxsTemplate
     */
    'NumberOfExtensions'?: number;
    /**
     * 
     * @type {PbxTemplateType}
     * @memberof PbxFxsTemplate
     */
    'TemplateType'?: PbxTemplateType;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxFxsTemplate
     */
    'TimeZones'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsTemplate
     */
    'URL'?: string;
    /**
     * 
     * @type {Array<PbxFxsVariable>}
     * @memberof PbxFxsTemplate
     */
    'Variables'?: Array<PbxFxsVariable>;
}


/**
 * 
 * @export
 * @interface PbxFxsTemplateCollectionResponse
 */
export interface PbxFxsTemplateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsTemplateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFxsTemplate>}
     * @memberof PbxFxsTemplateCollectionResponse
     */
    'value'?: Array<PbxFxsTemplate>;
}
/**
 * 
 * @export
 * @interface PbxFxsVariable
 */
export interface PbxFxsVariable {
    /**
     * 
     * @type {Array<PbxFxsVariableChoice>}
     * @memberof PbxFxsVariable
     */
    'Choices'?: Array<PbxFxsVariableChoice>;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsVariable
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsVariable
     */
    'Title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsVariable
     */
    'ValidationType'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxFxsVariableChoice
 */
export interface PbxFxsVariableChoice {
    /**
     * 
     * @type {string}
     * @memberof PbxFxsVariableChoice
     */
    'DisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxFxsVariableChoice
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface PbxFxsVariableChoiceCollectionResponse
 */
export interface PbxFxsVariableChoiceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsVariableChoiceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFxsVariableChoice>}
     * @memberof PbxFxsVariableChoiceCollectionResponse
     */
    'value'?: Array<PbxFxsVariableChoice>;
}
/**
 * 
 * @export
 * @interface PbxFxsVariableCollectionResponse
 */
export interface PbxFxsVariableCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxFxsVariableCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxFxsVariable>}
     * @memberof PbxFxsVariableCollectionResponse
     */
    'value'?: Array<PbxFxsVariable>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxGCCollectionMode = {
    Default: 'Default',
    Forced: 'Forced',
    Optimized: 'Optimized',
    Aggressive: 'Aggressive'
} as const;

export type PbxGCCollectionMode = typeof PbxGCCollectionMode[keyof typeof PbxGCCollectionMode];


/**
 * 
 * @export
 * @interface PbxGarbageCollect
 */
export interface PbxGarbageCollect {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGarbageCollect
     */
    'Blocking'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGarbageCollect
     */
    'Compacting'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGarbageCollect
     */
    'Generation'?: number | null;
    /**
     * 
     * @type {PbxGCCollectionMode}
     * @memberof PbxGarbageCollect
     */
    'Mode'?: PbxGCCollectionMode | null;
}


/**
 * 
 * @export
 * @interface PbxGateway
 */
export interface PbxGateway {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxGateway
     */
    'Codecs'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'DeliverAudio'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'DestNumberInRemotePartyIDCalled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'DestNumberInRequestLineURI'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'DestNumberInTo'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'Host'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGateway
     */
    'Id'?: number | null;
    /**
     * 
     * @type {Array<PbxGatewayParameterBinding>}
     * @memberof PbxGateway
     */
    'InboundParams'?: Array<PbxGatewayParameterBinding>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'Internal'?: boolean | null;
    /**
     * 
     * @type {PbxIPInRegistrationContactType}
     * @memberof PbxGateway
     */
    'IPInRegistrationContact'?: PbxIPInRegistrationContactType | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGateway
     */
    'Lines'?: number | null;
    /**
     * 
     * @type {PbxMatchingStrategyType}
     * @memberof PbxGateway
     */
    'MatchingStrategy'?: PbxMatchingStrategyType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'OutboundCallerID'?: string | null;
    /**
     * 
     * @type {Array<PbxGatewayParameterBinding>}
     * @memberof PbxGateway
     */
    'OutboundParams'?: Array<PbxGatewayParameterBinding>;
    /**
     * 
     * @type {number}
     * @memberof PbxGateway
     */
    'Port'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'ProxyHost'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGateway
     */
    'ProxyPort'?: number | null;
    /**
     * 
     * @type {PbxRequireRegistrationForType}
     * @memberof PbxGateway
     */
    'RequireRegistrationFor'?: PbxRequireRegistrationForType | null;
    /**
     * 
     * @type {Array<PbxGatewayParameterBinding>}
     * @memberof PbxGateway
     */
    'SourceIdentification'?: Array<PbxGatewayParameterBinding>;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'SpecifiedIPForRegistrationContact'?: string | null;
    /**
     * 
     * @type {PbxSRTPModeType}
     * @memberof PbxGateway
     */
    'SRTPMode'?: PbxSRTPModeType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'SupportReinvite'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'SupportReplaces'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGateway
     */
    'TemplateFilename'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGateway
     */
    'TimeBetweenReg'?: number | null;
    /**
     * 
     * @type {PbxGatewayType}
     * @memberof PbxGateway
     */
    'Type'?: PbxGatewayType;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGateway
     */
    'UseIPInContact'?: boolean | null;
    /**
     * 
     * @type {Array<PbxChoice>}
     * @memberof PbxGateway
     */
    'VariableChoices'?: Array<PbxChoice>;
}


/**
 * 
 * @export
 * @interface PbxGatewayParameter
 */
export interface PbxGatewayParameter {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGatewayParameter
     */
    'CanHaveDID'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGatewayParameter
     */
    'Description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameter
     */
    'Id'?: number;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxGatewayParameter
     */
    'InboundPossibleValues'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxGatewayParameter
     */
    'Name'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxGatewayParameter
     */
    'OutboundPossibleValues'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxGatewayParameter
     */
    'SourceIDPossibleValues'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface PbxGatewayParameterBinding
 */
export interface PbxGatewayParameterBinding {
    /**
     * 
     * @type {string}
     * @memberof PbxGatewayParameterBinding
     */
    'Custom'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterBinding
     */
    'ParamId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterBinding
     */
    'ValueId'?: number;
}
/**
 * 
 * @export
 * @interface PbxGatewayParameterBindingCollectionResponse
 */
export interface PbxGatewayParameterBindingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterBindingCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGatewayParameterBinding>}
     * @memberof PbxGatewayParameterBindingCollectionResponse
     */
    'value'?: Array<PbxGatewayParameterBinding>;
}
/**
 * 
 * @export
 * @interface PbxGatewayParameterCollectionResponse
 */
export interface PbxGatewayParameterCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGatewayParameter>}
     * @memberof PbxGatewayParameterCollectionResponse
     */
    'value'?: Array<PbxGatewayParameter>;
}
/**
 * 
 * @export
 * @interface PbxGatewayParameterValue
 */
export interface PbxGatewayParameterValue {
    /**
     * 
     * @type {string}
     * @memberof PbxGatewayParameterValue
     */
    'Description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterValue
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxGatewayParameterValue
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxGatewayParameterValueCollectionResponse
 */
export interface PbxGatewayParameterValueCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxGatewayParameterValueCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGatewayParameterValue>}
     * @memberof PbxGatewayParameterValueCollectionResponse
     */
    'value'?: Array<PbxGatewayParameterValue>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxGatewayType = {
    Unknown: 'Unknown',
    Analog: 'Analog',
    Provider: 'Provider',
    BridgeMaster: 'BridgeMaster',
    BridgeSlave: 'BridgeSlave',
    BridgeSlaveOverTunnel: 'BridgeSlaveOverTunnel',
    Bri: 'BRI',
    T1: 'T1',
    E1: 'E1'
} as const;

export type PbxGatewayType = typeof PbxGatewayType[keyof typeof PbxGatewayType];


/**
 * 
 * @export
 * @interface PbxGeneralLiveChatSettings
 */
export interface PbxGeneralLiveChatSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralLiveChatSettings
     */
    'AllowSoundNotifications'?: boolean | null;
    /**
     * 
     * @type {PbxAuthentication}
     * @memberof PbxGeneralLiveChatSettings
     */
    'Authentication'?: PbxAuthentication | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralLiveChatSettings
     */
    'DisableOfflineMessages'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralLiveChatSettings
     */
    'EnableGA'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralLiveChatSettings
     */
    'EnableOnMobile'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralLiveChatSettings
     */
    'GdprEnabled'?: boolean | null;
    /**
     * 
     * @type {PbxLiveChatGreeting}
     * @memberof PbxGeneralLiveChatSettings
     */
    'Greeting'?: PbxLiveChatGreeting | null;
}


/**
 * 
 * @export
 * @interface PbxGeneralSettingsForApps
 */
export interface PbxGeneralSettingsForApps {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'AllowChangePassword'?: boolean | null;
    /**
     * 
     * @type {PbxAutoSchedulerSettings}
     * @memberof PbxGeneralSettingsForApps
     */
    'AutoSchedulerSettings'?: PbxAutoSchedulerSettings | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'EnableChat'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'HideAbandonedQueueCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'HideCRMContacts'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'HideInteractionHistory'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForApps
     */
    'HideSystemExtensions'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGeneralSettingsForApps
     */
    'NameOfCustomAvailableStatus'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGeneralSettingsForApps
     */
    'NameOfCustomOutOfOfficeStatus'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxGeneralSettingsForPbx
 */
export interface PbxGeneralSettingsForPbx {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'AllowFwdToExternal'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'BusyMonitor'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGeneralSettingsForPbx
     */
    'BusyMonitorTimeout'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'DisableOutboundCallsOutOfficeHours'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'EnableVMenuOutboundCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'HDAutoLogoutEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGeneralSettingsForPbx
     */
    'HDAutoLogoutTime'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'LimitCallPickup'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGeneralSettingsForPbx
     */
    'OperatorExtension'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGeneralSettingsForPbx
     */
    'PlayBusy'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGeneralSettingsForPbx
     */
    'ScheduledReportGenerationTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxGoogleSettings
 */
export interface PbxGoogleSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxGoogleSettings
     */
    'ClientId'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxGoogleSettings
     */
    'ClientSecret'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGoogleSettings
     */
    'Id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGoogleSettings
     */
    'IsExtensionSignInEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGoogleSettings
     */
    'ProvisionUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxGreeting
 */
export interface PbxGreeting {
    /**
     * 
     * @type {string}
     * @memberof PbxGreeting
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGreeting
     */
    'Filename'?: string | null;
    /**
     * 
     * @type {PbxProfileType}
     * @memberof PbxGreeting
     */
    'Type'?: PbxProfileType;
}


/**
 * 
 * @export
 * @interface PbxGreetingCollectionResponse
 */
export interface PbxGreetingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxGreetingCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGreeting>}
     * @memberof PbxGreetingCollectionResponse
     */
    'value'?: Array<PbxGreeting>;
}
/**
 * 
 * @export
 * @interface PbxGreetingFile
 */
export interface PbxGreetingFile {
    /**
     * 
     * @type {string}
     * @memberof PbxGreetingFile
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGreetingFile
     */
    'Filename'?: string;
}
/**
 * 
 * @export
 * @interface PbxGroup
 */
export interface PbxGroup {
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'AllowCallService'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroup
     */
    'AnswerAfter'?: number | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxGroup
     */
    'BreakRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxGroup
     */
    'BreakTime'?: PbxSchedule | null;
    /**
     * 
     * @type {Array<PbxCallHandlingFlags>}
     * @memberof PbxGroup
     */
    'CallHandlingMode'?: Array<PbxCallHandlingFlags>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'CallUsEnableChat'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'CallUsEnablePhone'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'CallUsEnableVideo'?: boolean | null;
    /**
     * 
     * @type {PbxAuthentication}
     * @memberof PbxGroup
     */
    'CallUsRequirement'?: PbxAuthentication | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'ClickToCallId'?: string | null;
    /**
     * 
     * @type {PbxGroupHoursMode}
     * @memberof PbxGroup
     */
    'CurrentGroupHours'?: PbxGroupHoursMode | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxGroup
     */
    'CustomOperator'?: PbxDestination | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'CustomPrompt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'DisableCustomPrompt'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'GloballyVisible'?: boolean | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxGroup
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'HasMembers'?: boolean | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxGroup
     */
    'HolidaysRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxGroup
     */
    'Hours'?: PbxSchedule | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroup
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'IsDefault'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'Language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'LastLoginTime'?: string | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxGroup
     */
    'Members'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'Number'?: string | null;
    /**
     * 
     * @type {Array<PbxHoliday>}
     * @memberof PbxGroup
     */
    'OfficeHolidays'?: Array<PbxHoliday>;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxGroup
     */
    'OfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxGroup
     */
    'OutOfOfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'OverrideExpiresAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxGroup
     */
    'OverrideHolidays'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'PromptSet'?: string | null;
    /**
     * 
     * @type {PbxGroupProps}
     * @memberof PbxGroup
     */
    'Props'?: PbxGroupProps | null;
    /**
     * 
     * @type {Array<PbxRights>}
     * @memberof PbxGroup
     */
    'Rights'?: Array<PbxRights>;
    /**
     * 
     * @type {string}
     * @memberof PbxGroup
     */
    'TimeZoneId'?: string | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxGroup
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
}


/**
 * 
 * @export
 * @interface PbxGroupCollectionResponse
 */
export interface PbxGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxGroup>}
     * @memberof PbxGroupCollectionResponse
     */
    'value'?: Array<PbxGroup>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxGroupHoursMode = {
    Default: 'Default',
    ForceOpened: 'ForceOpened',
    ForceClosed: 'ForceClosed',
    ForceBreak: 'ForceBreak',
    ForceCustomOperator: 'ForceCustomOperator',
    ForceHoliday: 'ForceHoliday',
    HasForcedMask: 'HasForcedMask'
} as const;

export type PbxGroupHoursMode = typeof PbxGroupHoursMode[keyof typeof PbxGroupHoursMode];


/**
 * 
 * @export
 * @interface PbxGroupProps
 */
export interface PbxGroupProps {
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'DectMaxCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'Fqdn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'LiveChatMaxCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'OutboundRulesMaxCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'PersonalContactsMaxCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'PromptsMaxCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'ResellerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'ResellerName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxGroupProps
     */
    'SbcMaxCount'?: number | null;
    /**
     * 
     * @type {PbxStartupLicense}
     * @memberof PbxGroupProps
     */
    'StartupLicense'?: PbxStartupLicense | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'StartupOwnerEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'SubcriptionExpireDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'Subscription'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'SubscriptionType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'SystemNumberFrom'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'SystemNumberTo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'TrunkNumberFrom'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'TrunkNumberTo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'UserNumberFrom'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxGroupProps
     */
    'UserNumberTo'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxHoliday
 */
export interface PbxHoliday {
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'Day'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'DayEnd'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxHoliday
     */
    'HolidayPrompt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxHoliday
     */
    'IsRecurrent'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'Month'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'MonthEnd'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxHoliday
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxHoliday
     */
    'TimeOfEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxHoliday
     */
    'TimeOfStartDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'Year'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxHoliday
     */
    'YearEnd'?: number;
}
/**
 * 
 * @export
 * @interface PbxHolidayCollectionResponse
 */
export interface PbxHolidayCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxHolidayCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxHoliday>}
     * @memberof PbxHolidayCollectionResponse
     */
    'value'?: Array<PbxHoliday>;
}
/**
 * 
 * @export
 * @interface PbxHotelServices
 */
export interface PbxHotelServices {
    /**
     * 
     * @type {boolean}
     * @memberof PbxHotelServices
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxHotelServices
     */
    'HotelGroups'?: Array<string | null>;
    /**
     * 
     * @type {PbxPmsIntegrationType}
     * @memberof PbxHotelServices
     */
    'IntegrationType'?: PbxPmsIntegrationType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxHotelServices
     */
    'IpAddress'?: string | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxHotelServices
     */
    'NoAnswerDestination'?: PbxDestination | null;
    /**
     * 
     * @type {number}
     * @memberof PbxHotelServices
     */
    'NoAnswerTimeout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxHotelServices
     */
    'Port'?: number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxIPInRegistrationContactType = {
    External: 'External',
    Internal: 'Internal',
    Both: 'Both',
    Specified: 'Specified'
} as const;

export type PbxIPInRegistrationContactType = typeof PbxIPInRegistrationContactType[keyof typeof PbxIPInRegistrationContactType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxIVRForwardType = {
    EndCall: 'EndCall',
    Extension: 'Extension',
    RingGroup: 'RingGroup',
    Queue: 'Queue',
    Ivr: 'IVR',
    VoiceMail: 'VoiceMail',
    CallByName: 'CallByName',
    RepeatPrompt: 'RepeatPrompt',
    CustomInput: 'CustomInput'
} as const;

export type PbxIVRForwardType = typeof PbxIVRForwardType[keyof typeof PbxIVRForwardType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxIVRType = {
    Default: 'Default',
    CodeBased: 'CodeBased',
    ScriptBased: 'ScriptBased',
    Wakeup: 'Wakeup'
} as const;

export type PbxIVRType = typeof PbxIVRType[keyof typeof PbxIVRType];


/**
 * 
 * @export
 * @interface PbxInboundRule
 */
export interface PbxInboundRule {
    /**
     * 
     * @type {boolean}
     * @memberof PbxInboundRule
     */
    'AlterDestinationDuringHolidays'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxInboundRule
     */
    'AlterDestinationDuringOutOfOfficeHours'?: boolean | null;
    /**
     * 
     * @type {PbxRuleCallTypeType}
     * @memberof PbxInboundRule
     */
    'CallType'?: PbxRuleCallTypeType | null;
    /**
     * 
     * @type {PbxRuleConditionType}
     * @memberof PbxInboundRule
     */
    'Condition'?: PbxRuleConditionType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRule
     */
    'CustomData'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRule
     */
    'Data'?: string | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxInboundRule
     */
    'HolidaysDestination'?: PbxDestination | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxInboundRule
     */
    'Hours'?: PbxSchedule | null;
    /**
     * 
     * @type {number}
     * @memberof PbxInboundRule
     */
    'Id'?: number;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxInboundRule
     */
    'OfficeHoursDestination'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxInboundRule
     */
    'OutOfOfficeHoursDestination'?: PbxDestination | null;
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRule
     */
    'RuleName'?: string | null;
    /**
     * 
     * @type {PbxPeer}
     * @memberof PbxInboundRule
     */
    'TrunkDN'?: PbxPeer | null;
}


/**
 * 
 * @export
 * @interface PbxInboundRuleCollectionResponse
 */
export interface PbxInboundRuleCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxInboundRuleCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxInboundRule>}
     * @memberof PbxInboundRuleCollectionResponse
     */
    'value'?: Array<PbxInboundRule>;
}
/**
 * 
 * @export
 * @interface PbxInboundRuleReport
 */
export interface PbxInboundRuleReport {
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRuleReport
     */
    'DID'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxInboundRuleReport
     */
    'Id'?: number;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxInboundRuleReport
     */
    'InOfficeRouting'?: PbxDestination | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxInboundRuleReport
     */
    'OutOfficeRouting'?: PbxDestination | null;
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRuleReport
     */
    'RuleName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxInboundRuleReport
     */
    'Trunk'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxInboundRuleReportCollectionResponse
 */
export interface PbxInboundRuleReportCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxInboundRuleReportCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxInboundRuleReport>}
     * @memberof PbxInboundRuleReportCollectionResponse
     */
    'value'?: Array<PbxInboundRuleReport>;
}
/**
 * 
 * @export
 * @interface PbxInstallUpdates
 */
export interface PbxInstallUpdates {
    /**
     * 
     * @type {Array<string>}
     * @memberof PbxInstallUpdates
     */
    'Entries'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PbxInstallUpdates
     */
    'Key'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxIntegrationSyncType = {
    SyncAllUsers: 'SyncAllUsers',
    SyncAllUsersExceptSelected: 'SyncAllUsersExceptSelected',
    SyncSelected: 'SyncSelected'
} as const;

export type PbxIntegrationSyncType = typeof PbxIntegrationSyncType[keyof typeof PbxIntegrationSyncType];


/**
 * 
 * @export
 * @interface PbxKeyValuePair2OfStringOnBoardConnectedParticipantCollectionResponse
 */
export interface PbxKeyValuePair2OfStringOnBoardConnectedParticipantCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxKeyValuePair2OfStringOnBoardConnectedParticipantCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof PbxKeyValuePair2OfStringOnBoardConnectedParticipantCollectionResponse
     */
    'value'?: Array<object>;
}
/**
 * 
 * @export
 * @interface PbxLanguageItem
 */
export interface PbxLanguageItem {
    /**
     * 
     * @type {string}
     * @memberof PbxLanguageItem
     */
    'Code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLanguageItem
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxLicense
 */
export interface PbxLicense {
    /**
     * 
     * @type {string}
     * @memberof PbxLicense
     */
    'CountryCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLicense
     */
    'IsMaintainceExpired'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicense
     */
    'ProductCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxLicenseStatus
 */
export interface PbxLicenseStatus {
    /**
     * 
     * @type {boolean}
     * @memberof PbxLicenseStatus
     */
    'Activated'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxLicenseStatus
     */
    'ActiveModules'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'AdminEMail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'CompanyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'ContactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'CountryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'CountryName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'EMail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'ExpirationDate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLicenseStatus
     */
    'LicenseActive'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'LicenseKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'MaintenanceExpiresAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxLicenseStatus
     */
    'MaxSimCalls'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'ProductCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'ResellerName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxLicenseStatus
     */
    'SimMeetingParticipants'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLicenseStatus
     */
    'Support'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'Telephone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLicenseStatus
     */
    'Version'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxLiveChatAdvancedSettings
 */
export interface PbxLiveChatAdvancedSettings {
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatAdvancedSettings
     */
    'CallTitle'?: string | null;
    /**
     * 
     * @type {PbxLiveChatCommunication}
     * @memberof PbxLiveChatAdvancedSettings
     */
    'CommunicationOptions'?: PbxLiveChatCommunication | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLiveChatAdvancedSettings
     */
    'EnableDirectCall'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLiveChatAdvancedSettings
     */
    'IgnoreQueueOwnership'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxLiveChatBox
 */
export interface PbxLiveChatBox {
    /**
     * 
     * @type {PbxButtonIconType}
     * @memberof PbxLiveChatBox
     */
    'ButtonIconType'?: PbxButtonIconType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatBox
     */
    'ButtonIconUrl'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxLiveChatBox
     */
    'ChatDelay'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatBox
     */
    'Height'?: string | null;
    /**
     * 
     * @type {PbxLiveChatLanguage}
     * @memberof PbxLiveChatBox
     */
    'LiveChatLanguage'?: PbxLiveChatLanguage | null;
    /**
     * 
     * @type {PbxLiveMessageUserinfoFormat}
     * @memberof PbxLiveChatBox
     */
    'LiveMessageUserinfoFormat'?: PbxLiveMessageUserinfoFormat | null;
    /**
     * 
     * @type {PbxLiveChatMessageDateformat}
     * @memberof PbxLiveChatBox
     */
    'MessageDateformat'?: PbxLiveChatMessageDateformat | null;
    /**
     * 
     * @type {PbxLiveChatMinimizedStyle}
     * @memberof PbxLiveChatBox
     */
    'MinimizedStyle'?: PbxLiveChatMinimizedStyle | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatBox
     */
    'OperatorIcon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatBox
     */
    'OperatorName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLiveChatBox
     */
    'ShowOperatorActualName'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatBox
     */
    'WindowIcon'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveChatCommunication = {
    ChatOnly: 'ChatOnly',
    PhoneAndChat: 'PhoneAndChat',
    PhoneOnly: 'PhoneOnly',
    VideoPhoneAndChat: 'VideoPhoneAndChat'
} as const;

export type PbxLiveChatCommunication = typeof PbxLiveChatCommunication[keyof typeof PbxLiveChatCommunication];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveChatGreeting = {
    Disabled: 'Disabled',
    OnlyOnDesktop: 'OnlyOnDesktop',
    OnlyOnMobile: 'OnlyOnMobile',
    DesktopAndMobile: 'DesktopAndMobile'
} as const;

export type PbxLiveChatGreeting = typeof PbxLiveChatGreeting[keyof typeof PbxLiveChatGreeting];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveChatLanguage = {
    Browser: 'browser',
    En: 'en',
    Es: 'es',
    De: 'de',
    Fr: 'fr',
    It: 'it',
    Pl: 'pl',
    Ru: 'ru',
    Pt: 'pt',
    Zh: 'zh'
} as const;

export type PbxLiveChatLanguage = typeof PbxLiveChatLanguage[keyof typeof PbxLiveChatLanguage];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveChatMessageDateformat = {
    Date: 'Date',
    Time: 'Time',
    Both: 'Both'
} as const;

export type PbxLiveChatMessageDateformat = typeof PbxLiveChatMessageDateformat[keyof typeof PbxLiveChatMessageDateformat];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveChatMinimizedStyle = {
    BubbleLeft: 'BubbleLeft',
    BubbleRight: 'BubbleRight',
    BottomLeft: 'BottomLeft',
    BottomRight: 'BottomRight'
} as const;

export type PbxLiveChatMinimizedStyle = typeof PbxLiveChatMinimizedStyle[keyof typeof PbxLiveChatMinimizedStyle];


/**
 * 
 * @export
 * @interface PbxLiveChatStyling
 */
export interface PbxLiveChatStyling {
    /**
     * 
     * @type {PbxAnimationStyle}
     * @memberof PbxLiveChatStyling
     */
    'Animation'?: PbxAnimationStyle | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLiveChatStyling
     */
    'Minimized'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLiveChatStyling
     */
    'Style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLiveChatStyling
     */
    'UseRubik'?: boolean | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxLiveMessageUserinfoFormat = {
    Avatar: 'Avatar',
    Name: 'Name',
    Both: 'Both',
    None: 'None'
} as const;

export type PbxLiveMessageUserinfoFormat = typeof PbxLiveMessageUserinfoFormat[keyof typeof PbxLiveMessageUserinfoFormat];


/**
 * 
 * @export
 * @interface PbxLocationSettings
 */
export interface PbxLocationSettings {
    /**
     * 
     * @type {PbxFileSystemType}
     * @memberof PbxLocationSettings
     */
    'FileSystemType'?: PbxFileSystemType | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxLocationSettings
     */
    'FtpPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'FtpPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'FtpUser'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxLocationSettings
     */
    'FtpValidateCertificate'?: boolean | null;
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxLocationSettings
     */
    'GbJson'?: PbxConcealedDataFile | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'GbPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'LocalPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'NsDomain'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxLocationSettings
     */
    'NsPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'NsPath'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'NsUser'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxLocationSettings
     */
    'SftpPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'SftpPath'?: string | null;
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxLocationSettings
     */
    'SftpPrivateKey'?: PbxConcealedDataFile | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'SftpUser'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxLocationSettings
     */
    'SharePointPath'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxLoggingSettings
 */
export interface PbxLoggingSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxLoggingSettings
     */
    'KeepLogs'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxLoggingSettings
     */
    'KeepLogsDays'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxLoggingSettings
     */
    'LoggingLevel'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxMCURequestStatus
 */
export interface PbxMCURequestStatus {
    /**
     * 
     * @type {string}
     * @memberof PbxMCURequestStatus
     */
    'ErrorMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMCURequestStatus
     */
    'McuId'?: string | null;
    /**
     * 
     * @type {PbxMcuOperation}
     * @memberof PbxMCURequestStatus
     */
    'Operation'?: PbxMcuOperation | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMCURequestStatus
     */
    'RequestExpiration'?: string | null;
    /**
     * 
     * @type {PbxMcuReqState}
     * @memberof PbxMCURequestStatus
     */
    'State'?: PbxMcuReqState | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxMailServerType = {
    Tcx: 'Tcx',
    Ms365: 'MS365',
    Custom: 'Custom'
} as const;

export type PbxMailServerType = typeof PbxMailServerType[keyof typeof PbxMailServerType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxMatchingStrategyType = {
    MatchAnyFields: 'MatchAnyFields',
    MatchAllFields: 'MatchAllFields'
} as const;

export type PbxMatchingStrategyType = typeof PbxMatchingStrategyType[keyof typeof PbxMatchingStrategyType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxMcuOperation = {
    Create: 'Create',
    Delete: 'Delete'
} as const;

export type PbxMcuOperation = typeof PbxMcuOperation[keyof typeof PbxMcuOperation];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxMcuReqState = {
    Pending: 'Pending',
    Success: 'Success',
    Failure: 'Failure'
} as const;

export type PbxMcuReqState = typeof PbxMcuReqState[keyof typeof PbxMcuReqState];


/**
 * 
 * @export
 * @interface PbxMeetingObj
 */
export interface PbxMeetingObj {
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'documentlist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'friendlyname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'meetingid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'meetingprofile'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'openlink'?: string;
    /**
     * 
     * @type {PbxParticipantDetails}
     * @memberof PbxMeetingObj
     */
    'organizer'?: PbxParticipantDetails;
    /**
     * 
     * @type {PbxMeetingParams}
     * @memberof PbxMeetingObj
     */
    'params'?: PbxMeetingParams;
    /**
     * 
     * @type {Array<PbxParticipantDetails>}
     * @memberof PbxMeetingObj
     */
    'participants'?: Array<PbxParticipantDetails>;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingObj
     */
    'theme'?: string;
}
/**
 * 
 * @export
 * @interface PbxMeetingParams
 */
export interface PbxMeetingParams {
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'bitrate_data'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'bitrate_video'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'canchangemedia'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'clicktocall'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'forcemoderator'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'hideparticipants'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingParams
     */
    'mcu'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'meetingduration'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingParams
     */
    'meetingtitle'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'moderateparticipants'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'needorganizer'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingParams
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingParams
     */
    'org_properties'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMeetingParams
     */
    'part_properties'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'privaterooms'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMeetingParams
     */
    'quickmeeting'?: number;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365Integration
 */
export interface PbxMicrosoft365Integration {
    /**
     * 
     * @type {PbxADUsersSyncConfiguration}
     * @memberof PbxMicrosoft365Integration
     */
    'AdUsers'?: PbxADUsersSyncConfiguration | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365Integration
     */
    'ApplicationId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365Integration
     */
    'Id'?: number;
    /**
     * 
     * @type {PbxUsersSyncConfiguration}
     * @memberof PbxMicrosoft365Integration
     */
    'SharedMailboxesSync'?: PbxUsersSyncConfiguration | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365Integration
     */
    'TenantId'?: string;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365Status
 */
export interface PbxMicrosoft365Status {
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365Status
     */
    'ApplicationId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365Status
     */
    'ExceptionMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365Status
     */
    'ProvisionUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365SubscriptionTestResult
 */
export interface PbxMicrosoft365SubscriptionTestResult {
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365SubscriptionTestResult
     */
    'ExceptionMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365SubscriptionTestResult
     */
    'Fqdn'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMicrosoft365SubscriptionTestResult
     */
    'IsSubscriptionAvailable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365TeamsIntegration
 */
export interface PbxMicrosoft365TeamsIntegration {
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'AreaCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'DialPlanCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'IsDynamicIP'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'IsNativeFQDN'?: boolean | null;
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SbcCertificate'?: PbxConcealedDataFile | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SbcCertificateExpirationDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SbcFQDN'?: string | null;
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SbcPrivateKey'?: PbxConcealedDataFile | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SecureSipEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'SipDomain'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'TlsPortForNativeFQDN'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365TeamsIntegration
     */
    'TlsPortForNonNativeFQDN'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365User
 */
export interface PbxMicrosoft365User {
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365User
     */
    'Email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365User
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxMicrosoft365User
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365UserCollectionResponse
 */
export interface PbxMicrosoft365UserCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365UserCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxMicrosoft365User>}
     * @memberof PbxMicrosoft365UserCollectionResponse
     */
    'value'?: Array<PbxMicrosoft365User>;
}
/**
 * 
 * @export
 * @interface PbxMicrosoft365UsersPage
 */
export interface PbxMicrosoft365UsersPage {
    /**
     * 
     * @type {number}
     * @memberof PbxMicrosoft365UsersPage
     */
    'Total'?: number | null;
    /**
     * 
     * @type {Array<PbxMicrosoft365User>}
     * @memberof PbxMicrosoft365UsersPage
     */
    'Users'?: Array<PbxMicrosoft365User>;
}
/**
 * 
 * @export
 * @interface PbxMonitoringState
 */
export interface PbxMonitoringState {
    /**
     * 
     * @type {string}
     * @memberof PbxMonitoringState
     */
    'DN'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxMonitoringState
     */
    'Expiration'?: number;
}
/**
 * 
 * @export
 * @interface PbxMultiEditUserData
 */
export interface PbxMultiEditUserData {
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'AllowLanOnly'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'AllowOwnRecordings'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'Blfs'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'CallScreening'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'CanMoveForwardingExceptions'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'DisplayNumbers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'EmergencyAdditionalInfo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'EmergencyLocationId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'EnableHotdesking'?: boolean | null;
    /**
     * 
     * @type {Array<PbxExtensionRule>}
     * @memberof PbxMultiEditUserData
     */
    'ForwardingExceptions'?: Array<PbxExtensionRule>;
    /**
     * 
     * @type {Array<PbxForwardingProfile>}
     * @memberof PbxMultiEditUserData
     */
    'ForwardingProfiles'?: Array<PbxForwardingProfile>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'GoogleSignInEnabled'?: boolean | null;
    /**
     * 
     * @type {Array<PbxGreeting>}
     * @memberof PbxMultiEditUserData
     */
    'Greetings'?: Array<PbxGreeting>;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxMultiEditUserData
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'HideInPhonebook'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'Internal'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'Mobile'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MS365CalendarEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MS365ContactsEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MS365SignInEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MS365TeamsEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MyPhoneAllowDeleteRecordings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MyPhoneHideForwardings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'MyPhoneShowRecordings'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'Number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'PbxDeliversAudio'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'PinProtected'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxMultiEditUserData
     */
    'PinProtectTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMultiEditUserData
     */
    'PromptSet'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'RecordCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'RecordExternalCallsOnly'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'SendEmailMissedCalls'?: boolean | null;
    /**
     * 
     * @type {PbxSRTPModeType}
     * @memberof PbxMultiEditUserData
     */
    'SRTPMode'?: PbxSRTPModeType | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxMultiEditUserData
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'VMDisablePinAuth'?: boolean | null;
    /**
     * 
     * @type {PbxVMEmailOptionsType}
     * @memberof PbxMultiEditUserData
     */
    'VMEmailOptions'?: PbxVMEmailOptionsType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'VMEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMultiEditUserData
     */
    'VMPlayCallerID'?: boolean | null;
    /**
     * 
     * @type {PbxVMPlayMsgDateTimeType}
     * @memberof PbxMultiEditUserData
     */
    'VMPlayMsgDateTime'?: PbxVMPlayMsgDateTimeType | null;
}


/**
 * 
 * @export
 * @interface PbxMusicOnHoldSettings
 */
export interface PbxMusicOnHoldSettings {
    /**
     * 
     * @type {number}
     * @memberof PbxMusicOnHoldSettings
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold4'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold5'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold6'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold7'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold8'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHold9'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHoldRandomize'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxMusicOnHoldSettings
     */
    'MusicOnHoldRandomizePerCall'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxNetworkInterface
 */
export interface PbxNetworkInterface {
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkInterface
     */
    'Id'?: string;
}
/**
 * 
 * @export
 * @interface PbxNetworkInterfaceCollectionResponse
 */
export interface PbxNetworkInterfaceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkInterfaceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxNetworkInterface>}
     * @memberof PbxNetworkInterfaceCollectionResponse
     */
    'value'?: Array<PbxNetworkInterface>;
}
/**
 * 
 * @export
 * @interface PbxNetworkSettings
 */
export interface PbxNetworkSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxNetworkSettings
     */
    'AllowSourceAsOutbound'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNetworkSettings
     */
    'DirectSIPAllowExternal'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'DirectSIPLocalDomain'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNetworkSettings
     */
    'FirewallKeepAlive'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'FirewallKeepAliveInterval'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'Id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNetworkSettings
     */
    'IpV6BindingEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'PbxPublicFQDN'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'PublicInterface'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'PublicStaticIP'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'SipPort'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNetworkSettings
     */
    'StunDisabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'StunPrimaryHost'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'StunPrimaryPort'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'StunQuery'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'StunSecondaryHost'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'StunSecondaryPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNetworkSettings
     */
    'StunThirdHost'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'StunThirdPort'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNetworkSettings
     */
    'TunnelPort'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxNotificationSettings
 */
export interface PbxNotificationSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'CanEditEmailAddresses'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'CanEditMailServerType'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNotificationSettings
     */
    'EmailAddresses'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNotificationSettings
     */
    'FakeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxNotificationSettings
     */
    'MailAddress'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxNotificationSettings
     */
    'MailPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNotificationSettings
     */
    'MailServer'?: string | null;
    /**
     * 
     * @type {PbxMailServerType}
     * @memberof PbxNotificationSettings
     */
    'MailServerType'?: PbxMailServerType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'MailSslEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxNotificationSettings
     */
    'MailUser'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyCallDenied'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyEmergencyNumberDialed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyExtensionAdded'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyIPBlocked'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyLicenseLimit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyNetworkError'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyRequestAntiHacked'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyServiceStopped'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyStorageLimit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifySTUNError'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifySuccessScheduledBackups'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifySystemOwners'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyTrunkError'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyTrunkFailover'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyTrunkStatusChanged'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyUpdatesAvailable'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyWhenRecordingsQuotaReached'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxNotificationSettings
     */
    'NotifyWhenVoicemailQuotaReached'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNotificationSettings
     */
    'RecordingsQuotaPercentage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxNotificationSettings
     */
    'VoicemailQuotaPercentage'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxODataErrorsErrorDetails
 */
export interface PbxODataErrorsErrorDetails {
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsErrorDetails
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsErrorDetails
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsErrorDetails
     */
    'target'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxODataErrorsMainError
 */
export interface PbxODataErrorsMainError {
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsMainError
     */
    'code': string;
    /**
     * 
     * @type {Array<PbxODataErrorsErrorDetails>}
     * @memberof PbxODataErrorsMainError
     */
    'details'?: Array<PbxODataErrorsErrorDetails>;
    /**
     * The structure of this object is service-specific
     * @type {object}
     * @memberof PbxODataErrorsMainError
     */
    'innerError'?: object;
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsMainError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PbxODataErrorsMainError
     */
    'target'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxODataErrorsODataError
 */
export interface PbxODataErrorsODataError {
    /**
     * 
     * @type {PbxODataErrorsMainError}
     * @memberof PbxODataErrorsODataError
     */
    'error': PbxODataErrorsMainError;
}
/**
 * 
 * @export
 * @interface PbxOauthState
 */
export interface PbxOauthState {
    /**
     * 
     * @type {string}
     * @memberof PbxOauthState
     */
    'State'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxOauthStateParam
 */
export interface PbxOauthStateParam {
    /**
     * 
     * @type {string}
     * @memberof PbxOauthStateParam
     */
    'RedirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOauthStateParam
     */
    'Variable'?: string;
}
/**
 * 
 * @export
 * @interface PbxOfficeHours
 */
export interface PbxOfficeHours {
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxOfficeHours
     */
    'BreakTime'?: PbxSchedule | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxOfficeHours
     */
    'Hours'?: PbxSchedule | null;
    /**
     * 
     * @type {Array<PbxHoliday>}
     * @memberof PbxOfficeHours
     */
    'OfficeHolidays'?: Array<PbxHoliday>;
    /**
     * 
     * @type {string}
     * @memberof PbxOfficeHours
     */
    'SystemLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOfficeHours
     */
    'TimeZoneId'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxOfficeHoursBits = {
    GlobalSchedule: 'GlobalSchedule',
    AutoSwitchProfiles: 'AutoSwitchProfiles',
    AutoQueueLogOut: 'AutoQueueLogOut',
    BlockOutboundCalls: 'BlockOutboundCalls'
} as const;

export type PbxOfficeHoursBits = typeof PbxOfficeHoursBits[keyof typeof PbxOfficeHoursBits];


/**
 * 
 * @export
 * @interface PbxOnBoardMcuData
 */
export interface PbxOnBoardMcuData {
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'Attempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'AttendeeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'ClockSkew'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuData
     */
    'Connected'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'Cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'Delay'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuData
     */
    'Fqdn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'FreeDiskSpace'?: number;
    /**
     * 
     * @type {PbxOnBoardMcuDataDetail}
     * @memberof PbxOnBoardMcuData
     */
    'Mcu'?: PbxOnBoardMcuDataDetail;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'MeetingCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'Memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'NetIn'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'NetOut'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuData
     */
    'RestartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuData
     */
    'StartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuData
     */
    'Ts'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuData
     */
    'UpdateInterval'?: number;
}
/**
 * 
 * @export
 * @interface PbxOnBoardMcuDataDetail
 */
export interface PbxOnBoardMcuDataDetail {
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Cloud'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Host'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Port'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuDataDetail
     */
    'Version'?: string;
}
/**
 * 
 * @export
 * @interface PbxOnBoardMcuRow
 */
export interface PbxOnBoardMcuRow {
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuRow
     */
    'Active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuRow
     */
    'BandCap'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'CityName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuRow
     */
    'Cloud'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'CountryName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuRow
     */
    'Enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Host'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'InstallScript'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Ip'?: string;
    /**
     * 
     * @type {PbxOnBoardMcuRowLatitude}
     * @memberof PbxOnBoardMcuRow
     */
    'Latitude'?: PbxOnBoardMcuRowLatitude;
    /**
     * 
     * @type {PbxOnBoardMcuRowLatitude}
     * @memberof PbxOnBoardMcuRow
     */
    'Longitude'?: PbxOnBoardMcuRowLatitude;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMcuRow
     */
    'ManualGeo'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuRow
     */
    'PartsCap'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuRow
     */
    'Port'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Secret'?: string;
    /**
     * 
     * @type {PbxOnBoardMcuServerOS}
     * @memberof PbxOnBoardMcuRow
     */
    'ServerOS'?: PbxOnBoardMcuServerOS;
    /**
     * 
     * @type {number}
     * @memberof PbxOnBoardMcuRow
     */
    'ServerStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'TsActivated'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'TsCreated'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMcuRow
     */
    'Zone'?: string;
}


/**
 * @type PbxOnBoardMcuRowLatitude
 * @export
 */
export type PbxOnBoardMcuRowLatitude = ReferenceNumeric | number | string;

/**
 * 
 * @export
 * @enum {string}
 */

export const PbxOnBoardMcuServerOS = {
    Debian10: 'Debian10',
    Debian11: 'Debian11',
    Debian12: 'Debian12'
} as const;

export type PbxOnBoardMcuServerOS = typeof PbxOnBoardMcuServerOS[keyof typeof PbxOnBoardMcuServerOS];


/**
 * 
 * @export
 * @interface PbxOnBoardMeeting
 */
export interface PbxOnBoardMeeting {
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMeeting
     */
    'McuFqdn'?: string;
    /**
     * 
     * @type {PbxMeetingObj}
     * @memberof PbxOnBoardMeeting
     */
    'Meeting'?: PbxMeetingObj;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMeeting
     */
    'MeetingId'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof PbxOnBoardMeeting
     */
    'Parts'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMeeting
     */
    'Profile'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOnBoardMeeting
     */
    'Recorded'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMeeting
     */
    'Sessionid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxOnBoardMeeting
     */
    'Start'?: string;
}
/**
 * 
 * @export
 * @interface PbxOutboundRoute
 */
export interface PbxOutboundRoute {
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRoute
     */
    'Append'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRoute
     */
    'CallerID'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRoute
     */
    'Prepend'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRoute
     */
    'StripDigits'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRoute
     */
    'TrunkId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRoute
     */
    'TrunkName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxOutboundRouteCollectionResponse
 */
export interface PbxOutboundRouteCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRouteCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOutboundRoute>}
     * @memberof PbxOutboundRouteCollectionResponse
     */
    'value'?: Array<PbxOutboundRoute>;
}
/**
 * 
 * @export
 * @interface PbxOutboundRule
 */
export interface PbxOutboundRule {
    /**
     * 
     * @type {Array<PbxDNRange>}
     * @memberof PbxOutboundRule
     */
    'DNRanges'?: Array<PbxDNRange>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxOutboundRule
     */
    'EmergencyRule'?: boolean | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof PbxOutboundRule
     */
    'GroupIds'?: Array<number>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxOutboundRule
     */
    'GroupNames'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRule
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRule
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRule
     */
    'NumberLengthRanges'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxOutboundRule
     */
    'Prefix'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRule
     */
    'Priority'?: number | null;
    /**
     * 
     * @type {Array<PbxOutboundRoute>}
     * @memberof PbxOutboundRule
     */
    'Routes'?: Array<PbxOutboundRoute>;
}
/**
 * 
 * @export
 * @interface PbxOutboundRuleCollectionResponse
 */
export interface PbxOutboundRuleCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxOutboundRuleCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxOutboundRule>}
     * @memberof PbxOutboundRuleCollectionResponse
     */
    'value'?: Array<PbxOutboundRule>;
}
/**
 * 
 * @export
 * @interface PbxParameter
 */
export interface PbxParameter {
    /**
     * 
     * @type {string}
     * @memberof PbxParameter
     */
    'Description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxParameter
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxParameter
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxParameter
     */
    'Value'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxParameterCollectionResponse
 */
export interface PbxParameterCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxParameterCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxParameter>}
     * @memberof PbxParameterCollectionResponse
     */
    'value'?: Array<PbxParameter>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxParameterType = {
    String: 'String',
    Integer: 'Integer',
    Double: 'Double',
    Boolean: 'Boolean',
    DateTime: 'DateTime',
    Password: 'Password',
    OAuth: 'OAuth',
    List: 'List'
} as const;

export type PbxParameterType = typeof PbxParameterType[keyof typeof PbxParameterType];


/**
 * 
 * @export
 * @interface PbxParking
 */
export interface PbxParking {
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxParking
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {number}
     * @memberof PbxParking
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxParking
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxParking
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
}


/**
 * 
 * @export
 * @interface PbxParkingCollectionResponse
 */
export interface PbxParkingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxParkingCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxParking>}
     * @memberof PbxParkingCollectionResponse
     */
    'value'?: Array<PbxParking>;
}
/**
 * 
 * @export
 * @interface PbxParticipantDetails
 */
export interface PbxParticipantDetails {
    /**
     * 
     * @type {string}
     * @memberof PbxParticipantDetails
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxParticipantDetails
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxParticipantDetails
     */
    'moderator'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxParticipantDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxParticipantDetails
     */
    'pbx_extension'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxParticipantDetailsCollectionResponse
 */
export interface PbxParticipantDetailsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxParticipantDetailsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxParticipantDetails>}
     * @memberof PbxParticipantDetailsCollectionResponse
     */
    'value'?: Array<PbxParticipantDetails>;
}
/**
 * 
 * @export
 * @interface PbxPeer
 */
export interface PbxPeer {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPeer
     */
    'Hidden'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPeer
     */
    'Id'?: number;
    /**
     * 
     * @type {Array<PbxPeerGroup>}
     * @memberof PbxPeer
     */
    'MemberOf'?: Array<PbxPeerGroup>;
    /**
     * 
     * @type {string}
     * @memberof PbxPeer
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPeer
     */
    'Number'?: string | null;
    /**
     * 
     * @type {Array<PbxUserTag>}
     * @memberof PbxPeer
     */
    'Tags'?: Array<PbxUserTag>;
    /**
     * 
     * @type {PbxPeerType}
     * @memberof PbxPeer
     */
    'Type'?: PbxPeerType | null;
}


/**
 * 
 * @export
 * @interface PbxPeerCollectionResponse
 */
export interface PbxPeerCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPeerCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPeer>}
     * @memberof PbxPeerCollectionResponse
     */
    'value'?: Array<PbxPeer>;
}
/**
 * 
 * @export
 * @interface PbxPeerGroup
 */
export interface PbxPeerGroup {
    /**
     * 
     * @type {number}
     * @memberof PbxPeerGroup
     */
    'GroupID'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxPeerGroup
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPeerGroup
     */
    'Number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPeerGroup
     */
    'RoleName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPeerGroupCollectionResponse
 */
export interface PbxPeerGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPeerGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPeerGroup>}
     * @memberof PbxPeerGroupCollectionResponse
     */
    'value'?: Array<PbxPeerGroup>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPeerType = {
    None: 'None',
    Extension: 'Extension',
    Queue: 'Queue',
    RingGroup: 'RingGroup',
    Ivr: 'IVR',
    Fax: 'Fax',
    Conference: 'Conference',
    Parking: 'Parking',
    ExternalLine: 'ExternalLine',
    SpecialMenu: 'SpecialMenu',
    Group: 'Group',
    RoutePoint: 'RoutePoint'
} as const;

export type PbxPeerType = typeof PbxPeerType[keyof typeof PbxPeerType];


/**
 * 
 * @export
 * @interface PbxPeriod
 */
export interface PbxPeriod {
    /**
     * 
     * @type {PbxDayOfWeek}
     * @memberof PbxPeriod
     */
    'DayOfWeek'?: PbxDayOfWeek | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPeriod
     */
    'Start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPeriod
     */
    'Stop'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxPeriodCollectionResponse
 */
export interface PbxPeriodCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPeriodCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPeriod>}
     * @memberof PbxPeriodCollectionResponse
     */
    'value'?: Array<PbxPeriod>;
}
/**
 * 
 * @export
 * @interface PbxPhone
 */
export interface PbxPhone {
    /**
     * 
     * @type {number}
     * @memberof PbxPhone
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'Interface'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'MacAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'ProvisioningLinkExt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'ProvisioningLinkLocal'?: string | null;
    /**
     * 
     * @type {PbxPhoneSettings}
     * @memberof PbxPhone
     */
    'Settings'?: PbxPhoneSettings | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhone
     */
    'TemplateName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPhoneBookSettings
 */
export interface PbxPhoneBookSettings {
    /**
     * 
     * @type {PbxTypeOfPhoneBookAddQueueName}
     * @memberof PbxPhoneBookSettings
     */
    'PhoneBookAddQueueName'?: PbxTypeOfPhoneBookAddQueueName | null;
    /**
     * 
     * @type {PbxTypeOfPhoneBookDisplay}
     * @memberof PbxPhoneBookSettings
     */
    'PhoneBookDisplay'?: PbxTypeOfPhoneBookDisplay | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneBookSettings
     */
    'ResolvingLength'?: number | null;
    /**
     * 
     * @type {PbxTypeOfPhoneBookResolving}
     * @memberof PbxPhoneBookSettings
     */
    'ResolvingType'?: PbxTypeOfPhoneBookResolving | null;
}


/**
 * 
 * @export
 * @interface PbxPhoneCollectionResponse
 */
export interface PbxPhoneCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhone>}
     * @memberof PbxPhoneCollectionResponse
     */
    'value'?: Array<PbxPhone>;
}
/**
 * 
 * @export
 * @interface PbxPhoneDeviceVlanInfo
 */
export interface PbxPhoneDeviceVlanInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'Configurable'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'Priority'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'PriorityConfigurable'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'PriorityMax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'PriorityMin'?: number | null;
    /**
     * 
     * @type {PbxPhoneDeviceVlanType}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'Type'?: PbxPhoneDeviceVlanType | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'VlanId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'VlanIdMax'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfo
     */
    'VlanIdMin'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxPhoneDeviceVlanInfoCollectionResponse
 */
export interface PbxPhoneDeviceVlanInfoCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneDeviceVlanInfoCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneDeviceVlanInfo>}
     * @memberof PbxPhoneDeviceVlanInfoCollectionResponse
     */
    'value'?: Array<PbxPhoneDeviceVlanInfo>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPhoneDeviceVlanType = {
    Wan: 'Wan',
    Pc: 'Pc'
} as const;

export type PbxPhoneDeviceVlanType = typeof PbxPhoneDeviceVlanType[keyof typeof PbxPhoneDeviceVlanType];


/**
 * 
 * @export
 * @interface PbxPhoneLldpInfo
 */
export interface PbxPhoneLldpInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneLldpInfo
     */
    'Configurable'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneLldpInfo
     */
    'Value'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxPhoneLogo
 */
export interface PbxPhoneLogo {
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneLogo
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneLogo
     */
    'Filename'?: string;
}
/**
 * 
 * @export
 * @interface PbxPhoneLogoCollectionResponse
 */
export interface PbxPhoneLogoCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneLogoCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneLogo>}
     * @memberof PbxPhoneLogoCollectionResponse
     */
    'value'?: Array<PbxPhoneLogo>;
}
/**
 * 
 * @export
 * @interface PbxPhoneModel
 */
export interface PbxPhoneModel {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneModel
     */
    'AddAllowed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneModel
     */
    'CanBeSBC'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneModel
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneModel
     */
    'URL'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneModel
     */
    'UserAgent'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPhoneModelCollectionResponse
 */
export interface PbxPhoneModelCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneModelCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneModel>}
     * @memberof PbxPhoneModelCollectionResponse
     */
    'value'?: Array<PbxPhoneModel>;
}
/**
 * 
 * @export
 * @interface PbxPhoneRegistrar
 */
export interface PbxPhoneRegistrar {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneRegistrar
     */
    'Capabilities'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'FirmwareAvailable'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'FirmwareVersion'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'InterfaceLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'IpAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'MAC'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'Model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'UserAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneRegistrar
     */
    'Vendor'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPhoneSettings
 */
export interface PbxPhoneSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneSettings
     */
    'AllowCustomQueueRingtones'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'Backlight'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneSettings
     */
    'Codecs'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'CustomLogo'?: string | null;
    /**
     * 
     * @type {Array<PbxCustomQueueRingtone>}
     * @memberof PbxPhoneSettings
     */
    'CustomQueueRingtones'?: Array<PbxCustomQueueRingtone>;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'DateFormat'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'Firmware'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'FirmwareLang'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneSettings
     */
    'IsLogoCustomizable'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneSettings
     */
    'IsSBC'?: boolean | null;
    /**
     * 
     * @type {PbxPhoneLldpInfo}
     * @memberof PbxPhoneSettings
     */
    'LlDpInfo'?: PbxPhoneLldpInfo | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneSettings
     */
    'LocalRTPPortEnd'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneSettings
     */
    'LocalRTPPortStart'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneSettings
     */
    'LocalSipPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'LogoDescription'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneSettings
     */
    'LogoFileExtensionAllowed'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneSettings
     */
    'OwnBlfs'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'PhoneLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'PowerLed'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'ProvisionExtendedData'?: string | null;
    /**
     * 
     * @type {PbxProvType}
     * @memberof PbxPhoneSettings
     */
    'ProvisionType'?: PbxProvType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'QueueRingTone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'RemoteSpmHost'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneSettings
     */
    'RemoteSpmPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'RingTone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'SbcName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'ScreenSaver'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'Secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'Srtp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'TimeFormat'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneSettings
     */
    'TimeZone'?: string | null;
    /**
     * 
     * @type {Array<PbxPhoneDeviceVlanInfo>}
     * @memberof PbxPhoneSettings
     */
    'VlanInfos'?: Array<PbxPhoneDeviceVlanInfo>;
    /**
     * 
     * @type {PbxXferTypeEnum}
     * @memberof PbxPhoneSettings
     */
    'XferType'?: PbxXferTypeEnum | null;
}


/**
 * 
 * @export
 * @interface PbxPhoneTemplate
 */
export interface PbxPhoneTemplate {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'AddAllowed'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'AllowedNetConfigs'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'AllowSSLProvisioning'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'BacklightTimeouts'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'Codecs'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneTemplate
     */
    'Content'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'DateFormats'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneTemplate
     */
    'DefaultQueueRingTone'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'HotdeskingAllowed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneTemplate
     */
    'Id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'IsCustom'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'Languages'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneTemplate
     */
    'MaxQueueCustomRingtones'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneModel>}
     * @memberof PbxPhoneTemplate
     */
    'Models'?: Array<PbxPhoneModel>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'PowerLedSettings'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'QueueRingTones'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'RingTones'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'RpsEnabled'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'ScreenSaverTimeouts'?: Array<string | null>;
    /**
     * 
     * @type {PbxTemplateType}
     * @memberof PbxPhoneTemplate
     */
    'TemplateType'?: PbxTemplateType | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'TimeFormats'?: Array<string | null>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPhoneTemplate
     */
    'TimeZones'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxPhoneTemplate
     */
    'URL'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhoneTemplate
     */
    'XferTypeEnabled'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxPhoneTemplateCollectionResponse
 */
export interface PbxPhoneTemplateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPhoneTemplateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPhoneTemplate>}
     * @memberof PbxPhoneTemplateCollectionResponse
     */
    'value'?: Array<PbxPhoneTemplate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPhonebookPriorityOptions = {
    NotQueryIfInPhonebookFound: 'NotQueryIfInPhonebookFound',
    AlwaysQuery: 'AlwaysQuery'
} as const;

export type PbxPhonebookPriorityOptions = typeof PbxPhonebookPriorityOptions[keyof typeof PbxPhonebookPriorityOptions];


/**
 * 
 * @export
 * @interface PbxPhonesSettings
 */
export interface PbxPhonesSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhonesSettings
     */
    'AllowMultiQueueRingtones'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhonesSettings
     */
    'AutoCleanupFirmware'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPhonesSettings
     */
    'CustomDNDProfile'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhonesSettings
     */
    'PhoneAllowMultiFirmwares'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhonesSettings
     */
    'UseProvisioningSecret'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPhonesSettings
     */
    'UseRpcForLocalPhones'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxPlaylist
 */
export interface PbxPlaylist {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPlaylist
     */
    'AutoGain'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxPlaylist
     */
    'Files'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof PbxPlaylist
     */
    'MaxVolumePercent'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPlaylist
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxPlaylist
     */
    'PromptName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPlaylist
     */
    'RepositoryPath'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPlaylist
     */
    'Shuffle'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxPlaylistCollectionResponse
 */
export interface PbxPlaylistCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPlaylistCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPlaylist>}
     * @memberof PbxPlaylistCollectionResponse
     */
    'value'?: Array<PbxPlaylist>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPmsIntegrationType = {
    Tcxpms: 'tcxpms',
    Fidelio: 'fidelio'
} as const;

export type PbxPmsIntegrationType = typeof PbxPmsIntegrationType[keyof typeof PbxPmsIntegrationType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPollingStrategyType = {
    Hunt: 'Hunt',
    RingAll: 'RingAll',
    HuntRandomStart: 'HuntRandomStart',
    NextAgent: 'NextAgent',
    LongestWaiting: 'LongestWaiting',
    LeastTalkTime: 'LeastTalkTime',
    FewestAnswered: 'FewestAnswered',
    HuntBy3s: 'HuntBy3s',
    First3Available: 'First3Available',
    SkillBasedRoutingRingAll: 'SkillBasedRouting_RingAll',
    SkillBasedRoutingHuntRandomStart: 'SkillBasedRouting_HuntRandomStart',
    SkillBasedRoutingRoundRobin: 'SkillBasedRouting_RoundRobin',
    SkillBasedRoutingFewestAnswered: 'SkillBasedRouting_FewestAnswered'
} as const;

export type PbxPollingStrategyType = typeof PbxPollingStrategyType[keyof typeof PbxPollingStrategyType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxProfileType = {
    Default: 'Default',
    Available: 'Available',
    Away: 'Away',
    OutOfOffice: 'OutOfOffice',
    Available2: 'Available2',
    OutOfOffice2: 'OutOfOffice2'
} as const;

export type PbxProfileType = typeof PbxProfileType[keyof typeof PbxProfileType];


/**
 * 
 * @export
 * @interface PbxPrompt
 */
export interface PbxPrompt {
    /**
     * 
     * @type {string}
     * @memberof PbxPrompt
     */
    'Filename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPrompt
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxPrompt
     */
    'Transcription'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPromptCollectionResponse
 */
export interface PbxPromptCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPromptCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPrompt>}
     * @memberof PbxPromptCollectionResponse
     */
    'value'?: Array<PbxPrompt>;
}
/**
 * 
 * @export
 * @interface PbxPromptSet
 */
export interface PbxPromptSet {
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'CultureCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'Folder'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxPromptSet
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'LanguageCode'?: string | null;
    /**
     * 
     * @type {Array<PbxPrompt>}
     * @memberof PbxPromptSet
     */
    'Prompts'?: Array<PbxPrompt>;
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'PromptSetName'?: string | null;
    /**
     * 
     * @type {PbxPromptSetType}
     * @memberof PbxPromptSet
     */
    'PromptSetType'?: PbxPromptSetType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxPromptSet
     */
    'UseAlternateNumberPronunciation'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPromptSet
     */
    'Version'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxPromptSetCollectionResponse
 */
export interface PbxPromptSetCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPromptSetCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxPromptSet>}
     * @memberof PbxPromptSetCollectionResponse
     */
    'value'?: Array<PbxPromptSet>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPromptSetType = {
    System: 'System',
    Custom: 'Custom'
} as const;

export type PbxPromptSetType = typeof PbxPromptSetType[keyof typeof PbxPromptSetType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxPromptType = {
    File: 'File',
    Playlist: 'Playlist'
} as const;

export type PbxPromptType = typeof PbxPromptType[keyof typeof PbxPromptType];


/**
 * 
 * @export
 * @interface PbxProperty
 */
export interface PbxProperty {
    /**
     * 
     * @type {string}
     * @memberof PbxProperty
     */
    'Description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxProperty
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxProperty
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface PbxPropertyCollectionResponse
 */
export interface PbxPropertyCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxPropertyCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxProperty>}
     * @memberof PbxPropertyCollectionResponse
     */
    'value'?: Array<PbxProperty>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxProvType = {
    LocalLan: 'LocalLan',
    RemoteExt: 'RemoteExt',
    RemoteExtSipProxyMgr: 'RemoteExtSipProxyMgr',
    Sbc: 'SBC'
} as const;

export type PbxProvType = typeof PbxProvType[keyof typeof PbxProvType];


/**
 * 
 * @export
 * @interface PbxProvisionedTrunk
 */
export interface PbxProvisionedTrunk {
    /**
     * 
     * @type {string}
     * @memberof PbxProvisionedTrunk
     */
    'FinalizeURL'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxPurgeSettings
 */
export interface PbxPurgeSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxPurgeSettings
     */
    'All'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxPurgeSettings
     */
    'Start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxPurgeSettings
     */
    'Stop'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQualityParty
 */
export interface PbxQualityParty {
    /**
     * 
     * @type {string}
     * @memberof PbxQualityParty
     */
    'AddressStr'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityParty
     */
    'Burst'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQualityParty
     */
    'Codec'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityParty
     */
    'Duration'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQualityParty
     */
    'Inbound'?: boolean | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'MOSFromPBX'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'MOSToPBX'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQualityParty
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'RTT'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'RxJitter'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'RxLost'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityParty
     */
    'RxPackets'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQualityParty
     */
    'TunAddressStr'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityParty
     */
    'TxBursts'?: number | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'TxJitter'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityParty
     */
    'TxLost'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityParty
     */
    'TxPackets'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQualityParty
     */
    'UserAgent'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQualityReport
 */
export interface PbxQualityReport {
    /**
     * 
     * @type {PbxCallCostSettingsRate}
     * @memberof PbxQualityReport
     */
    'MOS'?: PbxCallCostSettingsRate | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityReport
     */
    'OverallScore'?: number | null;
    /**
     * 
     * @type {PbxQualityParty}
     * @memberof PbxQualityReport
     */
    'Party1'?: PbxQualityParty | null;
    /**
     * 
     * @type {PbxQualityParty}
     * @memberof PbxQualityReport
     */
    'Party2'?: PbxQualityParty | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQualityReport
     */
    'Summary'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQualityReport
     */
    'Transcoding'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxQueue
 */
export interface PbxQueue {
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'AgentAvailabilityMode'?: boolean | null;
    /**
     * 
     * @type {Array<PbxQueueAgent>}
     * @memberof PbxQueue
     */
    'Agents'?: Array<PbxQueueAgent>;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'AnnouncementInterval'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'AnnounceQueuePosition'?: boolean | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxQueue
     */
    'BreakRoute'?: PbxRoute | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'CallbackEnableTime'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'CallbackPrefix'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'CallUsEnableChat'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'CallUsEnablePhone'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'CallUsEnableVideo'?: boolean | null;
    /**
     * 
     * @type {PbxAuthentication}
     * @memberof PbxQueue
     */
    'CallUsRequirement'?: PbxAuthentication | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'ClickToCallId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'EnableIntro'?: boolean | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxQueue
     */
    'ForwardNoAnswer'?: PbxDestination | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxQueue
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxQueue
     */
    'HolidaysRoute'?: PbxRoute | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'IntroFile'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {Array<PbxQueueManager>}
     * @memberof PbxQueue
     */
    'Managers'?: Array<PbxQueueManager>;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'MasterTimeout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'MaxCallersInQueue'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'Name'?: string | null;
    /**
     * 
     * @type {Array<PbxQueueNotifyCode>}
     * @memberof PbxQueue
     */
    'NotifyCodes'?: Array<PbxQueueNotifyCode>;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxQueue
     */
    'OfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'OnHoldFile'?: string | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxQueue
     */
    'OutOfOfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'PlayFullPrompt'?: boolean | null;
    /**
     * 
     * @type {PbxPollingStrategyType}
     * @memberof PbxQueue
     */
    'PollingStrategy'?: PbxPollingStrategyType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'PriorityQueue'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueue
     */
    'PromptSet'?: string | null;
    /**
     * 
     * @type {PbxQueueRecording}
     * @memberof PbxQueue
     */
    'Recording'?: PbxQueueRecording | null;
    /**
     * 
     * @type {PbxResetQueueStatisticsSchedule}
     * @memberof PbxQueue
     */
    'ResetQueueStatisticsSchedule'?: PbxResetQueueStatisticsSchedule | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxQueue
     */
    'ResetStatisticsScheduleEnabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'RingTimeout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'SLATime'?: number | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxQueue
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {PbxTypeOfChatOwnershipType}
     * @memberof PbxQueue
     */
    'TypeOfChatOwnershipType'?: PbxTypeOfChatOwnershipType | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueue
     */
    'WrapUpTime'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxQueueAgent
 */
export interface PbxQueueAgent {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgent
     */
    'Id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgent
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgent
     */
    'Number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgent
     */
    'SkillGroup'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueueAgentCollectionResponse
 */
export interface PbxQueueAgentCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAgent>}
     * @memberof PbxQueueAgentCollectionResponse
     */
    'value'?: Array<PbxQueueAgent>;
}
/**
 * 
 * @export
 * @interface PbxQueueAgentsChatStatistics
 */
export interface PbxQueueAgentsChatStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'DealtWithCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'Dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'DnDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'Queue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatistics
     */
    'QueueDisplayName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueueAgentsChatStatisticsCollectionResponse
 */
export interface PbxQueueAgentsChatStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAgentsChatStatistics>}
     * @memberof PbxQueueAgentsChatStatisticsCollectionResponse
     */
    'value'?: Array<PbxQueueAgentsChatStatistics>;
}
/**
 * 
 * @export
 * @interface PbxQueueAgentsChatStatisticsTotals
 */
export interface PbxQueueAgentsChatStatisticsTotals {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatisticsTotals
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatisticsTotals
     */
    'DealtWithCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatisticsTotals
     */
    'Queue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAgentsChatStatisticsTotals
     */
    'QueueDisplayName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueueAgentsChatStatisticsTotalsCollectionResponse
 */
export interface PbxQueueAgentsChatStatisticsTotalsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAgentsChatStatisticsTotalsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAgentsChatStatisticsTotals>}
     * @memberof PbxQueueAgentsChatStatisticsTotalsCollectionResponse
     */
    'value'?: Array<PbxQueueAgentsChatStatisticsTotals>;
}
/**
 * 
 * @export
 * @interface PbxQueueAnsweredCallsByWaitTime
 */
export interface PbxQueueAnsweredCallsByWaitTime {
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'AnsweredTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'CallTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'Destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'Dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'DnNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'RingTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'SentimentScore'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueAnsweredCallsByWaitTime
     */
    'Source'?: string;
}
/**
 * 
 * @export
 * @interface PbxQueueAnsweredCallsByWaitTimeCollectionResponse
 */
export interface PbxQueueAnsweredCallsByWaitTimeCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueAnsweredCallsByWaitTimeCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueAnsweredCallsByWaitTime>}
     * @memberof PbxQueueAnsweredCallsByWaitTimeCollectionResponse
     */
    'value'?: Array<PbxQueueAnsweredCallsByWaitTime>;
}
/**
 * 
 * @export
 * @interface PbxQueueCallbacks
 */
export interface PbxQueueCallbacks {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueCallbacks
     */
    'CallbacksCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueCallbacks
     */
    'Dn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueCallbacks
     */
    'FailCallbacksCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueCallbacks
     */
    'QueueDnNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueCallbacks
     */
    'ReceivedCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxQueueCallbacksCollectionResponse
 */
export interface PbxQueueCallbacksCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueCallbacksCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueCallbacks>}
     * @memberof PbxQueueCallbacksCollectionResponse
     */
    'value'?: Array<PbxQueueCallbacks>;
}
/**
 * 
 * @export
 * @interface PbxQueueChatPerformance
 */
export interface PbxQueueChatPerformance {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueChatPerformance
     */
    'AbandonedCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueChatPerformance
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueChatPerformance
     */
    'IncomingCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueueChatPerformance
     */
    'QuantityAgents'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueChatPerformance
     */
    'Queue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueChatPerformance
     */
    'QueueDisplayName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueueChatPerformanceCollectionResponse
 */
export interface PbxQueueChatPerformanceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueChatPerformanceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueChatPerformance>}
     * @memberof PbxQueueChatPerformanceCollectionResponse
     */
    'value'?: Array<PbxQueueChatPerformance>;
}
/**
 * 
 * @export
 * @interface PbxQueueCollectionResponse
 */
export interface PbxQueueCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueue>}
     * @memberof PbxQueueCollectionResponse
     */
    'value'?: Array<PbxQueue>;
}
/**
 * 
 * @export
 * @interface PbxQueueFailedCallbacks
 */
export interface PbxQueueFailedCallbacks {
    /**
     * 
     * @type {string}
     * @memberof PbxQueueFailedCallbacks
     */
    'CallbackNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueFailedCallbacks
     */
    'CallTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueFailedCallbacks
     */
    'Dn'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueFailedCallbacks
     */
    'QueueDnNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueFailedCallbacks
     */
    'RingTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueueFailedCallbacksCollectionResponse
 */
export interface PbxQueueFailedCallbacksCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueFailedCallbacksCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueFailedCallbacks>}
     * @memberof PbxQueueFailedCallbacksCollectionResponse
     */
    'value'?: Array<PbxQueueFailedCallbacks>;
}
/**
 * 
 * @export
 * @interface PbxQueueManager
 */
export interface PbxQueueManager {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueManager
     */
    'Id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueManager
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueueManager
     */
    'Number'?: string;
}
/**
 * 
 * @export
 * @interface PbxQueueManagerCollectionResponse
 */
export interface PbxQueueManagerCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueueManagerCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueueManager>}
     * @memberof PbxQueueManagerCollectionResponse
     */
    'value'?: Array<PbxQueueManager>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxQueueNotifyCode = {
    Callback: 'Callback',
    CallbackFail: 'CallbackFail',
    SlaTimeBreached: 'SLATimeBreached',
    CallLost: 'CallLost'
} as const;

export type PbxQueueNotifyCode = typeof PbxQueueNotifyCode[keyof typeof PbxQueueNotifyCode];


/**
 * 
 * @export
 * @interface PbxQueuePerformanceOverview
 */
export interface PbxQueuePerformanceOverview {
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceOverview
     */
    'ExtensionAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceOverview
     */
    'ExtensionDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceOverview
     */
    'ExtensionDn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceOverview
     */
    'ExtensionDroppedCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceOverview
     */
    'QueueAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceOverview
     */
    'QueueDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceOverview
     */
    'QueueDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceOverview
     */
    'QueueReceivedCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceOverview
     */
    'TalkTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxQueuePerformanceOverviewCollectionResponse
 */
export interface PbxQueuePerformanceOverviewCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceOverviewCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueuePerformanceOverview>}
     * @memberof PbxQueuePerformanceOverviewCollectionResponse
     */
    'value'?: Array<PbxQueuePerformanceOverview>;
}
/**
 * 
 * @export
 * @interface PbxQueuePerformanceTotals
 */
export interface PbxQueuePerformanceTotals {
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceTotals
     */
    'ExtensionAnsweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceTotals
     */
    'ExtensionDroppedCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceTotals
     */
    'QueueDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxQueuePerformanceTotals
     */
    'QueueDn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceTotals
     */
    'QueueReceivedCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxQueuePerformanceTotalsCollectionResponse
 */
export interface PbxQueuePerformanceTotalsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxQueuePerformanceTotalsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxQueuePerformanceTotals>}
     * @memberof PbxQueuePerformanceTotalsCollectionResponse
     */
    'value'?: Array<PbxQueuePerformanceTotals>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxQueueRecording = {
    Disabled: 'Disabled',
    AllowToOptOut: 'AllowToOptOut',
    AskToOptIn: 'AskToOptIn'
} as const;

export type PbxQueueRecording = typeof PbxQueueRecording[keyof typeof PbxQueueRecording];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxQueueStatusType = {
    LoggedOut: 'LoggedOut',
    LoggedIn: 'LoggedIn'
} as const;

export type PbxQueueStatusType = typeof PbxQueueStatusType[keyof typeof PbxQueueStatusType];


/**
 * 
 * @export
 * @interface PbxReceptionist
 */
export interface PbxReceptionist {
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxReceptionist
     */
    'BreakRoute'?: PbxRoute | null;
    /**
     * 
     * @type {Array<PbxReceptionistForward>}
     * @memberof PbxReceptionist
     */
    'Forwards'?: Array<PbxReceptionistForward>;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'ForwardSmsTo'?: string | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxReceptionist
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxReceptionist
     */
    'HolidaysRoute'?: PbxRoute | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReceptionist
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'InvalidKeyForwardDN'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxReceptionist
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {PbxIVRType}
     * @memberof PbxReceptionist
     */
    'IVRType'?: PbxIVRType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxReceptionist
     */
    'OfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxReceptionist
     */
    'OutOfOfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'PromptFilename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'PromptSet'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReceptionist
     */
    'Timeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionist
     */
    'TimeoutForwardDN'?: string | null;
    /**
     * 
     * @type {PbxPeerType}
     * @memberof PbxReceptionist
     */
    'TimeoutForwardPeerType'?: PbxPeerType | null;
    /**
     * 
     * @type {PbxIVRForwardType}
     * @memberof PbxReceptionist
     */
    'TimeoutForwardType'?: PbxIVRForwardType | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxReceptionist
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxReceptionist
     */
    'UseMSExchange'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxReceptionistCollectionResponse
 */
export interface PbxReceptionistCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxReceptionistCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxReceptionist>}
     * @memberof PbxReceptionistCollectionResponse
     */
    'value'?: Array<PbxReceptionist>;
}
/**
 * 
 * @export
 * @interface PbxReceptionistForward
 */
export interface PbxReceptionistForward {
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionistForward
     */
    'CustomData'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionistForward
     */
    'ForwardDN'?: string | null;
    /**
     * 
     * @type {PbxIVRForwardType}
     * @memberof PbxReceptionistForward
     */
    'ForwardType'?: PbxIVRForwardType;
    /**
     * 
     * @type {number}
     * @memberof PbxReceptionistForward
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxReceptionistForward
     */
    'Input'?: string | null;
    /**
     * 
     * @type {PbxPeerType}
     * @memberof PbxReceptionistForward
     */
    'PeerType'?: PbxPeerType | null;
}


/**
 * 
 * @export
 * @interface PbxReceptionistForwardCollectionResponse
 */
export interface PbxReceptionistForwardCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxReceptionistForwardCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxReceptionistForward>}
     * @memberof PbxReceptionistForwardCollectionResponse
     */
    'value'?: Array<PbxReceptionistForward>;
}
/**
 * 
 * @export
 * @interface PbxRecording
 */
export interface PbxRecording {
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ArchivedUrl'?: string | null;
    /**
     * 
     * @type {PbxRecordingCallType}
     * @memberof PbxRecording
     */
    'CallType'?: PbxRecordingCallType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'EndTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'FromCallerNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'FromCrmContact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'FromDidNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'FromDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'FromDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'FromDnType'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'FromIdParticipant'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRecording
     */
    'IsArchived'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'RecordingUrl'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'RefParticipantId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'SentimentScore'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'StartTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'Summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ToCallerNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ToCrmContact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ToDidNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ToDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'ToDn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'ToDnType'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecording
     */
    'ToIdParticipant'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecording
     */
    'Transcription'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRecordingCallType = {
    Local: 'Local',
    InboundExternal: 'InboundExternal',
    OutboundExternal: 'OutboundExternal'
} as const;

export type PbxRecordingCallType = typeof PbxRecordingCallType[keyof typeof PbxRecordingCallType];


/**
 * 
 * @export
 * @interface PbxRecordingCollectionResponse
 */
export interface PbxRecordingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRecordingCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRecording>}
     * @memberof PbxRecordingCollectionResponse
     */
    'value'?: Array<PbxRecording>;
}
/**
 * 
 * @export
 * @interface PbxRecordingRepositorySettings
 */
export interface PbxRecordingRepositorySettings {
    /**
     * 
     * @type {number}
     * @memberof PbxRecordingRepositorySettings
     */
    'AutoDeleteRecordingDays'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRecordingRepositorySettings
     */
    'AutoDeleteRecordingEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRecordingRepositorySettings
     */
    'IsRecordingArchiveEnabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecordingRepositorySettings
     */
    'RecordingDiskSpace'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRecordingRepositorySettings
     */
    'RecordingPath'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecordingRepositorySettings
     */
    'RecordingsQuota'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRecordingRepositorySettings
     */
    'RecordingUsedSpace'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxRefreshToken
 */
export interface PbxRefreshToken {
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Created'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'CreatedByIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'CreatedByUserAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Expires'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxRefreshToken
     */
    'Id'?: number;
    /**
     * 
     * @type {PbxRevokeReason}
     * @memberof PbxRefreshToken
     */
    'ReasonRevoked'?: PbxRevokeReason | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Revoked'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'RevokedByIp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRefreshToken
     */
    'SlidingExpiration'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Token'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Used'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'UsedByIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'UsedByUserAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRefreshToken
     */
    'Username'?: string;
}


/**
 * 
 * @export
 * @interface PbxRefreshTokenCollectionResponse
 */
export interface PbxRefreshTokenCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRefreshTokenCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRefreshToken>}
     * @memberof PbxRefreshTokenCollectionResponse
     */
    'value'?: Array<PbxRefreshToken>;
}
/**
 * 
 * @export
 * @interface PbxRegistrarFxs
 */
export interface PbxRegistrarFxs {
    /**
     * 
     * @type {string}
     * @memberof PbxRegistrarFxs
     */
    'InterfaceLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRegistrarFxs
     */
    'MacAddress'?: string;
}
/**
 * 
 * @export
 * @interface PbxRegistrarFxsCollectionResponse
 */
export interface PbxRegistrarFxsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRegistrarFxsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRegistrarFxs>}
     * @memberof PbxRegistrarFxsCollectionResponse
     */
    'value'?: Array<PbxRegistrarFxs>;
}
/**
 * 
 * @export
 * @interface PbxRemoteArchivingSettings
 */
export interface PbxRemoteArchivingSettings {
    /**
     * 
     * @type {PbxArchiveSubsystem}
     * @memberof PbxRemoteArchivingSettings
     */
    'Backups'?: PbxArchiveSubsystem | null;
    /**
     * 
     * @type {PbxArchiveSubsystem}
     * @memberof PbxRemoteArchivingSettings
     */
    'Chats'?: PbxArchiveSubsystem | null;
    /**
     * 
     * @type {PbxArchiveSubsystem}
     * @memberof PbxRemoteArchivingSettings
     */
    'Faxes'?: PbxArchiveSubsystem | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRemoteArchivingSettings
     */
    'Id'?: number;
    /**
     * 
     * @type {PbxLocationSettings}
     * @memberof PbxRemoteArchivingSettings
     */
    'Location'?: PbxLocationSettings | null;
    /**
     * 
     * @type {PbxArchiveSubsystem}
     * @memberof PbxRemoteArchivingSettings
     */
    'Recordings'?: PbxArchiveSubsystem | null;
    /**
     * 
     * @type {PbxArchiveSubsystem}
     * @memberof PbxRemoteArchivingSettings
     */
    'Voicemails'?: PbxArchiveSubsystem | null;
}
/**
 * 
 * @export
 * @interface PbxReportExtensionStatisticsByGroup
 */
export interface PbxReportExtensionStatisticsByGroup {
    /**
     * 
     * @type {string}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'Dn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'InboundAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'InboundAnsweredTalkingDur'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'InboundUnansweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'OutboundAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'OutboundAnsweredTalkingDur'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'OutboundUnansweredCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroup
     */
    'SentimentScore'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxReportExtensionStatisticsByGroupCollectionResponse
 */
export interface PbxReportExtensionStatisticsByGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxReportExtensionStatisticsByGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxReportExtensionStatisticsByGroup>}
     * @memberof PbxReportExtensionStatisticsByGroupCollectionResponse
     */
    'value'?: Array<PbxReportExtensionStatisticsByGroup>;
}
/**
 * 
 * @export
 * @interface PbxReportGroup
 */
export interface PbxReportGroup {
    /**
     * 
     * @type {number}
     * @memberof PbxReportGroup
     */
    'GroupID'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxReportGroup
     */
    'GroupName'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxReportGroupCollectionResponse
 */
export interface PbxReportGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxReportGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxReportGroup>}
     * @memberof PbxReportGroupCollectionResponse
     */
    'value'?: Array<PbxReportGroup>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxReportScheduleType = {
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly',
    Hourly: 'Hourly',
    NotScheduled: 'NotScheduled'
} as const;

export type PbxReportScheduleType = typeof PbxReportScheduleType[keyof typeof PbxReportScheduleType];


/**
 * 
 * @export
 * @interface PbxRequestHelp
 */
export interface PbxRequestHelp {
    /**
     * 
     * @type {number}
     * @memberof PbxRequestHelp
     */
    'GrantPeriodDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxRequestHelp
     */
    'IssueDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRequestHelp
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRequestHelp
     */
    'PhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRequestHelp
     */
    'ReplyEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxRequestHelp
     */
    'SupportEmail'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRequireRegistrationForType = {
    Nothing: 'Nothing',
    IncomingCalls: 'IncomingCalls',
    OutgoingCalls: 'OutgoingCalls',
    InOutCalls: 'InOutCalls'
} as const;

export type PbxRequireRegistrationForType = typeof PbxRequireRegistrationForType[keyof typeof PbxRequireRegistrationForType];


/**
 * 
 * @export
 * @interface PbxResellerInfo
 */
export interface PbxResellerInfo {
    /**
     * 
     * @type {string}
     * @memberof PbxResellerInfo
     */
    'Id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxResellerInfo
     */
    'Name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxResetQueueStatisticsFrequency = {
    Disabled: 'Disabled',
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly'
} as const;

export type PbxResetQueueStatisticsFrequency = typeof PbxResetQueueStatisticsFrequency[keyof typeof PbxResetQueueStatisticsFrequency];


/**
 * 
 * @export
 * @interface PbxResetQueueStatisticsSchedule
 */
export interface PbxResetQueueStatisticsSchedule {
    /**
     * 
     * @type {PbxDayOfWeek}
     * @memberof PbxResetQueueStatisticsSchedule
     */
    'Day'?: PbxDayOfWeek | null;
    /**
     * 
     * @type {PbxResetQueueStatisticsFrequency}
     * @memberof PbxResetQueueStatisticsSchedule
     */
    'Frequency'?: PbxResetQueueStatisticsFrequency | null;
    /**
     * 
     * @type {string}
     * @memberof PbxResetQueueStatisticsSchedule
     */
    'Time'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxRestoreSettings
 */
export interface PbxRestoreSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxRestoreSettings
     */
    'EncryptBackup'?: boolean | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxRestoreSettings
     */
    'EncryptBackupPassword'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {PbxBackupSchedule}
     * @memberof PbxRestoreSettings
     */
    'Schedule'?: PbxBackupSchedule | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRestoreSettings
     */
    'ScheduleEnabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxRestrictions
 */
export interface PbxRestrictions {
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'Dects'?: PbxEntityRestrictions | null;
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'LiveChats'?: PbxEntityRestrictions | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRestrictions
     */
    'MaxPrompts'?: number | null;
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'Sbcs'?: PbxEntityRestrictions | null;
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'System'?: PbxEntityRestrictions | null;
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'Trunks'?: PbxEntityRestrictions | null;
    /**
     * 
     * @type {PbxEntityRestrictions}
     * @memberof PbxRestrictions
     */
    'Users'?: PbxEntityRestrictions | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRevokeReason = {
    TooMany: 'TooMany',
    SetPassword: 'SetPassword',
    InvalidatePassword: 'InvalidatePassword',
    Logout: 'Logout',
    Manual: 'Manual'
} as const;

export type PbxRevokeReason = typeof PbxRevokeReason[keyof typeof PbxRevokeReason];


/**
 * 
 * @export
 * @interface PbxRights
 */
export interface PbxRights {
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'AllowIVR'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'AllowParking'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'AllowToChangePresence'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'AllowToManageCompanyBook'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'AssignClearOperations'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'CanBargeIn'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'CanIntercom'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'CanSeeGroupCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'CanSeeGroupMembers'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'CanSeeGroupRecordings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'Invalid'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'PerformOperations'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRights
     */
    'RoleName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'ShowMyCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'ShowMyPresence'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRights
     */
    'ShowMyPresenceOutside'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxRightsCollectionResponse
 */
export interface PbxRightsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRightsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRights>}
     * @memberof PbxRightsCollectionResponse
     */
    'value'?: Array<PbxRights>;
}
/**
 * 
 * @export
 * @interface PbxRingGroup
 */
export interface PbxRingGroup {
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxRingGroup
     */
    'BreakRoute'?: PbxRoute | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRingGroup
     */
    'CallUsEnableChat'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRingGroup
     */
    'CallUsEnablePhone'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRingGroup
     */
    'CallUsEnableVideo'?: boolean | null;
    /**
     * 
     * @type {PbxAuthentication}
     * @memberof PbxRingGroup
     */
    'CallUsRequirement'?: PbxAuthentication | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroup
     */
    'ClickToCallId'?: string | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxRingGroup
     */
    'ForwardNoAnswer'?: PbxDestination | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxRingGroup
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxRingGroup
     */
    'HolidaysRoute'?: PbxRoute | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroup
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxRingGroup
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {Array<PbxRingGroupMember>}
     * @memberof PbxRingGroup
     */
    'Members'?: Array<PbxRingGroupMember>;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroup
     */
    'MulticastAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroup
     */
    'MulticastCodec'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroup
     */
    'MulticastPacketTime'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroup
     */
    'MulticastPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroup
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroup
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxRingGroup
     */
    'OfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxRoute}
     * @memberof PbxRingGroup
     */
    'OutOfOfficeRoute'?: PbxRoute | null;
    /**
     * 
     * @type {PbxStrategyType}
     * @memberof PbxRingGroup
     */
    'RingStrategy'?: PbxStrategyType | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroup
     */
    'RingTime'?: number | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxRingGroup
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
}


/**
 * 
 * @export
 * @interface PbxRingGroupCollectionResponse
 */
export interface PbxRingGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRingGroup>}
     * @memberof PbxRingGroupCollectionResponse
     */
    'value'?: Array<PbxRingGroup>;
}
/**
 * 
 * @export
 * @interface PbxRingGroupMember
 */
export interface PbxRingGroupMember {
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupMember
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroupMember
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroupMember
     */
    'Number'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxRingGroupMemberCollectionResponse
 */
export interface PbxRingGroupMemberCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupMemberCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRingGroupMember>}
     * @memberof PbxRingGroupMemberCollectionResponse
     */
    'value'?: Array<PbxRingGroupMember>;
}
/**
 * 
 * @export
 * @interface PbxRingGroupStatistics
 */
export interface PbxRingGroupStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupStatistics
     */
    'RingGroupAnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroupStatistics
     */
    'RingGroupDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRingGroupStatistics
     */
    'RingGroupDn'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupStatistics
     */
    'RingGroupReceivedCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupStatistics
     */
    'RingGroupSentimentScore'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxRingGroupStatisticsCollectionResponse
 */
export interface PbxRingGroupStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxRingGroupStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxRingGroupStatistics>}
     * @memberof PbxRingGroupStatisticsCollectionResponse
     */
    'value'?: Array<PbxRingGroupStatistics>;
}
/**
 * 
 * @export
 * @interface PbxRoute
 */
export interface PbxRoute {
    /**
     * 
     * @type {boolean}
     * @memberof PbxRoute
     */
    'IsPromptEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxRoute
     */
    'Prompt'?: string | null;
    /**
     * 
     * @type {PbxDestination}
     * @memberof PbxRoute
     */
    'Route'?: PbxDestination | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRuleCallTypeType = {
    AllCalls: 'AllCalls',
    InternalCallsOnly: 'InternalCallsOnly',
    ExternalCallsOnly: 'ExternalCallsOnly'
} as const;

export type PbxRuleCallTypeType = typeof PbxRuleCallTypeType[keyof typeof PbxRuleCallTypeType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRuleConditionType = {
    NoAnswer: 'NoAnswer',
    PhoneBusy: 'PhoneBusy',
    PhoneNotRegistered: 'PhoneNotRegistered',
    ForwardAll: 'ForwardAll',
    BasedOnCallerId: 'BasedOnCallerID',
    BasedOnDid: 'BasedOnDID'
} as const;

export type PbxRuleConditionType = typeof PbxRuleConditionType[keyof typeof PbxRuleConditionType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxRuleHoursType = {
    AllHours: 'AllHours',
    OfficeHours: 'OfficeHours',
    OutOfOfficeHours: 'OutOfOfficeHours',
    SpecificHours: 'SpecificHours',
    SpecificHoursExcludingHolidays: 'SpecificHoursExcludingHolidays',
    OutOfSpecificHours: 'OutOfSpecificHours',
    OutOfSpecificHoursIncludingHolidays: 'OutOfSpecificHoursIncludingHolidays',
    Never: 'Never',
    BreakTime: 'BreakTime'
} as const;

export type PbxRuleHoursType = typeof PbxRuleHoursType[keyof typeof PbxRuleHoursType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxSRTPModeType = {
    SrtpDisabled: 'SRTPDisabled',
    SrtpEnabled: 'SRTPEnabled',
    SrtpEnforced: 'SRTPEnforced'
} as const;

export type PbxSRTPModeType = typeof PbxSRTPModeType[keyof typeof PbxSRTPModeType];


/**
 * 
 * @export
 * @interface PbxSbc
 */
export interface PbxSbc {
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'DisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'Group'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSbc
     */
    'HasConnection'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'LocalIPv4'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'Password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'PhoneMAC'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSbc
     */
    'PhoneUserId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'ProvisionLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'PublicIP'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSbc
     */
    'Version'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxSbcCollectionResponse
 */
export interface PbxSbcCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxSbcCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxSbc>}
     * @memberof PbxSbcCollectionResponse
     */
    'value'?: Array<PbxSbc>;
}
/**
 * 
 * @export
 * @interface PbxSchedule
 */
export interface PbxSchedule {
    /**
     * 
     * @type {boolean}
     * @memberof PbxSchedule
     */
    'IgnoreHolidays'?: boolean | null;
    /**
     * 
     * @type {Array<PbxPeriod>}
     * @memberof PbxSchedule
     */
    'Periods'?: Array<PbxPeriod>;
    /**
     * 
     * @type {PbxRuleHoursType}
     * @memberof PbxSchedule
     */
    'Type'?: PbxRuleHoursType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxScheduleType = {
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly',
    Hourly: 'Hourly',
    Immediate: 'Immediate'
} as const;

export type PbxScheduleType = typeof PbxScheduleType[keyof typeof PbxScheduleType];


/**
 * 
 * @export
 * @interface PbxScheduledReport
 */
export interface PbxScheduledReport {
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'DN'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'EmailAddresses'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'FilterDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxScheduledReport
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'ReportLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxScheduledReport
     */
    'ReportParams'?: string;
    /**
     * 
     * @type {PbxScheduledReportType}
     * @memberof PbxScheduledReport
     */
    'ReportType'?: PbxScheduledReportType;
    /**
     * 
     * @type {PbxReportScheduleType}
     * @memberof PbxScheduledReport
     */
    'ScheduleType'?: PbxReportScheduleType;
}


/**
 * 
 * @export
 * @interface PbxScheduledReportCollectionResponse
 */
export interface PbxScheduledReportCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxScheduledReportCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxScheduledReport>}
     * @memberof PbxScheduledReportCollectionResponse
     */
    'value'?: Array<PbxScheduledReport>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxScheduledReportType = {
    None: 'None',
    CallLogs: 'CallLogs',
    ChatLogs: 'ChatLogs',
    AuditLogs: 'AuditLogs',
    InboundRules: 'InboundRules',
    QueueAbandonedCalls: 'QueueAbandonedCalls',
    QueueAnsweredCallsByWaitingTime: 'QueueAnsweredCallsByWaitingTime',
    QueueCallbacks: 'QueueCallbacks',
    QueueFailedCallbacks: 'QueueFailedCallbacks',
    QueuePerformanceOverview: 'QueuePerformanceOverview',
    QueueDetailedStatistics: 'QueueDetailedStatistics',
    QueueTeamGeneralStatistics: 'QueueTeamGeneralStatistics',
    SlaStatistics: 'SlaStatistics',
    SlaBreaches: 'SlaBreaches',
    AgentInQueueStatistics: 'AgentInQueueStatistics',
    AgentLoginHistory: 'AgentLoginHistory',
    ExtensionsStatisticsByRingGroups: 'ExtensionsStatisticsByRingGroups',
    ExtensionStatistics: 'ExtensionStatistics',
    CallCostByExtensionDept: 'CallCostByExtensionDept',
    QueueChatPerformance: 'QueueChatPerformance',
    QueueAgentsChat: 'QueueAgentsChat',
    AbandonedChats: 'AbandonedChats',
    RingGroups: 'RingGroups'
} as const;

export type PbxScheduledReportType = typeof PbxScheduledReportType[keyof typeof PbxScheduledReportType];


/**
 * 
 * @export
 * @interface PbxSecureSipSettings
 */
export interface PbxSecureSipSettings {
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxSecureSipSettings
     */
    'Certificate'?: PbxConcealedDataFile | null;
    /**
     * 
     * @type {PbxConcealedDataFile}
     * @memberof PbxSecureSipSettings
     */
    'PrivateKey'?: PbxConcealedDataFile | null;
}
/**
 * 
 * @export
 * @interface PbxServiceInfo
 */
export interface PbxServiceInfo {
    /**
     * 
     * @type {number}
     * @memberof PbxServiceInfo
     */
    'CpuUsage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxServiceInfo
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxServiceInfo
     */
    'HandleCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxServiceInfo
     */
    'MemoryUsed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxServiceInfo
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxServiceInfo
     */
    'RestartEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxServiceInfo
     */
    'StartStopEnabled'?: boolean | null;
    /**
     * 
     * @type {PbxServiceStatus}
     * @memberof PbxServiceInfo
     */
    'Status'?: PbxServiceStatus | null;
    /**
     * 
     * @type {number}
     * @memberof PbxServiceInfo
     */
    'ThreadCount'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxServiceInfoCollectionResponse
 */
export interface PbxServiceInfoCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxServiceInfoCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxServiceInfo>}
     * @memberof PbxServiceInfoCollectionResponse
     */
    'value'?: Array<PbxServiceInfo>;
}
/**
 * 
 * @export
 * @interface PbxServicePrincipal
 */
export interface PbxServicePrincipal {
    /**
     * 
     * @type {boolean}
     * @memberof PbxServicePrincipal
     */
    'CallControlEnabled'?: boolean | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxServicePrincipal
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {number}
     * @memberof PbxServicePrincipal
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxServicePrincipal
     */
    'LastUsed'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxServicePrincipal
     */
    'Number'?: string | null;
    /**
     * 
     * @type {Array<PbxPeer>}
     * @memberof PbxServicePrincipal
     */
    'Peers'?: Array<PbxPeer>;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxServicePrincipal
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxServicePrincipal
     */
    'XAPIEnabled'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxServicePrincipalCollectionResponse
 */
export interface PbxServicePrincipalCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxServicePrincipalCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxServicePrincipal>}
     * @memberof PbxServicePrincipalCollectionResponse
     */
    'value'?: Array<PbxServicePrincipal>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxServiceStatus = {
    Stopped: 'Stopped',
    StartPending: 'StartPending',
    StopPending: 'StopPending',
    Running: 'Running',
    ContinuePending: 'ContinuePending',
    PausePending: 'PausePending',
    Paused: 'Paused'
} as const;

export type PbxServiceStatus = typeof PbxServiceStatus[keyof typeof PbxServiceStatus];


/**
 * 
 * @export
 * @interface PbxSetRoute
 */
export interface PbxSetRoute {
    /**
     * 
     * @type {string}
     * @memberof PbxSetRoute
     */
    'DID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxSetRoute
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSetRoute
     */
    'TrunkId'?: number;
}
/**
 * 
 * @export
 * @interface PbxSetRouteCollectionResponse
 */
export interface PbxSetRouteCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxSetRouteCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxSetRoute>}
     * @memberof PbxSetRouteCollectionResponse
     */
    'value'?: Array<PbxSetRoute>;
}
/**
 * 
 * @export
 * @interface PbxSetRouteRequest
 */
export interface PbxSetRouteRequest {
    /**
     * 
     * @type {number}
     * @memberof PbxSetRouteRequest
     */
    'Id'?: number;
    /**
     * 
     * @type {Array<PbxSetRoute>}
     * @memberof PbxSetRouteRequest
     */
    'Routes'?: Array<PbxSetRoute>;
}
/**
 * 
 * @export
 * @interface PbxSipDevice
 */
export interface PbxSipDevice {
    /**
     * 
     * @type {PbxPeer}
     * @memberof PbxSipDevice
     */
    'DN'?: PbxPeer | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSipDevice
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxSipDevice
     */
    'PhoneWebPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSipDevice
     */
    'ProvLink'?: string | null;
    /**
     * 
     * @type {PbxPhoneRegistrar}
     * @memberof PbxSipDevice
     */
    'Registrar'?: PbxPhoneRegistrar | null;
}
/**
 * 
 * @export
 * @interface PbxSipDeviceCollectionResponse
 */
export interface PbxSipDeviceCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxSipDeviceCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxSipDevice>}
     * @memberof PbxSipDeviceCollectionResponse
     */
    'value'?: Array<PbxSipDevice>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxStartupLicense = {
    Free: 'Free',
    Pro: 'Pro'
} as const;

export type PbxStartupLicense = typeof PbxStartupLicense[keyof typeof PbxStartupLicense];


/**
 * 
 * @export
 * @interface PbxStatisticSla
 */
export interface PbxStatisticSla {
    /**
     * 
     * @type {number}
     * @memberof PbxStatisticSla
     */
    'BadSlaCallsCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxStatisticSla
     */
    'Dn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxStatisticSla
     */
    'QueueDnNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxStatisticSla
     */
    'ReceivedCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxStatisticSlaCollectionResponse
 */
export interface PbxStatisticSlaCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxStatisticSlaCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxStatisticSla>}
     * @memberof PbxStatisticSlaCollectionResponse
     */
    'value'?: Array<PbxStatisticSla>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxStrategyType = {
    Hunt: 'Hunt',
    RingAll: 'RingAll',
    Paging: 'Paging'
} as const;

export type PbxStrategyType = typeof PbxStrategyType[keyof typeof PbxStrategyType];


/**
 * 
 * @export
 * @interface PbxSystemDatabaseInformation
 */
export interface PbxSystemDatabaseInformation {
    /**
     * 
     * @type {number}
     * @memberof PbxSystemDatabaseInformation
     */
    'CallHistoryCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemDatabaseInformation
     */
    'ChatFilesCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemDatabaseInformation
     */
    'ChatMessagesCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemDatabaseInformation
     */
    'Id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemDatabaseInformation
     */
    'TodayOutboundCallsCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxSystemDirectory
 */
export interface PbxSystemDirectory {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxSystemDirectory
     */
    'Dirs'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemDirectory
     */
    'Path'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxSystemExtensionStatus
 */
export interface PbxSystemExtensionStatus {
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemExtensionStatus
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemExtensionStatus
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemExtensionStatus
     */
    'Number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemExtensionStatus
     */
    'Type'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxSystemHealthStatus
 */
export interface PbxSystemHealthStatus {
    /**
     * 
     * @type {number}
     * @memberof PbxSystemHealthStatus
     */
    'CustomTemplatesCount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemHealthStatus
     */
    'Firewall'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemHealthStatus
     */
    'Id'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemHealthStatus
     */
    'Phones'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemHealthStatus
     */
    'Trunks'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemHealthStatus
     */
    'UnsupportedFirmwaresCount'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxSystemParameters
 */
export interface PbxSystemParameters {
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'Custom1Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'Custom2Name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'EmRuleCreationAllowed'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'ENL'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'FirstExternalPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'FQDN'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'GlobalACPRMSET'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'GlobalLanguage'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'HttpPort'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'HttpsPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'IpV6'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'Is3CXFQDN'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsChatLogEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsHosted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsHosted3CX'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsMulticompanyMode'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsStaticIp'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'IsTranscriptionEnabled'?: boolean | null;
    /**
     * 
     * @type {PbxLicense}
     * @memberof PbxSystemParameters
     */
    'License'?: PbxLicense | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'PbxExternalHost'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemParameters
     */
    'RpsEnabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'SipPort'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'SipsPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'StaticIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'StunIp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'TunnnelPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemParameters
     */
    'Version'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemParameters
     */
    'WebrtcLastPort'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxSystemStatus
 */
export interface PbxSystemStatus {
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'Activated'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'AutoUpdateEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'AvailableLocalIps'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'BackupScheduled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'CallsActive'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'ChatUsedSpace'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'CurrentLocalIp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'DBMaintenanceInProgress'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'DiskUsage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'ExpirationDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'ExtensionsRegistered'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'ExtensionsTotal'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'FQDN'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'FreeDiskSpace'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'HasNotRunningServices'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'HasUnregisteredSystemExtensions'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'Ip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'IpV4'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'IpV6'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'IsAuditLogEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'IsChatLogEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'IsRecordingArchiveEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'LastBackupDateTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'LastCheckForUpdates'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'LastSuccessfulUpdate'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'LicenseActive'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'LicenseKey'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'LocalIpValid'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'LogUsedSpace'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'MaintenanceExpiresAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'MaxSimCalls'?: number | null;
    /**
     * 
     * @type {PbxXOperatingSystemType}
     * @memberof PbxSystemStatus
     */
    'OS'?: PbxXOperatingSystemType | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'OutboundRules'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'ProductCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'RecordingQuota'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'RecordingQuotaReached'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'RecordingStopped'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'RecordingUsedSpace'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'RemoteConfigurationRequired'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'RemoteStorageEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'ResellerName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'Support'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'TotalDiskSpace'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'TrunksRegistered'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxSystemStatus
     */
    'TrunksTotal'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxSystemStatus
     */
    'Version'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'VoicemailQuotaReached'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxSystemStatus
     */
    'VoicemailStopped'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxTeamQueueGeneralStatistics
 */
export interface PbxTeamQueueGeneralStatistics {
    /**
     * 
     * @type {number}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'AgentsInQueueCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'AnsweredCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'AvgTalkTime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'Dn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'QueueDnNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'ReceivedCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTeamQueueGeneralStatistics
     */
    'TotalTalkTime'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxTeamQueueGeneralStatisticsCollectionResponse
 */
export interface PbxTeamQueueGeneralStatisticsCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTeamQueueGeneralStatisticsCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTeamQueueGeneralStatistics>}
     * @memberof PbxTeamQueueGeneralStatisticsCollectionResponse
     */
    'value'?: Array<PbxTeamQueueGeneralStatistics>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTemplateType = {
    Preferred: 'Preferred',
    Supported: 'Supported',
    Dedicated: 'Dedicated',
    ThirdParty: 'ThirdParty',
    Deleted: 'Deleted',
    Unknown: 'Unknown'
} as const;

export type PbxTemplateType = typeof PbxTemplateType[keyof typeof PbxTemplateType];


/**
 * 
 * @export
 * @interface PbxTestResult
 */
export interface PbxTestResult {
    /**
     * 
     * @type {string}
     * @memberof PbxTestResult
     */
    'Error'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxTestResult
     */
    'Parameters'?: Array<string | null>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTestResult
     */
    'Success'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PbxTimeReportData
 */
export interface PbxTimeReportData {
    /**
     * 
     * @type {string}
     * @memberof PbxTimeReportData
     */
    'XValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof PbxTimeReportData
     */
    'YValue1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTimeReportData
     */
    'YValue2'?: number | null;
}
/**
 * 
 * @export
 * @interface PbxTimeReportDataCollectionResponse
 */
export interface PbxTimeReportDataCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTimeReportDataCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTimeReportData>}
     * @memberof PbxTimeReportDataCollectionResponse
     */
    'value'?: Array<PbxTimeReportData>;
}
/**
 * 
 * @export
 * @interface PbxTimeZone
 */
export interface PbxTimeZone {
    /**
     * 
     * @type {string}
     * @memberof PbxTimeZone
     */
    'IanaName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxTimeZone
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxTimeZone
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxTimeZone
     */
    'WindowsName'?: string;
}
/**
 * 
 * @export
 * @interface PbxTimeZoneCollectionResponse
 */
export interface PbxTimeZoneCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTimeZoneCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTimeZone>}
     * @memberof PbxTimeZoneCollectionResponse
     */
    'value'?: Array<PbxTimeZone>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTranscribeEngine = {
    None: 'None',
    Google: 'Google',
    OpenAi: 'OpenAI',
    Whisper: 'Whisper',
    Engine3Cx: 'Engine3CX'
} as const;

export type PbxTranscribeEngine = typeof PbxTranscribeEngine[keyof typeof PbxTranscribeEngine];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTranscriptionType = {
    Nothing: 'Nothing',
    Voicemail: 'Voicemail',
    Recordings: 'Recordings',
    Both: 'Both',
    Inherit: 'Inherit'
} as const;

export type PbxTranscriptionType = typeof PbxTranscriptionType[keyof typeof PbxTranscriptionType];


/**
 * 
 * @export
 * @interface PbxTrunk
 */
export interface PbxTrunk {
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'AuthID'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'AuthPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'Certificate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'CertificateName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'ConfigurationIssue'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxTrunk
     */
    'DidNumbers'?: Array<string | null>;
    /**
     * 
     * @type {PbxDirectionType}
     * @memberof PbxTrunk
     */
    'Direction'?: PbxDirectionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'DisableVideo'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'DiversionHeader'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'E164CountryCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'E164ProcessIncomingNumber'?: boolean | null;
    /**
     * 
     * @type {Array<PbxEmergencyGeoTrunkLocation>}
     * @memberof PbxTrunk
     */
    'EmergencyGeoLocations'?: Array<PbxEmergencyGeoTrunkLocation>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'EnableInboundCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'EnableOutboundCalls'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'ExternalNumber'?: string | null;
    /**
     * 
     * @type {PbxGateway}
     * @memberof PbxTrunk
     */
    'Gateway'?: PbxGateway | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxTrunk
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunk
     */
    'Id'?: number;
    /**
     * 
     * @type {Array<PbxCIDFormatting>}
     * @memberof PbxTrunk
     */
    'InCIDFormatting'?: Array<PbxCIDFormatting>;
    /**
     * 
     * @type {PbxTypeOfIPDestriction}
     * @memberof PbxTrunk
     */
    'IPRestriction'?: PbxTypeOfIPDestriction | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'IsOnline'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'IsWebmeetingBridge'?: boolean | null;
    /**
     * 
     * @type {PbxTrunkMessaging}
     * @memberof PbxTrunk
     */
    'Messaging'?: PbxTrunkMessaging | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'Number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'OutboundCallerID'?: string | null;
    /**
     * 
     * @type {Array<PbxCIDFormatting>}
     * @memberof PbxTrunk
     */
    'OutCIDFormatting'?: Array<PbxCIDFormatting>;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxTrunk
     */
    'PublicInfoGroups'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'PublicIPinSIP'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'PublishInfo'?: boolean | null;
    /**
     * 
     * @type {Array<PbxPeer>}
     * @memberof PbxTrunk
     */
    'ReceiveExtensions'?: Array<PbxPeer>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'ReceiveInfo'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'RemoteMyPhoneUriHost'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'RemotePBXPreffix'?: string | null;
    /**
     * 
     * @type {Array<PbxInboundRule>}
     * @memberof PbxTrunk
     */
    'RoutingRules'?: Array<PbxInboundRule>;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'SecondaryRegistrar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'SeparateAuthId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunk
     */
    'SimultaneousCalls'?: number | null;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxTrunk
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {PbxTypeOfTransportRestriction}
     * @memberof PbxTrunk
     */
    'TransportRestriction'?: PbxTypeOfTransportRestriction | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'TunnelEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunk
     */
    'TunnelRemoteAddr'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunk
     */
    'TunnelRemotePort'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunk
     */
    'UseSeparateAuthId'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PbxTrunkCollectionResponse
 */
export interface PbxTrunkCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTrunk>}
     * @memberof PbxTrunkCollectionResponse
     */
    'value'?: Array<PbxTrunk>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTrunkEditorType = {
    Messaging: 'Messaging',
    Voip: 'Voip'
} as const;

export type PbxTrunkEditorType = typeof PbxTrunkEditorType[keyof typeof PbxTrunkEditorType];


/**
 * 
 * @export
 * @interface PbxTrunkMessaging
 */
export interface PbxTrunkMessaging {
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunkMessaging
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkMessaging
     */
    'Provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkMessaging
     */
    'Webhook'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxTrunkMessagingTemplate
 */
export interface PbxTrunkMessagingTemplate {
    /**
     * 
     * @type {Array<PbxTrunkVariable>}
     * @memberof PbxTrunkMessagingTemplate
     */
    'MessagingVariables'?: Array<PbxTrunkVariable>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunkMessagingTemplate
     */
    'Optional'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunkMessagingTemplate
     */
    'Outbound'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkMessagingTemplate
     */
    'Provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkMessagingTemplate
     */
    'Type'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxTrunkTemplate
 */
export interface PbxTrunkTemplate {
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunkTemplate
     */
    'AddAllowed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkTemplate
     */
    'Content'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxTrunkTemplate
     */
    'Countries'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkTemplate
     */
    'DefaultProxyPort'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkTemplate
     */
    'DefaultRegistrarPort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkTemplate
     */
    'Description'?: string | null;
    /**
     * 
     * @type {Array<PbxTrunkEditorType>}
     * @memberof PbxTrunkTemplate
     */
    'Editors'?: Array<PbxTrunkEditorType>;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkTemplate
     */
    'Id'?: string;
    /**
     * 
     * @type {PbxTrunkMessagingTemplate}
     * @memberof PbxTrunkTemplate
     */
    'MessagingTemplate'?: PbxTrunkMessagingTemplate | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkTemplate
     */
    'Name'?: string;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxTrunkTemplate
     */
    'Tags'?: Array<string | null>;
    /**
     * 
     * @type {PbxTemplateType}
     * @memberof PbxTrunkTemplate
     */
    'TemplateType'?: PbxTemplateType;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkTemplate
     */
    'Url'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxTrunkTemplateCollectionResponse
 */
export interface PbxTrunkTemplateCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkTemplateCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTrunkTemplate>}
     * @memberof PbxTrunkTemplateCollectionResponse
     */
    'value'?: Array<PbxTrunkTemplate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTrunkType = {
    Voxtelesys: 'Voxtelesys'
} as const;

export type PbxTrunkType = typeof PbxTrunkType[keyof typeof PbxTrunkType];


/**
 * 
 * @export
 * @interface PbxTrunkVariable
 */
export interface PbxTrunkVariable {
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'DefaultValue'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkVariable
     */
    'MaxLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkVariable
     */
    'MinLength'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Option'?: string | null;
    /**
     * 
     * @type {PbxTrunkVariableType}
     * @memberof PbxTrunkVariable
     */
    'OptionType'?: PbxTrunkVariableType | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Pattern'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Prompt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxTrunkVariable
     */
    'Required'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxTrunkVariable
     */
    'Validation'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxTrunkVariableCollectionResponse
 */
export interface PbxTrunkVariableCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxTrunkVariableCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxTrunkVariable>}
     * @memberof PbxTrunkVariableCollectionResponse
     */
    'value'?: Array<PbxTrunkVariable>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTrunkVariableType = {
    Text: 'Text',
    Password: 'Password'
} as const;

export type PbxTrunkVariableType = typeof PbxTrunkVariableType[keyof typeof PbxTrunkVariableType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfAutoPickupForward = {
    TransferBack: 'TransferBack',
    Dn: 'DN',
    ExtensionVoiceMail: 'ExtensionVoiceMail',
    ExternalNumber: 'ExternalNumber',
    RoutePoint: 'RoutePoint'
} as const;

export type PbxTypeOfAutoPickupForward = typeof PbxTypeOfAutoPickupForward[keyof typeof PbxTypeOfAutoPickupForward];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfCDRLog = {
    SingleFileForAllCalls: 'SingleFileForAllCalls',
    SingleFileForEachCall: 'SingleFileForEachCall',
    PassiveSocket: 'PassiveSocket',
    ActiveSocket: 'ActiveSocket'
} as const;

export type PbxTypeOfCDRLog = typeof PbxTypeOfCDRLog[keyof typeof PbxTypeOfCDRLog];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfChatOwnershipType = {
    TakeManually: 'TakeManually',
    AutoAssign: 'AutoAssign'
} as const;

export type PbxTypeOfChatOwnershipType = typeof PbxTypeOfChatOwnershipType[keyof typeof PbxTypeOfChatOwnershipType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfIPDestriction = {
    Any: 'Any',
    Ipv4: 'IPV4',
    Ipv6: 'IPV6'
} as const;

export type PbxTypeOfIPDestriction = typeof PbxTypeOfIPDestriction[keyof typeof PbxTypeOfIPDestriction];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfPhoneBookAddQueueName = {
    NotAdd: 'NotAdd',
    Append: 'Append',
    Prepend: 'Prepend'
} as const;

export type PbxTypeOfPhoneBookAddQueueName = typeof PbxTypeOfPhoneBookAddQueueName[keyof typeof PbxTypeOfPhoneBookAddQueueName];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfPhoneBookDisplay = {
    FirstNameLastName: 'FirstNameLastName',
    LastNameFirstName: 'LastNameFirstName'
} as const;

export type PbxTypeOfPhoneBookDisplay = typeof PbxTypeOfPhoneBookDisplay[keyof typeof PbxTypeOfPhoneBookDisplay];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfPhoneBookResolving = {
    NotResolve: 'NotResolve',
    MatchExact: 'MatchExact',
    MatchLength: 'MatchLength'
} as const;

export type PbxTypeOfPhoneBookResolving = typeof PbxTypeOfPhoneBookResolving[keyof typeof PbxTypeOfPhoneBookResolving];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfTransportRestriction = {
    Any: 'Any',
    Udp: 'UDP',
    Tcp: 'TCP',
    Tls: 'TLS'
} as const;

export type PbxTypeOfTransportRestriction = typeof PbxTypeOfTransportRestriction[keyof typeof PbxTypeOfTransportRestriction];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxTypeOfUser = {
    Users: 'Users',
    SharedMailboxes: 'SharedMailboxes',
    LicensedUsers: 'LicensedUsers'
} as const;

export type PbxTypeOfUser = typeof PbxTypeOfUser[keyof typeof PbxTypeOfUser];


/**
 * 
 * @export
 * @interface PbxUpdateItem
 */
export interface PbxUpdateItem {
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'Category'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'Description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'DescriptionLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'Guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUpdateItem
     */
    'Ignore'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'LocalVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUpdateItem
     */
    'OutOfDate'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateItem
     */
    'ServerVersion'?: string;
    /**
     * 
     * @type {PbxUpdateType}
     * @memberof PbxUpdateItem
     */
    'UpdateType'?: PbxUpdateType | null;
}


/**
 * 
 * @export
 * @interface PbxUpdateItemCollectionResponse
 */
export interface PbxUpdateItemCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxUpdateItemCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxUpdateItem>}
     * @memberof PbxUpdateItemCollectionResponse
     */
    'value'?: Array<PbxUpdateItem>;
}
/**
 * 
 * @export
 * @interface PbxUpdateList
 */
export interface PbxUpdateList {
    /**
     * 
     * @type {Array<PbxUpdateItem>}
     * @memberof PbxUpdateList
     */
    'Entries'?: Array<PbxUpdateItem>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUpdateList
     */
    'IsMaintananceExpired'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateList
     */
    'Key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUpdateList
     */
    'LastSuccessfulUpdate'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxUpdateSettings
 */
export interface PbxUpdateSettings {
    /**
     * 
     * @type {boolean}
     * @memberof PbxUpdateSettings
     */
    'AutoUpdateEnabled'?: boolean | null;
    /**
     * 
     * @type {PbxBackupSchedule}
     * @memberof PbxUpdateSettings
     */
    'Schedule'?: PbxBackupSchedule | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxUpdateType = {
    Release: 'Release',
    Beta: 'Beta',
    MajorRelease: 'MajorRelease',
    Alpha: 'Alpha',
    Hotfix: 'Hotfix'
} as const;

export type PbxUpdateType = typeof PbxUpdateType[keyof typeof PbxUpdateType];


/**
 * 
 * @export
 * @interface PbxUpdatesStats
 */
export interface PbxUpdatesStats {
    /**
     * 
     * @type {Array<PbxCategoryUpdate>}
     * @memberof PbxUpdatesStats
     */
    'PerPage'?: Array<PbxCategoryUpdate>;
    /**
     * 
     * @type {Array<PbxCategoryUpdate>}
     * @memberof PbxUpdatesStats
     */
    'TcxUpdate'?: Array<PbxCategoryUpdate>;
}
/**
 * 
 * @export
 * @interface PbxUser
 */
export interface PbxUser {
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'AccessPassword'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'AllowLanOnly'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'AllowOwnRecordings'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'AuthID'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'AuthPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'Blfs'?: string | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxUser
     */
    'BreakTime'?: PbxSchedule | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'CallScreening'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'CallUsEnableChat'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'CallUsEnablePhone'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'CallUsEnableVideo'?: boolean | null;
    /**
     * 
     * @type {PbxAuthentication}
     * @memberof PbxUser
     */
    'CallUsRequirement'?: PbxAuthentication | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'ClickToCallId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'ContactImage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'CurrentProfileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'DeskphonePassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'DisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'EmailAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'EmergencyAdditionalInfo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'EmergencyLocationId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'Enable2FA'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'Enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'EnableHotdesking'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'FirstName'?: string | null;
    /**
     * 
     * @type {Array<PbxExtensionRule>}
     * @memberof PbxUser
     */
    'ForwardingExceptions'?: Array<PbxExtensionRule>;
    /**
     * 
     * @type {Array<PbxForwardingProfile>}
     * @memberof PbxUser
     */
    'ForwardingProfiles'?: Array<PbxForwardingProfile>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'GoogleSignInEnabled'?: boolean | null;
    /**
     * 
     * @type {Array<PbxGreeting>}
     * @memberof PbxUser
     */
    'Greetings'?: Array<PbxGreeting>;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxUser
     */
    'Groups'?: Array<PbxUserGroup>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'HideInPhonebook'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'HotdeskingAssignment'?: string | null;
    /**
     * 
     * @type {PbxSchedule}
     * @memberof PbxUser
     */
    'Hours'?: PbxSchedule | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUser
     */
    'Id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'Internal'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'IsRegistered'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'Language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'LastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'Mobile'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MS365CalendarEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MS365ContactsEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MS365SignInEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MS365TeamsEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MyPhoneAllowDeleteRecordings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MyPhoneHideForwardings'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MyPhonePush'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'MyPhoneShowRecordings'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'Number'?: string | null;
    /**
     * 
     * @type {Array<PbxOfficeHoursBits>}
     * @memberof PbxUser
     */
    'OfficeHoursProps'?: Array<PbxOfficeHoursBits>;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'OutboundCallerID'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'PbxDeliversAudio'?: boolean | null;
    /**
     * 
     * @type {Array<PbxPhone>}
     * @memberof PbxUser
     */
    'Phones'?: Array<PbxPhone>;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'PinProtected'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUser
     */
    'PinProtectTimeout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUser
     */
    'PrimaryGroupId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'PromptSet'?: string | null;
    /**
     * 
     * @type {PbxQueueStatusType}
     * @memberof PbxUser
     */
    'QueueStatus'?: PbxQueueStatusType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'RecordCalls'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'RecordExternalCallsOnly'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'Require2FA'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'SendEmailMissedCalls'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'SIPID'?: string | null;
    /**
     * 
     * @type {PbxSRTPModeType}
     * @memberof PbxUser
     */
    'SRTPMode'?: PbxSRTPModeType | null;
    /**
     * 
     * @type {Array<PbxUserTag>}
     * @memberof PbxUser
     */
    'Tags'?: Array<PbxUserTag>;
    /**
     * 
     * @type {PbxTranscriptionType}
     * @memberof PbxUser
     */
    'TranscriptionMode'?: PbxTranscriptionType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'VMDisablePinAuth'?: boolean | null;
    /**
     * 
     * @type {PbxVMEmailOptionsType}
     * @memberof PbxUser
     */
    'VMEmailOptions'?: PbxVMEmailOptionsType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'VMEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'VMPIN'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'VMPlayCallerID'?: boolean | null;
    /**
     * 
     * @type {PbxVMPlayMsgDateTimeType}
     * @memberof PbxUser
     */
    'VMPlayMsgDateTime'?: PbxVMPlayMsgDateTimeType | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxUser
     */
    'WebMeetingApproveParticipants'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUser
     */
    'WebMeetingFriendlyName'?: string | null;
}


/**
 * 
 * @export
 * @interface PbxUserCollectionResponse
 */
export interface PbxUserCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxUserCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxUser>}
     * @memberof PbxUserCollectionResponse
     */
    'value'?: Array<PbxUser>;
}
/**
 * 
 * @export
 * @interface PbxUserDeleteError
 */
export interface PbxUserDeleteError {
    /**
     * 
     * @type {string}
     * @memberof PbxUserDeleteError
     */
    'Error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUserDeleteError
     */
    'ExtensionNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxUserGroup
 */
export interface PbxUserGroup {
    /**
     * 
     * @type {boolean}
     * @memberof PbxUserGroup
     */
    'CanDelete'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUserGroup
     */
    'GroupId'?: number | null;
    /**
     * 
     * @type {PbxRights}
     * @memberof PbxUserGroup
     */
    'GroupRights'?: PbxRights | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUserGroup
     */
    'Id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUserGroup
     */
    'MemberName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUserGroup
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxUserGroup
     */
    'Number'?: string | null;
    /**
     * 
     * @type {PbxRights}
     * @memberof PbxUserGroup
     */
    'Rights'?: PbxRights | null;
    /**
     * 
     * @type {Array<PbxUserTag>}
     * @memberof PbxUserGroup
     */
    'Tags'?: Array<PbxUserTag>;
    /**
     * 
     * @type {PbxPeerType}
     * @memberof PbxUserGroup
     */
    'Type'?: PbxPeerType | null;
}


/**
 * 
 * @export
 * @interface PbxUserGroupCollectionResponse
 */
export interface PbxUserGroupCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxUserGroupCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxUserGroup>}
     * @memberof PbxUserGroupCollectionResponse
     */
    'value'?: Array<PbxUserGroup>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxUserTag = {
    Ms: 'MS',
    Teams: 'Teams',
    Google: 'Google',
    WakeUp: 'WakeUp',
    FaxServer: 'FaxServer',
    Principal: 'Principal'
} as const;

export type PbxUserTag = typeof PbxUserTag[keyof typeof PbxUserTag];


/**
 * 
 * @export
 * @interface PbxUsersRequestOptions
 */
export interface PbxUsersRequestOptions {
    /**
     * 
     * @type {number}
     * @memberof PbxUsersRequestOptions
     */
    'Count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PbxUsersRequestOptions
     */
    'Search'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxUsersRequestOptions
     */
    'Start'?: number;
    /**
     * 
     * @type {PbxTypeOfUser}
     * @memberof PbxUsersRequestOptions
     */
    'TypeOfUser'?: PbxTypeOfUser;
}


/**
 * 
 * @export
 * @interface PbxUsersSyncConfiguration
 */
export interface PbxUsersSyncConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PbxUsersSyncConfiguration
     */
    'IsEnabled'?: boolean | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxUsersSyncConfiguration
     */
    'SelectedUsers'?: Array<string | null>;
    /**
     * 
     * @type {PbxIntegrationSyncType}
     * @memberof PbxUsersSyncConfiguration
     */
    'SyncType'?: PbxIntegrationSyncType | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxVMEmailOptionsType = {
    None: 'None',
    Notification: 'Notification',
    Attachment: 'Attachment',
    AttachmentAndDelete: 'AttachmentAndDelete'
} as const;

export type PbxVMEmailOptionsType = typeof PbxVMEmailOptionsType[keyof typeof PbxVMEmailOptionsType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxVMPlayMsgDateTimeType = {
    None: 'None',
    Play12Hr: 'Play12Hr',
    Play24Hr: 'Play24Hr'
} as const;

export type PbxVMPlayMsgDateTimeType = typeof PbxVMPlayMsgDateTimeType[keyof typeof PbxVMPlayMsgDateTimeType];


/**
 * 
 * @export
 * @interface PbxVariable
 */
export interface PbxVariable {
    /**
     * 
     * @type {string}
     * @memberof PbxVariable
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxVariable
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface PbxVariableCollectionResponse
 */
export interface PbxVariableCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxVariableCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxVariable>}
     * @memberof PbxVariableCollectionResponse
     */
    'value'?: Array<PbxVariable>;
}
/**
 * 
 * @export
 * @interface PbxVersionUpdateType
 */
export interface PbxVersionUpdateType {
    /**
     * 
     * @type {PbxUpdateType}
     * @memberof PbxVersionUpdateType
     */
    'Type'?: PbxUpdateType | null;
}


/**
 * 
 * @export
 * @interface PbxVoicemailSettings
 */
export interface PbxVoicemailSettings {
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'AutoDeleteDays'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxVoicemailSettings
     */
    'AutoDeleteEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxVoicemailSettings
     */
    'Extension'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'Id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'MinDuration'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'Quota'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxVoicemailSettings
     */
    'RemoteStorageEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxVoicemailSettings
     */
    'SendEmailQuotaEnabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'SendEmailQuotaPercentage'?: number | null;
    /**
     * 
     * @type {PbxTranscribeEngine}
     * @memberof PbxVoicemailSettings
     */
    'TranscribeEngine'?: PbxTranscribeEngine | null;
    /**
     * 
     * @type {string}
     * @memberof PbxVoicemailSettings
     */
    'TranscribeLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxVoicemailSettings
     */
    'TranscribeRegion'?: string | null;
    /**
     * 
     * @type {PbxConcealedPassword}
     * @memberof PbxVoicemailSettings
     */
    'TranscribeSecretKey'?: PbxConcealedPassword | null;
    /**
     * 
     * @type {number}
     * @memberof PbxVoicemailSettings
     */
    'UsedSpace'?: number | null;
}


/**
 * 
 * @export
 * @interface PbxVoipProvider
 */
export interface PbxVoipProvider {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxVoipProvider
     */
    'Countries'?: Array<string | null>;
    /**
     * 
     * @type {string}
     * @memberof PbxVoipProvider
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PbxVoipProvider
     */
    'Name'?: string;
    /**
     * 
     * @type {PbxTemplateType}
     * @memberof PbxVoipProvider
     */
    'Type'?: PbxTemplateType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PbxWarnings = {
    ContactsSpecifyNameSurnameCompany: 'WARNINGS.CONTACTS_SPECIFY_NAME_SURNAME_COMPANY',
    ContactsSpecifyPhoneNumber: 'WARNINGS.CONTACTS_SPECIFY_PHONE_NUMBER',
    LengthNotMore50Chars: 'WARNINGS.LENGTH_NOT_MORE_50_CHARS',
    LengthNotMore255Chars: 'WARNINGS.LENGTH_NOT_MORE_255_CHARS',
    XapiLengthNotMore2048Chars: 'WARNINGS.XAPI.LENGTH_NOT_MORE_2048_CHARS',
    XapiInvalidHexCharacter: 'WARNINGS.XAPI.INVALID_HEX_CHARACTER',
    NoMoreNumbersAvailable: 'WARNINGS.NO_MORE_NUMBERS_AVAILABLE',
    ErpServerError: 'WARNINGS.ERP_SERVER_ERROR',
    LicenseNotFound: 'WARNINGS.LICENSE_NOT_FOUND',
    LimitReached: 'WARNINGS.LIMIT_REACHED',
    XapiInvalid: 'WARNINGS.XAPI.INVALID',
    XapiInvalidPinNumber: 'WARNINGS.XAPI.INVALID_PIN_NUMBER',
    XapiNotSupported: 'WARNINGS.XAPI.NOT_SUPPORTED',
    XapiUserRoleDowngrade: 'WARNINGS.XAPI.USER_ROLE_DOWNGRADE',
    GroupCannotBeDeleted: 'WARNINGS.GROUP_CANNOT_BE_DELETED',
    CannotBeDeleted: 'WARNINGS.CANNOT_BE_DELETED',
    GroupWithMembersCannotBeDeleted: 'WARNINGS.GROUP_WITH_MEMBERS_CANNOT_BE_DELETED',
    XapiOtherUserRoleDowngrade: 'WARNINGS.XAPI.OTHER_USER_ROLE_DOWNGRADE',
    XapiInvalidLicenseType: 'WARNINGS.XAPI.INVALID_LICENSE_TYPE',
    XapiInvalidPassword: 'WARNINGS.XAPI.INVALID_PASSWORD',
    XapiNotFound: 'WARNINGS.XAPI.NOT_FOUND',
    XapiFileNotFound: 'WARNINGS.XAPI.FILE_NOT_FOUND',
    XapiFileNotAccessible: 'WARNINGS.XAPI.FILE_NOT_ACCESSIBLE',
    XapiRequired: 'WARNINGS.XAPI.REQUIRED',
    XapiCanNotBeEmptyString: 'WARNINGS.XAPI.CAN_NOT_BE_EMPTY_STRING',
    XapiDuplicate: 'WARNINGS.XAPI.DUPLICATE',
    XapiAlreadyInUse: 'WARNINGS.XAPI.ALREADY_IN_USE',
    XapiPlaylistInUse: 'WARNINGS.XAPI.PLAYLIST_IN_USE',
    XapiOutOfTheRange: 'WARNINGS.XAPI.OUT_OF_THE_RANGE',
    XapiTooManyPhones: 'WARNINGS.XAPI.TOO_MANY_PHONES',
    XapiTooManySbc: 'WARNINGS.XAPI.TOO_MANY_SBC',
    XapiTooManyPrompts: 'WARNINGS.XAPI.TOO_MANY_PROMPTS',
    XapiOutboundRulesLimitReached: 'WARNINGS.XAPI.OUTBOUND_RULES_LIMIT_REACHED',
    XapiForbiddenChange: 'WARNINGS.XAPI.FORBIDDEN_CHANGE',
    FaxServerCannotBeDeleted: 'WARNINGS.FAX_SERVER_CANNOT_BE_DELETED',
    OperatorCannotBeDeleted: 'WARNINGS.OPERATOR_CANNOT_BE_DELETED',
    UserExtensionCannotBeDeleted: 'WARNINGS.USER_EXTENSION_CANNOT_BE_DELETED',
    XapiNumberIgnored: 'WARNINGS.XAPI.NUMBER_IGNORED',
    XapiInvalidTimezone: 'WARNINGS.XAPI.INVALID_TIMEZONE',
    XapiInvalidPath: 'WARNINGS.XAPI.INVALID_PATH',
    XapiPathShouldNotContainSpaces: 'WARNINGS.XAPI.PATH_SHOULD_NOT_CONTAIN_SPACES',
    XapiInvalidCredentials: 'WARNINGS.XAPI.INVALID_CREDENTIALS',
    XapiCannotConnectFtp: 'WARNINGS.XAPI.CANNOT_CONNECT_FTP',
    XapiCannotConnectSmb: 'WARNINGS.XAPI.CANNOT_CONNECT_SMB',
    XapiCannotConnectSftp: 'WARNINGS.XAPI.CANNOT_CONNECT_SFTP',
    XapiCannotConnectGoogleBucket: 'WARNINGS.XAPI.CANNOT_CONNECT_GOOGLE_BUCKET',
    XapiPlaylistNoSource: 'WARNINGS.XAPI.PLAYLIST_NO_SOURCE',
    XapiNoUsersInTeams: 'WARNINGS.XAPI.NO_USERS_IN_TEAMS',
    XapiFileFormatIsIncorrect: 'WARNINGS.XAPI.FILE_FORMAT_IS_INCORRECT',
    XapiInvalidFileName: 'WARNINGS.XAPI.INVALID_FILE_NAME',
    CsvInvalidFileFormat: 'WARNINGS.CSV_INVALID_FILE_FORMAT',
    CsvLineCorrupted: 'WARNINGS.CSV_LINE_CORRUPTED',
    WrongCsvFileRequiredColumnsNotFound: 'WARNINGS.WRONG_CSV_FILE_REQUIRED_COLUMNS_NOT_FOUND',
    CsvImportLimitReached: 'WARNINGS.CSV_IMPORT_LIMIT_REACHED',
    WrongCsvFileRequiredHeaderNotFound: 'WARNINGS.WRONG_CSV_FILE_REQUIRED_HEADER_NOT_FOUND',
    XapiFileIsTooLarge: 'WARNINGS.XAPI.FILE_IS_TOO_LARGE',
    XapiSbcCertFqdnMismatch: 'WARNINGS.XAPI.SBC_CERT_FQDN_MISMATCH',
    XapiSbcCertExpired: 'WARNINGS.XAPI.SBC_CERT_EXPIRED',
    XapiSbcKeyCertMismatch: 'WARNINGS.XAPI.SBC_KEY_CERT_MISMATCH',
    XapiNonExistentExtNumber: 'WARNINGS.XAPI.NON_EXISTENT_EXT_NUMBER',
    XapiMcmModeRequired: 'WARNINGS.XAPI.MCM_MODE_REQUIRED',
    InternationalprefixIsMissing: 'WARNINGS.INTERNATIONALPREFIX_IS_MISSING',
    TimezoneidIsMissing: 'WARNINGS.TIMEZONEID_IS_MISSING',
    XapiChatLogIsDisabled: 'WARNINGS.XAPI.CHAT_LOG_IS_DISABLED',
    WakeupIvrExists: 'WARNINGS.WAKEUP_IVR_EXISTS',
    RingGroupEnablePaging: 'WARNINGS.RING_GROUP_ENABLE_PAGING',
    XapiCreate1SipTruckEmergency: 'WARNINGS.XAPI.CREATE_1_SIP_TRUCK_EMERGENCY',
    DeletingAlreadyInProgress: 'WARNINGS.DELETING_ALREADY_IN_PROGRESS',
    InvalidIpMask: 'WARNINGS.INVALID_IP_MASK',
    TooManyBackups: 'WARNINGS.TOO_MANY_BACKUPS',
    BackupLocationConfigError: 'WARNINGS.BACKUP_LOCATION_CONFIG_ERROR',
    BackupNotFoundOrInvalid: 'WARNINGS.BACKUP_NOT_FOUND_OR_INVALID',
    InvalidCallFlowFile: 'WARNINGS.INVALID_CALL_FLOW_FILE',
    AlreadyExpired: 'WARNINGS.ALREADY_EXPIRED',
    CallFlowMustBeAlphanumeric: 'WARNINGS.CALL_FLOW_MUST_BE_ALPHANUMERIC',
    ExtractingOutsideTheDestinationDirectory: 'WARNINGS.EXTRACTING_OUTSIDE_THE_DESTINATION_DIRECTORY',
    InvalidExtensionNumberLength: 'WARNINGS.INVALID_EXTENSION_NUMBER_LENGTH',
    DnNumberCannotBeUsed: 'WARNINGS.DN_NUMBER_CANNOT_BE_USED',
    WiresharkNotFound: 'WARNINGS.WIRESHARK_NOT_FOUND',
    CaptureLocalhostNotAllowed: 'WARNINGS.CAPTURE_LOCALHOST_NOT_ALLOWED',
    CaptureOngoing: 'WARNINGS.CAPTURE_ONGOING',
    CannotDeleteTrunksBindedErmergencyNumber: 'WARNINGS.CANNOT_DELETE_TRUNKS_BINDED_ERMERGENCY_NUMBER',
    BlacklistNumberLimitExceeded: 'WARNINGS.BLACKLIST_NUMBER_LIMIT_EXCEEDED',
    DoubleQuotesNotAllowed: 'WARNINGS.DOUBLE_QUOTES_NOT_ALLOWED',
    McuRequestAlreadyInProgress: 'WARNINGS.MCU_REQUEST_ALREADY_IN_PROGRESS',
    McuLimitReached: 'WARNINGS.MCU_LIMIT_REACHED',
    McuWebmeetingBridgeNotFound: 'WARNINGS.MCU_WEBMEETING_BRIDGE_NOT_FOUND',
    McuRequestNotFound: 'WARNINGS.MCU_REQUEST_NOT_FOUND',
    McuRequestTimeout: 'WARNINGS.MCU_REQUEST_TIMEOUT',
    SupportedMediaFormatWav: 'WARNINGS.SUPPORTED_MEDIA_FORMAT_WAV',
    NoSecretDefined: 'WARNINGS.NO_SECRET_DEFINED',
    InvalidSecurityCode: 'WARNINGS.INVALID_SECURITY_CODE',
    UnableReachUpdatesServer: 'WARNINGS.UNABLE_REACH_UPDATES_SERVER',
    ErrorDownloadingFromUpdatesServer: 'WARNINGS.ERROR_DOWNLOADING_FROM_UPDATES_SERVER'
} as const;

export type PbxWarnings = typeof PbxWarnings[keyof typeof PbxWarnings];


/**
 * 
 * @export
 * @interface PbxWeblink
 */
export interface PbxWeblink {
    /**
     * 
     * @type {PbxLiveChatAdvancedSettings}
     * @memberof PbxWeblink
     */
    'Advanced'?: PbxLiveChatAdvancedSettings | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxWeblink
     */
    'CallsEnabled'?: boolean | null;
    /**
     * 
     * @type {PbxLiveChatBox}
     * @memberof PbxWeblink
     */
    'ChatBox'?: PbxLiveChatBox | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxWeblink
     */
    'ChatEnabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxWeblink
     */
    'DefaultRecord'?: boolean | null;
    /**
     * 
     * @type {PbxPeer}
     * @memberof PbxWeblink
     */
    'DN'?: PbxPeer | null;
    /**
     * 
     * @type {PbxGeneralLiveChatSettings}
     * @memberof PbxWeblink
     */
    'General'?: PbxGeneralLiveChatSettings | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWeblink
     */
    'Group'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PbxWeblink
     */
    'Hidden'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PbxWeblink
     */
    'Id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWeblink
     */
    'Link'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PbxWeblink
     */
    'MeetingEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWeblink
     */
    'Name'?: string | null;
    /**
     * 
     * @type {PbxLiveChatStyling}
     * @memberof PbxWeblink
     */
    'Styling'?: PbxLiveChatStyling | null;
    /**
     * 
     * @type {PbxWebsiteLinksTranslations}
     * @memberof PbxWeblink
     */
    'Translations'?: PbxWebsiteLinksTranslations | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxWeblink
     */
    'Website'?: Array<string | null>;
}
/**
 * 
 * @export
 * @interface PbxWeblinkCollectionResponse
 */
export interface PbxWeblinkCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof PbxWeblinkCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxWeblink>}
     * @memberof PbxWeblinkCollectionResponse
     */
    'value'?: Array<PbxWeblink>;
}
/**
 * 
 * @export
 * @interface PbxWebsiteLinksTranslations
 */
export interface PbxWebsiteLinksTranslations {
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'AuthenticationMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'EndingMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'FirstResponseMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'GdprMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'GreetingMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'GreetingOfflineMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'InviteMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineEmailMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineFinishMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineFormInvalidEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineFormInvalidName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineFormMaximumCharactersReached'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'OfflineNameMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'StartChatButtonText'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'UnavailableMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxWebsiteLinksTranslations
     */
    'WindowTitle'?: string | null;
}
/**
 * 
 * @export
 * @interface PbxXLicenseParams
 */
export interface PbxXLicenseParams {
    /**
     * 
     * @type {string}
     * @memberof PbxXLicenseParams
     */
    'CompanyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxXLicenseParams
     */
    'ContactName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxXLicenseParams
     */
    'Country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxXLicenseParams
     */
    'Email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PbxXLicenseParams
     */
    'Phone'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxXOperatingSystemType = {
    Other: 'Other',
    Linux: 'Linux',
    Windows: 'Windows'
} as const;

export type PbxXOperatingSystemType = typeof PbxXOperatingSystemType[keyof typeof PbxXOperatingSystemType];


/**
 * 
 * @export
 * @interface PbxXOutboundRulePurge
 */
export interface PbxXOutboundRulePurge {
    /**
     * 
     * @type {Array<number>}
     * @memberof PbxXOutboundRulePurge
     */
    'Ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PbxXServiceManageOptions
 */
export interface PbxXServiceManageOptions {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof PbxXServiceManageOptions
     */
    'ServiceNames'?: Array<string | null>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PbxXferTypeEnum = {
    BXfer: 'BXfer',
    AttXfer: 'AttXfer'
} as const;

export type PbxXferTypeEnum = typeof PbxXferTypeEnum[keyof typeof PbxXferTypeEnum];


/**
 * 
 * @export
 * @interface PlaylistsDeletePlaylistFileRequestBody
 */
export interface PlaylistsDeletePlaylistFileRequestBody {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsDeletePlaylistFileRequestBody
     */
    'playlistKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistsDeletePlaylistFileRequestBody
     */
    'fileName'?: string;
}
/**
 * 
 * @export
 * @interface PromptSetsPromptSetCopyRequestBody
 */
export interface PromptSetsPromptSetCopyRequestBody {
    /**
     * 
     * @type {PbxPromptSet}
     * @memberof PromptSetsPromptSetCopyRequestBody
     */
    'overrides'?: PbxPromptSet;
}
/**
 * 
 * @export
 * @interface PromptSetsPromptSetPlayPromptRequestBody
 */
export interface PromptSetsPromptSetPlayPromptRequestBody {
    /**
     * 
     * @type {string}
     * @memberof PromptSetsPromptSetPlayPromptRequestBody
     */
    'promptId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptSetsPromptSetPlayPromptRequestBody
     */
    'extension'?: string;
}
/**
 * 
 * @export
 * @interface PromptSetsPromptSetRecordPromptRequestBody
 */
export interface PromptSetsPromptSetRecordPromptRequestBody {
    /**
     * 
     * @type {string}
     * @memberof PromptSetsPromptSetRecordPromptRequestBody
     */
    'promptId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptSetsPromptSetRecordPromptRequestBody
     */
    'extension'?: string;
}
/**
 * 
 * @export
 * @interface PromptSetsPromptSetSetAlternatePronunciationRequestBody
 */
export interface PromptSetsPromptSetSetAlternatePronunciationRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof PromptSetsPromptSetSetAlternatePronunciationRequestBody
     */
    'alternatePronunciation'?: boolean;
}
/**
 * 
 * @export
 * @interface RecordingsBulkRecordingsArchiveRequestBody
 */
export interface RecordingsBulkRecordingsArchiveRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof RecordingsBulkRecordingsArchiveRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RecordingsBulkRecordingsDeleteRequestBody
 */
export interface RecordingsBulkRecordingsDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof RecordingsBulkRecordingsDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RecordingsSetRecordingRepositorySettingsRequestBody
 */
export interface RecordingsSetRecordingRepositorySettingsRequestBody {
    /**
     * 
     * @type {PbxRecordingRepositorySettings}
     * @memberof RecordingsSetRecordingRepositorySettingsRequestBody
     */
    'settings'?: PbxRecordingRepositorySettings;
}
/**
 * 
 * @export
 * @interface ReferenceCreate
 */
export interface ReferenceCreate {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ReferenceCreate
     */
    '@odata.id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReferenceNumeric = {
    NEGATIVE_INFINITY: '-INF',
    INFINITY: 'INF',
    NAN: 'NaN'
} as const;

export type ReferenceNumeric = typeof ReferenceNumeric[keyof typeof ReferenceNumeric];


/**
 * 
 * @export
 * @interface ReferenceUpdate
 */
export interface ReferenceUpdate {
    /**
     * 
     * @type {string}
     * @memberof ReferenceUpdate
     */
    '@odata.id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceUpdate
     */
    '@odata.type'?: string | null;
}
/**
 * 
 * @export
 * @interface RegenerateRequestBody
 */
export interface RegenerateRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'SipAuth'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'WebclientPassword'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'VoicemailPIN'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'DeskphonePassword'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'SendWelcomeEmail'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'ConfigurationLink'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegenerateRequestBody
     */
    'RpsKey'?: boolean;
}
/**
 * 
 * @export
 * @interface RegenerateWebCredentials200Response
 */
export interface RegenerateWebCredentials200Response {
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Brand'?: string | null;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof RegenerateWebCredentials200Response
     */
    'Codecs'?: Array<string | null>;
    /**
     * 
     * @type {number}
     * @memberof RegenerateWebCredentials200Response
     */
    'FxsLineCount'?: number | null;
    /**
     * 
     * @type {Array<PbxDeviceLine>}
     * @memberof RegenerateWebCredentials200Response
     */
    'FxsLines'?: Array<PbxDeviceLine>;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Group'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'MacAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'ModelName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Password'?: string | null;
    /**
     * 
     * @type {PbxFxsProvisioning}
     * @memberof RegenerateWebCredentials200Response
     */
    'Provisioning'?: PbxFxsProvisioning | null;
    /**
     * 
     * @type {PbxRegistrarFxs}
     * @memberof RegenerateWebCredentials200Response
     */
    'Registered'?: PbxRegistrarFxs | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'Secret'?: string | null;
    /**
     * 
     * @type {PbxFxsTemplate}
     * @memberof RegenerateWebCredentials200Response
     */
    'Template'?: PbxFxsTemplate | null;
    /**
     * 
     * @type {string}
     * @memberof RegenerateWebCredentials200Response
     */
    'TimeZone'?: string | null;
    /**
     * 
     * @type {Array<PbxVariable>}
     * @memberof RegenerateWebCredentials200Response
     */
    'Variables'?: Array<PbxVariable>;
}
/**
 * 
 * @export
 * @interface ReplaceMyGroupLicenseKeyRequestBody
 */
export interface ReplaceMyGroupLicenseKeyRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ReplaceMyGroupLicenseKeyRequestBody
     */
    'licenseKey'?: string;
}
/**
 * 
 * @export
 * @interface ServicesDisableRequestBody
 */
export interface ServicesDisableRequestBody {
    /**
     * 
     * @type {PbxXServiceManageOptions}
     * @memberof ServicesDisableRequestBody
     */
    'options'?: PbxXServiceManageOptions;
}
/**
 * 
 * @export
 * @interface ServicesEnableRequestBody
 */
export interface ServicesEnableRequestBody {
    /**
     * 
     * @type {PbxXServiceManageOptions}
     * @memberof ServicesEnableRequestBody
     */
    'options'?: PbxXServiceManageOptions;
}
/**
 * 
 * @export
 * @interface ServicesGarbageCollectRequestBody
 */
export interface ServicesGarbageCollectRequestBody {
    /**
     * 
     * @type {PbxGarbageCollect}
     * @memberof ServicesGarbageCollectRequestBody
     */
    'options'?: PbxGarbageCollect;
}
/**
 * 
 * @export
 * @interface ServicesRestartRequestBody
 */
export interface ServicesRestartRequestBody {
    /**
     * 
     * @type {PbxXServiceManageOptions}
     * @memberof ServicesRestartRequestBody
     */
    'options'?: PbxXServiceManageOptions;
}
/**
 * 
 * @export
 * @interface ServicesStartRequestBody
 */
export interface ServicesStartRequestBody {
    /**
     * 
     * @type {PbxXServiceManageOptions}
     * @memberof ServicesStartRequestBody
     */
    'options'?: PbxXServiceManageOptions;
}
/**
 * 
 * @export
 * @interface ServicesStopRequestBody
 */
export interface ServicesStopRequestBody {
    /**
     * 
     * @type {PbxXServiceManageOptions}
     * @memberof ServicesStopRequestBody
     */
    'options'?: PbxXServiceManageOptions;
}
/**
 * 
 * @export
 * @interface SetMonitorStatusRequestBody
 */
export interface SetMonitorStatusRequestBody {
    /**
     * 
     * @type {number}
     * @memberof SetMonitorStatusRequestBody
     */
    'days'?: number;
}
/**
 * 
 * @export
 * @interface SipDevicesSipDevicePushFirmwareRequestBody
 */
export interface SipDevicesSipDevicePushFirmwareRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SipDevicesSipDevicePushFirmwareRequestBody
     */
    'firmwareId'?: string;
}
/**
 * 
 * @export
 * @interface StringCollectionResponse
 */
export interface StringCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof StringCollectionResponse
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof StringCollectionResponse
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SystemExtensions200Response
 */
export interface SystemExtensions200Response {
    /**
     * 
     * @type {number}
     * @memberof SystemExtensions200Response
     */
    '@odata.count'?: number | null;
    /**
     * 
     * @type {Array<PbxSystemExtensionStatus>}
     * @memberof SystemExtensions200Response
     */
    'value'?: Array<PbxSystemExtensionStatus>;
}
/**
 * 
 * @export
 * @interface SystemStatusRequestHelpRequestBody
 */
export interface SystemStatusRequestHelpRequestBody {
    /**
     * 
     * @type {SystemStatusRequestHelpRequestBodyDescription}
     * @memberof SystemStatusRequestHelpRequestBody
     */
    'description'?: SystemStatusRequestHelpRequestBodyDescription;
}
/**
 * 
 * @export
 * @interface SystemStatusRequestHelpRequestBodyDescription
 */
export interface SystemStatusRequestHelpRequestBodyDescription {
    /**
     * 
     * @type {number}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'GrantPeriodDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'IssueDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'PhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'ReplyEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemStatusRequestHelpRequestBodyDescription
     */
    'SupportEmail'?: string | null;
}
/**
 * 
 * @export
 * @interface SystemStatusSetChatLogStatusRequestBody
 */
export interface SystemStatusSetChatLogStatusRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof SystemStatusSetChatLogStatusRequestBody
     */
    'enable'?: boolean;
}
/**
 * 
 * @export
 * @interface SystemStatusSetMultiCompanyModeRequestBody
 */
export interface SystemStatusSetMultiCompanyModeRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof SystemStatusSetMultiCompanyModeRequestBody
     */
    'enable'?: boolean;
}
/**
 * 
 * @export
 * @interface TrunksProvisionTrunkRequestBody
 */
export interface TrunksProvisionTrunkRequestBody {
    /**
     * 
     * @type {PbxCreateTrunk}
     * @memberof TrunksProvisionTrunkRequestBody
     */
    'model'?: PbxCreateTrunk;
}
/**
 * 
 * @export
 * @interface TrunksRefreshRegistrationRequestBody
 */
export interface TrunksRefreshRegistrationRequestBody {
    /**
     * 
     * @type {number}
     * @memberof TrunksRefreshRegistrationRequestBody
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface TrunksSetRoutesRequestBody
 */
export interface TrunksSetRoutesRequestBody {
    /**
     * 
     * @type {PbxSetRouteRequest}
     * @memberof TrunksSetRoutesRequestBody
     */
    'routes'?: PbxSetRouteRequest;
}
/**
 * 
 * @export
 * @interface Update200Response
 */
export interface Update200Response {
}
/**
 * 
 * @export
 * @interface UsersBatchDeleteRequestBody
 */
export interface UsersBatchDeleteRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersBatchDeleteRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UsersBulkUpdateRequestBody
 */
export interface UsersBulkUpdateRequestBody {
    /**
     * 
     * @type {PbxUser}
     * @memberof UsersBulkUpdateRequestBody
     */
    'user'?: PbxUser;
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersBulkUpdateRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UsersGetDuplicatedEmailsRequestBody
 */
export interface UsersGetDuplicatedEmailsRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersGetDuplicatedEmailsRequestBody
     */
    'emails'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UsersGetMultiEditGreetingsRequestBody
 */
export interface UsersGetMultiEditGreetingsRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersGetMultiEditGreetingsRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UsersGetPhoneRegistrarsRequestBody
 */
export interface UsersGetPhoneRegistrarsRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersGetPhoneRegistrarsRequestBody
     */
    'macs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UsersMakeCallRequestBody
 */
export interface UsersMakeCallRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersMakeCallRequestBody
     */
    'dn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersMakeCallRequestBody
     */
    'destination'?: string;
}
/**
 * 
 * @export
 * @interface UsersMultiDeleteGreetingRequestBody
 */
export interface UsersMultiDeleteGreetingRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersMultiDeleteGreetingRequestBody
     */
    'ids'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UsersMultiDeleteGreetingRequestBody
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface UsersMultiUserUpdateRequestBody
 */
export interface UsersMultiUserUpdateRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersMultiUserUpdateRequestBody
     */
    'ids'?: Array<number>;
    /**
     * 
     * @type {PbxMultiEditUserData}
     * @memberof UsersMultiUserUpdateRequestBody
     */
    'user'?: PbxMultiEditUserData;
}
/**
 * 
 * @export
 * @interface UsersRebootPhoneRequestBody
 */
export interface UsersRebootPhoneRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersRebootPhoneRequestBody
     */
    'mac'?: string;
}
/**
 * 
 * @export
 * @interface UsersRegeneratePasswordsRequestBody
 */
export interface UsersRegeneratePasswordsRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'SipAuth'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'WebclientPassword'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'VoicemailPIN'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'DeskphonePassword'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'SendWelcomeEmail'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'ConfigurationLink'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'RpsKey'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersRegeneratePasswordsRequestBody
     */
    'Ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UsersReprovisionAllPhonesRequestBody
 */
export interface UsersReprovisionAllPhonesRequestBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof UsersReprovisionAllPhonesRequestBody
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UsersReprovisionPhoneRequestBody
 */
export interface UsersReprovisionPhoneRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersReprovisionPhoneRequestBody
     */
    'mac'?: string;
}
/**
 * 
 * @export
 * @interface UsersUpgradePhoneRequestBody
 */
export interface UsersUpgradePhoneRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UsersUpgradePhoneRequestBody
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUpgradePhoneRequestBody
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUpgradePhoneRequestBody
     */
    'useragent'?: string;
}
/**
 * 
 * @export
 * @interface WebsiteLinksBulkLinksDeleteRequestBody
 */
export interface WebsiteLinksBulkLinksDeleteRequestBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebsiteLinksBulkLinksDeleteRequestBody
     */
    'ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WebsiteLinksValidateLinkRequestBody
 */
export interface WebsiteLinksValidateLinkRequestBody {
    /**
     * 
     * @type {PbxChatLinkNameValidation}
     * @memberof WebsiteLinksValidateLinkRequestBody
     */
    'model'?: PbxChatLinkNameValidation;
}

/**
 * ActiveCallsApi - axios parameter creator
 * @export
 */
export const ActiveCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action DropCall
         * @param {number} id The unique identifier of ActiveCall
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropCall: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dropCall', 'id', id)
            const localVarPath = `/ActiveCalls({Id})/Pbx.DropCall`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from ActiveCalls
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveCall: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ActiveCalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveCallsApi - functional programming interface
 * @export
 */
export const ActiveCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActiveCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action DropCall
         * @param {number} id The unique identifier of ActiveCall
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropCall(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropCall(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActiveCallsApi.dropCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from ActiveCalls
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveCall($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxActiveCallCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveCall($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActiveCallsApi.listActiveCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActiveCallsApi - factory interface
 * @export
 */
export const ActiveCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActiveCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action DropCall
         * @param {ActiveCallsApiDropCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropCall(requestParameters: ActiveCallsApiDropCallRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.dropCall(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from ActiveCalls
         * @param {ActiveCallsApiListActiveCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveCall(requestParameters: ActiveCallsApiListActiveCallRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxActiveCallCollectionResponse> {
            return localVarFp.listActiveCall(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dropCall operation in ActiveCallsApi.
 * @export
 * @interface ActiveCallsApiDropCallRequest
 */
export interface ActiveCallsApiDropCallRequest {
    /**
     * The unique identifier of ActiveCall
     * @type {number}
     * @memberof ActiveCallsApiDropCall
     */
    readonly id: number
}

/**
 * Request parameters for listActiveCall operation in ActiveCallsApi.
 * @export
 * @interface ActiveCallsApiListActiveCallRequest
 */
export interface ActiveCallsApiListActiveCallRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ActiveCallsApiListActiveCall
     */
    readonly $expand?: Set<string>
}

/**
 * ActiveCallsApi - object-oriented interface
 * @export
 * @class ActiveCallsApi
 * @extends {BaseAPI}
 */
export class ActiveCallsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action DropCall
     * @param {ActiveCallsApiDropCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveCallsApi
     */
    public dropCall(requestParameters: ActiveCallsApiDropCallRequest, options?: RawAxiosRequestConfig) {
        return ActiveCallsApiFp(this.configuration).dropCall(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from ActiveCalls
     * @param {ActiveCallsApiListActiveCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveCallsApi
     */
    public listActiveCall(requestParameters: ActiveCallsApiListActiveCallRequest = {}, options?: RawAxiosRequestConfig) {
        return ActiveCallsApiFp(this.configuration).listActiveCall(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivityLogApi - axios parameter creator
 * @export
 */
export const ActivityLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function GetFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ActivityLog/Pbx.GetFilter()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetLogs
         * @param {string} startDate Usage: startDate&#x3D;{startDate}
         * @param {string} endDate Usage: endDate&#x3D;{endDate}
         * @param {string | null} extension Usage: extension&#x3D;{extension}
         * @param {string | null} call Usage: call&#x3D;{call}
         * @param {string | null} search Usage: search&#x3D;{search}
         * @param {string | null} severity Usage: severity&#x3D;{severity}
         * @param {number} top Usage: top&#x3D;{top}
         * @param {number} skip Usage: skip&#x3D;{skip}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs: async (startDate: string, endDate: string, extension: string | null, call: string | null, search: string | null, severity: string | null, top: number, skip: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getLogs', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getLogs', 'endDate', endDate)
            // verify required parameter 'extension' is not null or undefined
            assertParamExists('getLogs', 'extension', extension)
            // verify required parameter 'call' is not null or undefined
            assertParamExists('getLogs', 'call', call)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('getLogs', 'search', search)
            // verify required parameter 'severity' is not null or undefined
            assertParamExists('getLogs', 'severity', severity)
            // verify required parameter 'top' is not null or undefined
            assertParamExists('getLogs', 'top', top)
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('getLogs', 'skip', skip)
            const localVarPath = `/ActivityLog/Pbx.GetLogs(startDate={startDate},endDate={endDate},extension={extension},call={call},search={search},severity={severity},top={top},skip={skip})`
                .replace(`{${"startDate"}}`, encodeURIComponent(String(startDate)))
                .replace(`{${"endDate"}}`, encodeURIComponent(String(endDate)))
                .replace(`{${"extension"}}`, encodeURIComponent(String(extension)))
                .replace(`{${"call"}}`, encodeURIComponent(String(call)))
                .replace(`{${"search"}}`, encodeURIComponent(String(search)))
                .replace(`{${"severity"}}`, encodeURIComponent(String(severity)))
                .replace(`{${"top"}}`, encodeURIComponent(String(top)))
                .replace(`{${"skip"}}`, encodeURIComponent(String(skip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PurgeLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeLogs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ActivityLog/Pbx.PurgeLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogApi - functional programming interface
 * @export
 */
export const ActivityLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxActivityLogsFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.getFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetLogs
         * @param {string} startDate Usage: startDate&#x3D;{startDate}
         * @param {string} endDate Usage: endDate&#x3D;{endDate}
         * @param {string | null} extension Usage: extension&#x3D;{extension}
         * @param {string | null} call Usage: call&#x3D;{call}
         * @param {string | null} search Usage: search&#x3D;{search}
         * @param {string | null} severity Usage: severity&#x3D;{severity}
         * @param {number} top Usage: top&#x3D;{top}
         * @param {number} skip Usage: skip&#x3D;{skip}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogs(startDate: string, endDate: string, extension: string | null, call: string | null, search: string | null, severity: string | null, top: number, skip: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfActivityLogEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogs(startDate, endDate, extension, call, search, severity, top, skip, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.getLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PurgeLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeLogs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeLogs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityLogApi.purgeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityLogApi - factory interface
 * @export
 */
export const ActivityLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetFilter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(options?: RawAxiosRequestConfig): AxiosPromise<PbxActivityLogsFilter> {
            return localVarFp.getFilter(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetLogs
         * @param {ActivityLogApiGetLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(requestParameters: ActivityLogApiGetLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfActivityLogEvent> {
            return localVarFp.getLogs(requestParameters.startDate, requestParameters.endDate, requestParameters.extension, requestParameters.call, requestParameters.search, requestParameters.severity, requestParameters.top, requestParameters.skip, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PurgeLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeLogs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeLogs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLogs operation in ActivityLogApi.
 * @export
 * @interface ActivityLogApiGetLogsRequest
 */
export interface ActivityLogApiGetLogsRequest {
    /**
     * Usage: startDate&#x3D;{startDate}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly startDate: string

    /**
     * Usage: endDate&#x3D;{endDate}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly endDate: string

    /**
     * Usage: extension&#x3D;{extension}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly extension: string | null

    /**
     * Usage: call&#x3D;{call}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly call: string | null

    /**
     * Usage: search&#x3D;{search}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly search: string | null

    /**
     * Usage: severity&#x3D;{severity}
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly severity: string | null

    /**
     * Usage: top&#x3D;{top}
     * @type {number}
     * @memberof ActivityLogApiGetLogs
     */
    readonly top: number

    /**
     * Usage: skip&#x3D;{skip}
     * @type {number}
     * @memberof ActivityLogApiGetLogs
     */
    readonly skip: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ActivityLogApiGetLogs
     */
    readonly $expand?: Set<string>
}

/**
 * ActivityLogApi - object-oriented interface
 * @export
 * @class ActivityLogApi
 * @extends {BaseAPI}
 */
export class ActivityLogApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function GetFilter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public getFilter(options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).getFilter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetLogs
     * @param {ActivityLogApiGetLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public getLogs(requestParameters: ActivityLogApiGetLogsRequest, options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).getLogs(requestParameters.startDate, requestParameters.endDate, requestParameters.extension, requestParameters.call, requestParameters.search, requestParameters.severity, requestParameters.top, requestParameters.skip, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PurgeLogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public purgeLogs(options?: RawAxiosRequestConfig) {
        return ActivityLogApiFp(this.configuration).purgeLogs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AntiHackingSettingsApi - axios parameter creator
 * @export
 */
export const AntiHackingSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get AntiHackingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAntiHackingSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/AntiHackingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update AntiHackingSettings
         * @param {PbxAntiHackingSettings} pbxAntiHackingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAntiHackingSettings: async (pbxAntiHackingSettings: PbxAntiHackingSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxAntiHackingSettings' is not null or undefined
            assertParamExists('updateAntiHackingSettings', 'pbxAntiHackingSettings', pbxAntiHackingSettings)
            const localVarPath = `/AntiHackingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxAntiHackingSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AntiHackingSettingsApi - functional programming interface
 * @export
 */
export const AntiHackingSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AntiHackingSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get AntiHackingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAntiHackingSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxAntiHackingSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAntiHackingSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AntiHackingSettingsApi.getAntiHackingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update AntiHackingSettings
         * @param {PbxAntiHackingSettings} pbxAntiHackingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAntiHackingSettings(pbxAntiHackingSettings: PbxAntiHackingSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAntiHackingSettings(pbxAntiHackingSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AntiHackingSettingsApi.updateAntiHackingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AntiHackingSettingsApi - factory interface
 * @export
 */
export const AntiHackingSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AntiHackingSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get AntiHackingSettings
         * @param {AntiHackingSettingsApiGetAntiHackingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAntiHackingSettings(requestParameters: AntiHackingSettingsApiGetAntiHackingSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxAntiHackingSettings> {
            return localVarFp.getAntiHackingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update AntiHackingSettings
         * @param {AntiHackingSettingsApiUpdateAntiHackingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAntiHackingSettings(requestParameters: AntiHackingSettingsApiUpdateAntiHackingSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAntiHackingSettings(requestParameters.pbxAntiHackingSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAntiHackingSettings operation in AntiHackingSettingsApi.
 * @export
 * @interface AntiHackingSettingsApiGetAntiHackingSettingsRequest
 */
export interface AntiHackingSettingsApiGetAntiHackingSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof AntiHackingSettingsApiGetAntiHackingSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof AntiHackingSettingsApiGetAntiHackingSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateAntiHackingSettings operation in AntiHackingSettingsApi.
 * @export
 * @interface AntiHackingSettingsApiUpdateAntiHackingSettingsRequest
 */
export interface AntiHackingSettingsApiUpdateAntiHackingSettingsRequest {
    /**
     * New property values
     * @type {PbxAntiHackingSettings}
     * @memberof AntiHackingSettingsApiUpdateAntiHackingSettings
     */
    readonly pbxAntiHackingSettings: PbxAntiHackingSettings
}

/**
 * AntiHackingSettingsApi - object-oriented interface
 * @export
 * @class AntiHackingSettingsApi
 * @extends {BaseAPI}
 */
export class AntiHackingSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get AntiHackingSettings
     * @param {AntiHackingSettingsApiGetAntiHackingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntiHackingSettingsApi
     */
    public getAntiHackingSettings(requestParameters: AntiHackingSettingsApiGetAntiHackingSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return AntiHackingSettingsApiFp(this.configuration).getAntiHackingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update AntiHackingSettings
     * @param {AntiHackingSettingsApiUpdateAntiHackingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntiHackingSettingsApi
     */
    public updateAntiHackingSettings(requestParameters: AntiHackingSettingsApiUpdateAntiHackingSettingsRequest, options?: RawAxiosRequestConfig) {
        return AntiHackingSettingsApiFp(this.configuration).updateAntiHackingSettings(requestParameters.pbxAntiHackingSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action Backup
         * @param {BackupsBackupRequestBody} backupsBackupRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup: async (backupsBackupRequestBody: BackupsBackupRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupsBackupRequestBody' is not null or undefined
            assertParamExists('backup', 'backupsBackupRequestBody', backupsBackupRequestBody)
            const localVarPath = `/Backups/Pbx.Backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsBackupRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Backups
         * @param {string} fileName The unique identifier of Backups
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackups: async (fileName: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteBackups', 'fileName', fileName)
            const localVarPath = `/Backups({FileName})`
                .replace(`{${"FileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetBackupExtras
         * @param {string} fileName The unique identifier of Backups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupExtras: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getBackupExtras', 'fileName', fileName)
            const localVarPath = `/Backups({FileName})/Pbx.GetBackupExtras()`
                .replace(`{${"FileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetBackupFailoverSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupFailoverSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetBackupFailoverSettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetBackupRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupRepositorySettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetBackupRepositorySettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetBackupSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetBackupSettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCanCreateBackup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCanCreateBackup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetCanCreateBackup()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFailoverScripts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailoverScripts: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetFailoverScripts()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRestoreSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestoreSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups/Pbx.GetRestoreSettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Backups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Backups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Restore
         * @param {string} fileName The unique identifier of Backups
         * @param {BackupsBackupsRestoreRequestBody} backupsBackupsRestoreRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore: async (fileName: string, backupsBackupsRestoreRequestBody: BackupsBackupsRestoreRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('restore', 'fileName', fileName)
            // verify required parameter 'backupsBackupsRestoreRequestBody' is not null or undefined
            assertParamExists('restore', 'backupsBackupsRestoreRequestBody', backupsBackupsRestoreRequestBody)
            const localVarPath = `/Backups({FileName})/Pbx.Restore`
                .replace(`{${"FileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsBackupsRestoreRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetBackupFailoverSettings
         * @param {BackupsSetBackupFailoverSettingsRequestBody} backupsSetBackupFailoverSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupFailoverSettings: async (backupsSetBackupFailoverSettingsRequestBody: BackupsSetBackupFailoverSettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupsSetBackupFailoverSettingsRequestBody' is not null or undefined
            assertParamExists('setBackupFailoverSettings', 'backupsSetBackupFailoverSettingsRequestBody', backupsSetBackupFailoverSettingsRequestBody)
            const localVarPath = `/Backups/Pbx.SetBackupFailoverSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsSetBackupFailoverSettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetBackupRepositorySettings
         * @param {BackupsSetBackupRepositorySettingsRequestBody} backupsSetBackupRepositorySettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupRepositorySettings: async (backupsSetBackupRepositorySettingsRequestBody: BackupsSetBackupRepositorySettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupsSetBackupRepositorySettingsRequestBody' is not null or undefined
            assertParamExists('setBackupRepositorySettings', 'backupsSetBackupRepositorySettingsRequestBody', backupsSetBackupRepositorySettingsRequestBody)
            const localVarPath = `/Backups/Pbx.SetBackupRepositorySettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsSetBackupRepositorySettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetBackupSettings
         * @param {BackupsSetBackupSettingsRequestBody} backupsSetBackupSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupSettings: async (backupsSetBackupSettingsRequestBody: BackupsSetBackupSettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupsSetBackupSettingsRequestBody' is not null or undefined
            assertParamExists('setBackupSettings', 'backupsSetBackupSettingsRequestBody', backupsSetBackupSettingsRequestBody)
            const localVarPath = `/Backups/Pbx.SetBackupSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsSetBackupSettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetRestoreSettings
         * @param {BackupsSetRestoreSettingsRequestBody} backupsSetRestoreSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRestoreSettings: async (backupsSetRestoreSettingsRequestBody: BackupsSetRestoreSettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupsSetRestoreSettingsRequestBody' is not null or undefined
            assertParamExists('setRestoreSettings', 'backupsSetRestoreSettingsRequestBody', backupsSetRestoreSettingsRequestBody)
            const localVarPath = `/Backups/Pbx.SetRestoreSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupsSetRestoreSettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action Backup
         * @param {BackupsBackupRequestBody} backupsBackupRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backup(backupsBackupRequestBody: BackupsBackupRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backup(backupsBackupRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.backup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Backups
         * @param {string} fileName The unique identifier of Backups
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackups(fileName: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackups(fileName, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.deleteBackups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetBackupExtras
         * @param {string} fileName The unique identifier of Backups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupExtras(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBackupExtras>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupExtras(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getBackupExtras']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetBackupFailoverSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupFailoverSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBackupFailoverSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupFailoverSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getBackupFailoverSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetBackupRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupRepositorySettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBackupRepositorySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupRepositorySettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getBackupRepositorySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetBackupSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBackupSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getBackupSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCanCreateBackup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCanCreateBackup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCanCreateBackup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getCanCreateBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFailoverScripts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFailoverScripts($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFailoverScripts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFailoverScripts($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getFailoverScripts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRestoreSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestoreSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRestoreSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestoreSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.getRestoreSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Backups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackups($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBackupsCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackups($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.listBackups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Restore
         * @param {string} fileName The unique identifier of Backups
         * @param {BackupsBackupsRestoreRequestBody} backupsBackupsRestoreRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restore(fileName: string, backupsBackupsRestoreRequestBody: BackupsBackupsRestoreRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restore(fileName, backupsBackupsRestoreRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.restore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetBackupFailoverSettings
         * @param {BackupsSetBackupFailoverSettingsRequestBody} backupsSetBackupFailoverSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBackupFailoverSettings(backupsSetBackupFailoverSettingsRequestBody: BackupsSetBackupFailoverSettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBackupFailoverSettings(backupsSetBackupFailoverSettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.setBackupFailoverSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetBackupRepositorySettings
         * @param {BackupsSetBackupRepositorySettingsRequestBody} backupsSetBackupRepositorySettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBackupRepositorySettings(backupsSetBackupRepositorySettingsRequestBody: BackupsSetBackupRepositorySettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBackupRepositorySettings(backupsSetBackupRepositorySettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.setBackupRepositorySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetBackupSettings
         * @param {BackupsSetBackupSettingsRequestBody} backupsSetBackupSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBackupSettings(backupsSetBackupSettingsRequestBody: BackupsSetBackupSettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBackupSettings(backupsSetBackupSettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.setBackupSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetRestoreSettings
         * @param {BackupsSetRestoreSettingsRequestBody} backupsSetRestoreSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRestoreSettings(backupsSetRestoreSettingsRequestBody: BackupsSetRestoreSettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRestoreSettings(backupsSetRestoreSettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.setRestoreSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action Backup
         * @param {BackupsApiBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(requestParameters: BackupsApiBackupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.backup(requestParameters.backupsBackupRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Backups
         * @param {BackupsApiDeleteBackupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackups(requestParameters: BackupsApiDeleteBackupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBackups(requestParameters.fileName, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetBackupExtras
         * @param {BackupsApiGetBackupExtrasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupExtras(requestParameters: BackupsApiGetBackupExtrasRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxBackupExtras> {
            return localVarFp.getBackupExtras(requestParameters.fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetBackupFailoverSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupFailoverSettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxBackupFailoverSettings> {
            return localVarFp.getBackupFailoverSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetBackupRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupRepositorySettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxBackupRepositorySettings> {
            return localVarFp.getBackupRepositorySettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetBackupSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupSettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxBackupSettings> {
            return localVarFp.getBackupSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCanCreateBackup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCanCreateBackup(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.getCanCreateBackup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFailoverScripts
         * @param {BackupsApiGetFailoverScriptsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailoverScripts(requestParameters: BackupsApiGetFailoverScriptsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetFailoverScripts200Response> {
            return localVarFp.getFailoverScripts(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRestoreSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestoreSettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxRestoreSettings> {
            return localVarFp.getRestoreSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Backups
         * @param {BackupsApiListBackupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups(requestParameters: BackupsApiListBackupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxBackupsCollectionResponse> {
            return localVarFp.listBackups(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Restore
         * @param {BackupsApiRestoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(requestParameters: BackupsApiRestoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restore(requestParameters.fileName, requestParameters.backupsBackupsRestoreRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetBackupFailoverSettings
         * @param {BackupsApiSetBackupFailoverSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupFailoverSettings(requestParameters: BackupsApiSetBackupFailoverSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setBackupFailoverSettings(requestParameters.backupsSetBackupFailoverSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetBackupRepositorySettings
         * @param {BackupsApiSetBackupRepositorySettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupRepositorySettings(requestParameters: BackupsApiSetBackupRepositorySettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setBackupRepositorySettings(requestParameters.backupsSetBackupRepositorySettingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetBackupSettings
         * @param {BackupsApiSetBackupSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupSettings(requestParameters: BackupsApiSetBackupSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setBackupSettings(requestParameters.backupsSetBackupSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetRestoreSettings
         * @param {BackupsApiSetRestoreSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRestoreSettings(requestParameters: BackupsApiSetRestoreSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setRestoreSettings(requestParameters.backupsSetRestoreSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for backup operation in BackupsApi.
 * @export
 * @interface BackupsApiBackupRequest
 */
export interface BackupsApiBackupRequest {
    /**
     * Action parameters
     * @type {BackupsBackupRequestBody}
     * @memberof BackupsApiBackup
     */
    readonly backupsBackupRequestBody: BackupsBackupRequestBody
}

/**
 * Request parameters for deleteBackups operation in BackupsApi.
 * @export
 * @interface BackupsApiDeleteBackupsRequest
 */
export interface BackupsApiDeleteBackupsRequest {
    /**
     * The unique identifier of Backups
     * @type {string}
     * @memberof BackupsApiDeleteBackups
     */
    readonly fileName: string

    /**
     * ETag
     * @type {string}
     * @memberof BackupsApiDeleteBackups
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getBackupExtras operation in BackupsApi.
 * @export
 * @interface BackupsApiGetBackupExtrasRequest
 */
export interface BackupsApiGetBackupExtrasRequest {
    /**
     * The unique identifier of Backups
     * @type {string}
     * @memberof BackupsApiGetBackupExtras
     */
    readonly fileName: string
}

/**
 * Request parameters for getFailoverScripts operation in BackupsApi.
 * @export
 * @interface BackupsApiGetFailoverScriptsRequest
 */
export interface BackupsApiGetFailoverScriptsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof BackupsApiGetFailoverScripts
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof BackupsApiGetFailoverScripts
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof BackupsApiGetFailoverScripts
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof BackupsApiGetFailoverScripts
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof BackupsApiGetFailoverScripts
     */
    readonly $count?: boolean
}

/**
 * Request parameters for listBackups operation in BackupsApi.
 * @export
 * @interface BackupsApiListBackupsRequest
 */
export interface BackupsApiListBackupsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof BackupsApiListBackups
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof BackupsApiListBackups
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof BackupsApiListBackups
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof BackupsApiListBackups
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof BackupsApiListBackups
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof BackupsApiListBackups
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof BackupsApiListBackups
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof BackupsApiListBackups
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for restore operation in BackupsApi.
 * @export
 * @interface BackupsApiRestoreRequest
 */
export interface BackupsApiRestoreRequest {
    /**
     * The unique identifier of Backups
     * @type {string}
     * @memberof BackupsApiRestore
     */
    readonly fileName: string

    /**
     * Action parameters
     * @type {BackupsBackupsRestoreRequestBody}
     * @memberof BackupsApiRestore
     */
    readonly backupsBackupsRestoreRequestBody: BackupsBackupsRestoreRequestBody
}

/**
 * Request parameters for setBackupFailoverSettings operation in BackupsApi.
 * @export
 * @interface BackupsApiSetBackupFailoverSettingsRequest
 */
export interface BackupsApiSetBackupFailoverSettingsRequest {
    /**
     * Action parameters
     * @type {BackupsSetBackupFailoverSettingsRequestBody}
     * @memberof BackupsApiSetBackupFailoverSettings
     */
    readonly backupsSetBackupFailoverSettingsRequestBody: BackupsSetBackupFailoverSettingsRequestBody
}

/**
 * Request parameters for setBackupRepositorySettings operation in BackupsApi.
 * @export
 * @interface BackupsApiSetBackupRepositorySettingsRequest
 */
export interface BackupsApiSetBackupRepositorySettingsRequest {
    /**
     * Action parameters
     * @type {BackupsSetBackupRepositorySettingsRequestBody}
     * @memberof BackupsApiSetBackupRepositorySettings
     */
    readonly backupsSetBackupRepositorySettingsRequestBody: BackupsSetBackupRepositorySettingsRequestBody
}

/**
 * Request parameters for setBackupSettings operation in BackupsApi.
 * @export
 * @interface BackupsApiSetBackupSettingsRequest
 */
export interface BackupsApiSetBackupSettingsRequest {
    /**
     * Action parameters
     * @type {BackupsSetBackupSettingsRequestBody}
     * @memberof BackupsApiSetBackupSettings
     */
    readonly backupsSetBackupSettingsRequestBody: BackupsSetBackupSettingsRequestBody
}

/**
 * Request parameters for setRestoreSettings operation in BackupsApi.
 * @export
 * @interface BackupsApiSetRestoreSettingsRequest
 */
export interface BackupsApiSetRestoreSettingsRequest {
    /**
     * Action parameters
     * @type {BackupsSetRestoreSettingsRequestBody}
     * @memberof BackupsApiSetRestoreSettings
     */
    readonly backupsSetRestoreSettingsRequestBody: BackupsSetRestoreSettingsRequestBody
}

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action Backup
     * @param {BackupsApiBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public backup(requestParameters: BackupsApiBackupRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).backup(requestParameters.backupsBackupRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Backups
     * @param {BackupsApiDeleteBackupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public deleteBackups(requestParameters: BackupsApiDeleteBackupsRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).deleteBackups(requestParameters.fileName, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetBackupExtras
     * @param {BackupsApiGetBackupExtrasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getBackupExtras(requestParameters: BackupsApiGetBackupExtrasRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getBackupExtras(requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetBackupFailoverSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getBackupFailoverSettings(options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getBackupFailoverSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetBackupRepositorySettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getBackupRepositorySettings(options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getBackupRepositorySettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetBackupSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getBackupSettings(options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getBackupSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCanCreateBackup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getCanCreateBackup(options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getCanCreateBackup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFailoverScripts
     * @param {BackupsApiGetFailoverScriptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getFailoverScripts(requestParameters: BackupsApiGetFailoverScriptsRequest = {}, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getFailoverScripts(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRestoreSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public getRestoreSettings(options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).getRestoreSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Backups
     * @param {BackupsApiListBackupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public listBackups(requestParameters: BackupsApiListBackupsRequest = {}, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).listBackups(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Restore
     * @param {BackupsApiRestoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public restore(requestParameters: BackupsApiRestoreRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).restore(requestParameters.fileName, requestParameters.backupsBackupsRestoreRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetBackupFailoverSettings
     * @param {BackupsApiSetBackupFailoverSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public setBackupFailoverSettings(requestParameters: BackupsApiSetBackupFailoverSettingsRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).setBackupFailoverSettings(requestParameters.backupsSetBackupFailoverSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetBackupRepositorySettings
     * @param {BackupsApiSetBackupRepositorySettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public setBackupRepositorySettings(requestParameters: BackupsApiSetBackupRepositorySettingsRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).setBackupRepositorySettings(requestParameters.backupsSetBackupRepositorySettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetBackupSettings
     * @param {BackupsApiSetBackupSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public setBackupSettings(requestParameters: BackupsApiSetBackupSettingsRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).setBackupSettings(requestParameters.backupsSetBackupSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetRestoreSettings
     * @param {BackupsApiSetRestoreSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public setRestoreSettings(requestParameters: BackupsApiSetRestoreSettingsRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).setRestoreSettings(requestParameters.backupsSetRestoreSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlackListNumbersApi - axios parameter creator
 * @export
 */
export const BlackListNumbersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BulkNumbersDelete
         * @param {BlackListNumbersBulkNumbersDeleteRequestBody} blackListNumbersBulkNumbersDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkNumbersDelete: async (blackListNumbersBulkNumbersDeleteRequestBody: BlackListNumbersBulkNumbersDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blackListNumbersBulkNumbersDeleteRequestBody' is not null or undefined
            assertParamExists('bulkNumbersDelete', 'blackListNumbersBulkNumbersDeleteRequestBody', blackListNumbersBulkNumbersDeleteRequestBody)
            const localVarPath = `/BlackListNumbers/Pbx.BulkNumbersDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blackListNumbersBulkNumbersDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to BlackListNumbers
         * @param {PbxBlackListNumber} pbxBlackListNumber New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlackListNumber: async (pbxBlackListNumber: PbxBlackListNumber, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxBlackListNumber' is not null or undefined
            assertParamExists('createBlackListNumber', 'pbxBlackListNumber', pbxBlackListNumber)
            const localVarPath = `/BlackListNumbers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxBlackListNumber, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from BlackListNumbers
         * @param {string} id The unique identifier of BlackListNumber
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlackListNumber: async (id: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlackListNumber', 'id', id)
            const localVarPath = `/BlackListNumbers({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from BlackListNumbers by key
         * @param {string} id The unique identifier of BlackListNumber
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlackListNumber: async (id: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlackListNumber', 'id', id)
            const localVarPath = `/BlackListNumbers({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from BlackListNumbers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlackListNumber: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/BlackListNumbers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in BlackListNumbers
         * @param {string} id The unique identifier of BlackListNumber
         * @param {PbxBlackListNumber} pbxBlackListNumber New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlackListNumber: async (id: string, pbxBlackListNumber: PbxBlackListNumber, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBlackListNumber', 'id', id)
            // verify required parameter 'pbxBlackListNumber' is not null or undefined
            assertParamExists('updateBlackListNumber', 'pbxBlackListNumber', pbxBlackListNumber)
            const localVarPath = `/BlackListNumbers({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxBlackListNumber, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlackListNumbersApi - functional programming interface
 * @export
 */
export const BlackListNumbersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlackListNumbersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkNumbersDelete
         * @param {BlackListNumbersBulkNumbersDeleteRequestBody} blackListNumbersBulkNumbersDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkNumbersDelete(blackListNumbersBulkNumbersDeleteRequestBody: BlackListNumbersBulkNumbersDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkNumbersDelete(blackListNumbersBulkNumbersDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.bulkNumbersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to BlackListNumbers
         * @param {PbxBlackListNumber} pbxBlackListNumber New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlackListNumber(pbxBlackListNumber: PbxBlackListNumber, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlackListNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlackListNumber(pbxBlackListNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.createBlackListNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from BlackListNumbers
         * @param {string} id The unique identifier of BlackListNumber
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlackListNumber(id: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlackListNumber(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.deleteBlackListNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from BlackListNumbers by key
         * @param {string} id The unique identifier of BlackListNumber
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlackListNumber(id: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlackListNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlackListNumber(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.getBlackListNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from BlackListNumbers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBlackListNumber($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlackListNumberCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBlackListNumber($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.listBlackListNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in BlackListNumbers
         * @param {string} id The unique identifier of BlackListNumber
         * @param {PbxBlackListNumber} pbxBlackListNumber New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlackListNumber(id: string, pbxBlackListNumber: PbxBlackListNumber, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlackListNumber(id, pbxBlackListNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlackListNumbersApi.updateBlackListNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlackListNumbersApi - factory interface
 * @export
 */
export const BlackListNumbersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlackListNumbersApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkNumbersDelete
         * @param {BlackListNumbersApiBulkNumbersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkNumbersDelete(requestParameters: BlackListNumbersApiBulkNumbersDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkNumbersDelete(requestParameters.blackListNumbersBulkNumbersDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to BlackListNumbers
         * @param {BlackListNumbersApiCreateBlackListNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlackListNumber(requestParameters: BlackListNumbersApiCreateBlackListNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlackListNumber> {
            return localVarFp.createBlackListNumber(requestParameters.pbxBlackListNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from BlackListNumbers
         * @param {BlackListNumbersApiDeleteBlackListNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlackListNumber(requestParameters: BlackListNumbersApiDeleteBlackListNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBlackListNumber(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from BlackListNumbers by key
         * @param {BlackListNumbersApiGetBlackListNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlackListNumber(requestParameters: BlackListNumbersApiGetBlackListNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlackListNumber> {
            return localVarFp.getBlackListNumber(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from BlackListNumbers
         * @param {BlackListNumbersApiListBlackListNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlackListNumber(requestParameters: BlackListNumbersApiListBlackListNumberRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlackListNumberCollectionResponse> {
            return localVarFp.listBlackListNumber(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in BlackListNumbers
         * @param {BlackListNumbersApiUpdateBlackListNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlackListNumber(requestParameters: BlackListNumbersApiUpdateBlackListNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateBlackListNumber(requestParameters.id, requestParameters.pbxBlackListNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkNumbersDelete operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiBulkNumbersDeleteRequest
 */
export interface BlackListNumbersApiBulkNumbersDeleteRequest {
    /**
     * Action parameters
     * @type {BlackListNumbersBulkNumbersDeleteRequestBody}
     * @memberof BlackListNumbersApiBulkNumbersDelete
     */
    readonly blackListNumbersBulkNumbersDeleteRequestBody: BlackListNumbersBulkNumbersDeleteRequestBody
}

/**
 * Request parameters for createBlackListNumber operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiCreateBlackListNumberRequest
 */
export interface BlackListNumbersApiCreateBlackListNumberRequest {
    /**
     * New entity
     * @type {PbxBlackListNumber}
     * @memberof BlackListNumbersApiCreateBlackListNumber
     */
    readonly pbxBlackListNumber: PbxBlackListNumber
}

/**
 * Request parameters for deleteBlackListNumber operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiDeleteBlackListNumberRequest
 */
export interface BlackListNumbersApiDeleteBlackListNumberRequest {
    /**
     * The unique identifier of BlackListNumber
     * @type {string}
     * @memberof BlackListNumbersApiDeleteBlackListNumber
     */
    readonly id: string

    /**
     * ETag
     * @type {string}
     * @memberof BlackListNumbersApiDeleteBlackListNumber
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getBlackListNumber operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiGetBlackListNumberRequest
 */
export interface BlackListNumbersApiGetBlackListNumberRequest {
    /**
     * The unique identifier of BlackListNumber
     * @type {string}
     * @memberof BlackListNumbersApiGetBlackListNumber
     */
    readonly id: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof BlackListNumbersApiGetBlackListNumber
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof BlackListNumbersApiGetBlackListNumber
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listBlackListNumber operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiListBlackListNumberRequest
 */
export interface BlackListNumbersApiListBlackListNumberRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof BlackListNumbersApiListBlackListNumber
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateBlackListNumber operation in BlackListNumbersApi.
 * @export
 * @interface BlackListNumbersApiUpdateBlackListNumberRequest
 */
export interface BlackListNumbersApiUpdateBlackListNumberRequest {
    /**
     * The unique identifier of BlackListNumber
     * @type {string}
     * @memberof BlackListNumbersApiUpdateBlackListNumber
     */
    readonly id: string

    /**
     * New property values
     * @type {PbxBlackListNumber}
     * @memberof BlackListNumbersApiUpdateBlackListNumber
     */
    readonly pbxBlackListNumber: PbxBlackListNumber
}

/**
 * BlackListNumbersApi - object-oriented interface
 * @export
 * @class BlackListNumbersApi
 * @extends {BaseAPI}
 */
export class BlackListNumbersApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BulkNumbersDelete
     * @param {BlackListNumbersApiBulkNumbersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public bulkNumbersDelete(requestParameters: BlackListNumbersApiBulkNumbersDeleteRequest, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).bulkNumbersDelete(requestParameters.blackListNumbersBulkNumbersDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to BlackListNumbers
     * @param {BlackListNumbersApiCreateBlackListNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public createBlackListNumber(requestParameters: BlackListNumbersApiCreateBlackListNumberRequest, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).createBlackListNumber(requestParameters.pbxBlackListNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from BlackListNumbers
     * @param {BlackListNumbersApiDeleteBlackListNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public deleteBlackListNumber(requestParameters: BlackListNumbersApiDeleteBlackListNumberRequest, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).deleteBlackListNumber(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from BlackListNumbers by key
     * @param {BlackListNumbersApiGetBlackListNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public getBlackListNumber(requestParameters: BlackListNumbersApiGetBlackListNumberRequest, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).getBlackListNumber(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from BlackListNumbers
     * @param {BlackListNumbersApiListBlackListNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public listBlackListNumber(requestParameters: BlackListNumbersApiListBlackListNumberRequest = {}, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).listBlackListNumber(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in BlackListNumbers
     * @param {BlackListNumbersApiUpdateBlackListNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlackListNumbersApi
     */
    public updateBlackListNumber(requestParameters: BlackListNumbersApiUpdateBlackListNumberRequest, options?: RawAxiosRequestConfig) {
        return BlackListNumbersApiFp(this.configuration).updateBlackListNumber(requestParameters.id, requestParameters.pbxBlackListNumber, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlocklistApi - axios parameter creator
 * @export
 */
export const BlocklistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BulkIpsDelete
         * @param {BlocklistBulkIpsDeleteRequestBody} blocklistBulkIpsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkIpsDelete: async (blocklistBulkIpsDeleteRequestBody: BlocklistBulkIpsDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blocklistBulkIpsDeleteRequestBody' is not null or undefined
            assertParamExists('bulkIpsDelete', 'blocklistBulkIpsDeleteRequestBody', blocklistBulkIpsDeleteRequestBody)
            const localVarPath = `/Blocklist/Pbx.BulkIpsDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blocklistBulkIpsDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to Blocklist
         * @param {PbxBlocklistAddr} pbxBlocklistAddr New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlocklistAddr: async (pbxBlocklistAddr: PbxBlocklistAddr, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxBlocklistAddr' is not null or undefined
            assertParamExists('createBlocklistAddr', 'pbxBlocklistAddr', pbxBlocklistAddr)
            const localVarPath = `/Blocklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxBlocklistAddr, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Blocklist
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlocklistAddr: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlocklistAddr', 'id', id)
            const localVarPath = `/Blocklist({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Blocklist by key
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocklistAddr: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlocklistAddr', 'id', id)
            const localVarPath = `/Blocklist({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Blocklist
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlocklistAddr: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Blocklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Blocklist
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {PbxBlocklistAddr} pbxBlocklistAddr New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlocklistAddr: async (id: number, pbxBlocklistAddr: PbxBlocklistAddr, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBlocklistAddr', 'id', id)
            // verify required parameter 'pbxBlocklistAddr' is not null or undefined
            assertParamExists('updateBlocklistAddr', 'pbxBlocklistAddr', pbxBlocklistAddr)
            const localVarPath = `/Blocklist({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxBlocklistAddr, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocklistApi - functional programming interface
 * @export
 */
export const BlocklistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocklistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkIpsDelete
         * @param {BlocklistBulkIpsDeleteRequestBody} blocklistBulkIpsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkIpsDelete(blocklistBulkIpsDeleteRequestBody: BlocklistBulkIpsDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkIpsDelete(blocklistBulkIpsDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.bulkIpsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to Blocklist
         * @param {PbxBlocklistAddr} pbxBlocklistAddr New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlocklistAddr(pbxBlocklistAddr: PbxBlocklistAddr, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlocklistAddr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlocklistAddr(pbxBlocklistAddr, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.createBlocklistAddr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Blocklist
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlocklistAddr(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlocklistAddr(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.deleteBlocklistAddr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Blocklist by key
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocklistAddr(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlocklistAddr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocklistAddr(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.getBlocklistAddr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Blocklist
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBlocklistAddr($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxBlocklistAddrCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBlocklistAddr($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.listBlocklistAddr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Blocklist
         * @param {number} id The unique identifier of BlocklistAddr
         * @param {PbxBlocklistAddr} pbxBlocklistAddr New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlocklistAddr(id: number, pbxBlocklistAddr: PbxBlocklistAddr, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlocklistAddr(id, pbxBlocklistAddr, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlocklistApi.updateBlocklistAddr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlocklistApi - factory interface
 * @export
 */
export const BlocklistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocklistApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkIpsDelete
         * @param {BlocklistApiBulkIpsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkIpsDelete(requestParameters: BlocklistApiBulkIpsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkIpsDelete(requestParameters.blocklistBulkIpsDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to Blocklist
         * @param {BlocklistApiCreateBlocklistAddrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlocklistAddr(requestParameters: BlocklistApiCreateBlocklistAddrRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlocklistAddr> {
            return localVarFp.createBlocklistAddr(requestParameters.pbxBlocklistAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Blocklist
         * @param {BlocklistApiDeleteBlocklistAddrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlocklistAddr(requestParameters: BlocklistApiDeleteBlocklistAddrRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBlocklistAddr(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Blocklist by key
         * @param {BlocklistApiGetBlocklistAddrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocklistAddr(requestParameters: BlocklistApiGetBlocklistAddrRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlocklistAddr> {
            return localVarFp.getBlocklistAddr(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Blocklist
         * @param {BlocklistApiListBlocklistAddrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBlocklistAddr(requestParameters: BlocklistApiListBlocklistAddrRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxBlocklistAddrCollectionResponse> {
            return localVarFp.listBlocklistAddr(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Blocklist
         * @param {BlocklistApiUpdateBlocklistAddrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlocklistAddr(requestParameters: BlocklistApiUpdateBlocklistAddrRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateBlocklistAddr(requestParameters.id, requestParameters.pbxBlocklistAddr, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkIpsDelete operation in BlocklistApi.
 * @export
 * @interface BlocklistApiBulkIpsDeleteRequest
 */
export interface BlocklistApiBulkIpsDeleteRequest {
    /**
     * Action parameters
     * @type {BlocklistBulkIpsDeleteRequestBody}
     * @memberof BlocklistApiBulkIpsDelete
     */
    readonly blocklistBulkIpsDeleteRequestBody: BlocklistBulkIpsDeleteRequestBody
}

/**
 * Request parameters for createBlocklistAddr operation in BlocklistApi.
 * @export
 * @interface BlocklistApiCreateBlocklistAddrRequest
 */
export interface BlocklistApiCreateBlocklistAddrRequest {
    /**
     * New entity
     * @type {PbxBlocklistAddr}
     * @memberof BlocklistApiCreateBlocklistAddr
     */
    readonly pbxBlocklistAddr: PbxBlocklistAddr
}

/**
 * Request parameters for deleteBlocklistAddr operation in BlocklistApi.
 * @export
 * @interface BlocklistApiDeleteBlocklistAddrRequest
 */
export interface BlocklistApiDeleteBlocklistAddrRequest {
    /**
     * The unique identifier of BlocklistAddr
     * @type {number}
     * @memberof BlocklistApiDeleteBlocklistAddr
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof BlocklistApiDeleteBlocklistAddr
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getBlocklistAddr operation in BlocklistApi.
 * @export
 * @interface BlocklistApiGetBlocklistAddrRequest
 */
export interface BlocklistApiGetBlocklistAddrRequest {
    /**
     * The unique identifier of BlocklistAddr
     * @type {number}
     * @memberof BlocklistApiGetBlocklistAddr
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof BlocklistApiGetBlocklistAddr
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof BlocklistApiGetBlocklistAddr
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listBlocklistAddr operation in BlocklistApi.
 * @export
 * @interface BlocklistApiListBlocklistAddrRequest
 */
export interface BlocklistApiListBlocklistAddrRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof BlocklistApiListBlocklistAddr
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateBlocklistAddr operation in BlocklistApi.
 * @export
 * @interface BlocklistApiUpdateBlocklistAddrRequest
 */
export interface BlocklistApiUpdateBlocklistAddrRequest {
    /**
     * The unique identifier of BlocklistAddr
     * @type {number}
     * @memberof BlocklistApiUpdateBlocklistAddr
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxBlocklistAddr}
     * @memberof BlocklistApiUpdateBlocklistAddr
     */
    readonly pbxBlocklistAddr: PbxBlocklistAddr
}

/**
 * BlocklistApi - object-oriented interface
 * @export
 * @class BlocklistApi
 * @extends {BaseAPI}
 */
export class BlocklistApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BulkIpsDelete
     * @param {BlocklistApiBulkIpsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public bulkIpsDelete(requestParameters: BlocklistApiBulkIpsDeleteRequest, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).bulkIpsDelete(requestParameters.blocklistBulkIpsDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to Blocklist
     * @param {BlocklistApiCreateBlocklistAddrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public createBlocklistAddr(requestParameters: BlocklistApiCreateBlocklistAddrRequest, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).createBlocklistAddr(requestParameters.pbxBlocklistAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Blocklist
     * @param {BlocklistApiDeleteBlocklistAddrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public deleteBlocklistAddr(requestParameters: BlocklistApiDeleteBlocklistAddrRequest, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).deleteBlocklistAddr(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Blocklist by key
     * @param {BlocklistApiGetBlocklistAddrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public getBlocklistAddr(requestParameters: BlocklistApiGetBlocklistAddrRequest, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).getBlocklistAddr(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Blocklist
     * @param {BlocklistApiListBlocklistAddrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public listBlocklistAddr(requestParameters: BlocklistApiListBlocklistAddrRequest = {}, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).listBlocklistAddr(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Blocklist
     * @param {BlocklistApiUpdateBlocklistAddrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocklistApi
     */
    public updateBlocklistAddr(requestParameters: BlocklistApiUpdateBlocklistAddrRequest, options?: RawAxiosRequestConfig) {
        return BlocklistApiFp(this.configuration).updateBlocklistAddr(requestParameters.id, requestParameters.pbxBlocklistAddr, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CDRSettingsApi - axios parameter creator
 * @export
 */
export const CDRSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get CDRSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDRSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CDRSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CDRSettings
         * @param {PbxCDRSettings} pbxCDRSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDRSettings: async (pbxCDRSettings: PbxCDRSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCDRSettings' is not null or undefined
            assertParamExists('updateCDRSettings', 'pbxCDRSettings', pbxCDRSettings)
            const localVarPath = `/CDRSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCDRSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CDRSettingsApi - functional programming interface
 * @export
 */
export const CDRSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CDRSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get CDRSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCDRSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCDRSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCDRSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDRSettingsApi.getCDRSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CDRSettings
         * @param {PbxCDRSettings} pbxCDRSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCDRSettings(pbxCDRSettings: PbxCDRSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCDRSettings(pbxCDRSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CDRSettingsApi.updateCDRSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CDRSettingsApi - factory interface
 * @export
 */
export const CDRSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CDRSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get CDRSettings
         * @param {CDRSettingsApiGetCDRSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDRSettings(requestParameters: CDRSettingsApiGetCDRSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCDRSettings> {
            return localVarFp.getCDRSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CDRSettings
         * @param {CDRSettingsApiUpdateCDRSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDRSettings(requestParameters: CDRSettingsApiUpdateCDRSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCDRSettings(requestParameters.pbxCDRSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCDRSettings operation in CDRSettingsApi.
 * @export
 * @interface CDRSettingsApiGetCDRSettingsRequest
 */
export interface CDRSettingsApiGetCDRSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CDRSettingsApiGetCDRSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CDRSettingsApiGetCDRSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCDRSettings operation in CDRSettingsApi.
 * @export
 * @interface CDRSettingsApiUpdateCDRSettingsRequest
 */
export interface CDRSettingsApiUpdateCDRSettingsRequest {
    /**
     * New property values
     * @type {PbxCDRSettings}
     * @memberof CDRSettingsApiUpdateCDRSettings
     */
    readonly pbxCDRSettings: PbxCDRSettings
}

/**
 * CDRSettingsApi - object-oriented interface
 * @export
 * @class CDRSettingsApi
 * @extends {BaseAPI}
 */
export class CDRSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get CDRSettings
     * @param {CDRSettingsApiGetCDRSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CDRSettingsApi
     */
    public getCDRSettings(requestParameters: CDRSettingsApiGetCDRSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return CDRSettingsApiFp(this.configuration).getCDRSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CDRSettings
     * @param {CDRSettingsApiUpdateCDRSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CDRSettingsApi
     */
    public updateCDRSettings(requestParameters: CDRSettingsApiUpdateCDRSettingsRequest, options?: RawAxiosRequestConfig) {
        return CDRSettingsApiFp(this.configuration).updateCDRSettings(requestParameters.pbxCDRSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallCostSettingsApi - axios parameter creator
 * @export
 */
export const CallCostSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function ExportCallCosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCallCosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallCostSettings/Pbx.ExportCallCosts()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from CallCostSettings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallCostSettings: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallCostSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UpdateCost
         * @param {CallCostSettingsUpdateCostRequestBody} callCostSettingsUpdateCostRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCost: async (callCostSettingsUpdateCostRequestBody: CallCostSettingsUpdateCostRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callCostSettingsUpdateCostRequestBody' is not null or undefined
            assertParamExists('updateCost', 'callCostSettingsUpdateCostRequestBody', callCostSettingsUpdateCostRequestBody)
            const localVarPath = `/CallCostSettings/Pbx.UpdateCost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callCostSettingsUpdateCostRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallCostSettingsApi - functional programming interface
 * @export
 */
export const CallCostSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallCostSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function ExportCallCosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportCallCosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportCallCosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallCostSettingsApi.exportCallCosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from CallCostSettings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCallCostSettings($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallCostSettingsCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCallCostSettings($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallCostSettingsApi.listCallCostSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UpdateCost
         * @param {CallCostSettingsUpdateCostRequestBody} callCostSettingsUpdateCostRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCost(callCostSettingsUpdateCostRequestBody: CallCostSettingsUpdateCostRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCost(callCostSettingsUpdateCostRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallCostSettingsApi.updateCost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallCostSettingsApi - factory interface
 * @export
 */
export const CallCostSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallCostSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function ExportCallCosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCallCosts(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.exportCallCosts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from CallCostSettings
         * @param {CallCostSettingsApiListCallCostSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallCostSettings(requestParameters: CallCostSettingsApiListCallCostSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallCostSettingsCollectionResponse> {
            return localVarFp.listCallCostSettings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UpdateCost
         * @param {CallCostSettingsApiUpdateCostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCost(requestParameters: CallCostSettingsApiUpdateCostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCost(requestParameters.callCostSettingsUpdateCostRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCallCostSettings operation in CallCostSettingsApi.
 * @export
 * @interface CallCostSettingsApiListCallCostSettingsRequest
 */
export interface CallCostSettingsApiListCallCostSettingsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallCostSettingsApiListCallCostSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCost operation in CallCostSettingsApi.
 * @export
 * @interface CallCostSettingsApiUpdateCostRequest
 */
export interface CallCostSettingsApiUpdateCostRequest {
    /**
     * Action parameters
     * @type {CallCostSettingsUpdateCostRequestBody}
     * @memberof CallCostSettingsApiUpdateCost
     */
    readonly callCostSettingsUpdateCostRequestBody: CallCostSettingsUpdateCostRequestBody
}

/**
 * CallCostSettingsApi - object-oriented interface
 * @export
 * @class CallCostSettingsApi
 * @extends {BaseAPI}
 */
export class CallCostSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function ExportCallCosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallCostSettingsApi
     */
    public exportCallCosts(options?: RawAxiosRequestConfig) {
        return CallCostSettingsApiFp(this.configuration).exportCallCosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from CallCostSettings
     * @param {CallCostSettingsApiListCallCostSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallCostSettingsApi
     */
    public listCallCostSettings(requestParameters: CallCostSettingsApiListCallCostSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return CallCostSettingsApiFp(this.configuration).listCallCostSettings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UpdateCost
     * @param {CallCostSettingsApiUpdateCostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallCostSettingsApi
     */
    public updateCost(requestParameters: CallCostSettingsApiUpdateCostRequest, options?: RawAxiosRequestConfig) {
        return CallCostSettingsApiFp(this.configuration).updateCost(requestParameters.callCostSettingsUpdateCostRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallFlowAppsApi - axios parameter creator
 * @export
 */
export const CallFlowAppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to CallFlowApps
         * @param {PbxCallFlowApp} pbxCallFlowApp New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCallFlowApp: async (pbxCallFlowApp: PbxCallFlowApp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCallFlowApp' is not null or undefined
            assertParamExists('createCallFlowApp', 'pbxCallFlowApp', pbxCallFlowApp)
            const localVarPath = `/CallFlowApps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCallFlowApp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeleteAudioFile
         * @param {number} id The unique identifier of CallFlowApp
         * @param {CallFlowAppsCallFlowAppDeleteAudioFileRequestBody} callFlowAppsCallFlowAppDeleteAudioFileRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudioFile: async (id: number, callFlowAppsCallFlowAppDeleteAudioFileRequestBody: CallFlowAppsCallFlowAppDeleteAudioFileRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAudioFile', 'id', id)
            // verify required parameter 'callFlowAppsCallFlowAppDeleteAudioFileRequestBody' is not null or undefined
            assertParamExists('deleteAudioFile', 'callFlowAppsCallFlowAppDeleteAudioFileRequestBody', callFlowAppsCallFlowAppDeleteAudioFileRequestBody)
            const localVarPath = `/CallFlowApps({Id})/Pbx.DeleteAudioFile`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callFlowAppsCallFlowAppDeleteAudioFileRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from CallFlowApps
         * @param {number} id The unique identifier of CallFlowApp
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCallFlowApp: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCallFlowApp', 'id', id)
            const localVarPath = `/CallFlowApps({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAudioFiles
         * @param {number} id The unique identifier of CallFlowApp
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioFiles: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAudioFiles', 'id', id)
            const localVarPath = `/CallFlowApps({Id})/Pbx.GetAudioFiles()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from CallFlowApps by key
         * @param {number} id The unique identifier of CallFlowApp
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallFlowApp: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCallFlowApp', 'id', id)
            const localVarPath = `/CallFlowApps({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from CallFlowApps
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallFlowApp: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallFlowApps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in CallFlowApps
         * @param {number} id The unique identifier of CallFlowApp
         * @param {PbxCallFlowApp} pbxCallFlowApp New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallFlowApp: async (id: number, pbxCallFlowApp: PbxCallFlowApp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCallFlowApp', 'id', id)
            // verify required parameter 'pbxCallFlowApp' is not null or undefined
            assertParamExists('updateCallFlowApp', 'pbxCallFlowApp', pbxCallFlowApp)
            const localVarPath = `/CallFlowApps({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCallFlowApp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallFlowAppsApi - functional programming interface
 * @export
 */
export const CallFlowAppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallFlowAppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to CallFlowApps
         * @param {PbxCallFlowApp} pbxCallFlowApp New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCallFlowApp(pbxCallFlowApp: PbxCallFlowApp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallFlowApp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCallFlowApp(pbxCallFlowApp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.createCallFlowApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeleteAudioFile
         * @param {number} id The unique identifier of CallFlowApp
         * @param {CallFlowAppsCallFlowAppDeleteAudioFileRequestBody} callFlowAppsCallFlowAppDeleteAudioFileRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAudioFile(id: number, callFlowAppsCallFlowAppDeleteAudioFileRequestBody: CallFlowAppsCallFlowAppDeleteAudioFileRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAudioFile(id, callFlowAppsCallFlowAppDeleteAudioFileRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.deleteAudioFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from CallFlowApps
         * @param {number} id The unique identifier of CallFlowApp
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCallFlowApp(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCallFlowApp(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.deleteCallFlowApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAudioFiles
         * @param {number} id The unique identifier of CallFlowApp
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioFiles(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudioFiles(id, $top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.getAudioFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from CallFlowApps by key
         * @param {number} id The unique identifier of CallFlowApp
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallFlowApp(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallFlowApp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallFlowApp(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.getCallFlowApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from CallFlowApps
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCallFlowApp($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallFlowAppCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCallFlowApp($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.listCallFlowApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in CallFlowApps
         * @param {number} id The unique identifier of CallFlowApp
         * @param {PbxCallFlowApp} pbxCallFlowApp New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCallFlowApp(id: number, pbxCallFlowApp: PbxCallFlowApp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCallFlowApp(id, pbxCallFlowApp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowAppsApi.updateCallFlowApp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallFlowAppsApi - factory interface
 * @export
 */
export const CallFlowAppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallFlowAppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to CallFlowApps
         * @param {CallFlowAppsApiCreateCallFlowAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCallFlowApp(requestParameters: CallFlowAppsApiCreateCallFlowAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallFlowApp> {
            return localVarFp.createCallFlowApp(requestParameters.pbxCallFlowApp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeleteAudioFile
         * @param {CallFlowAppsApiDeleteAudioFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudioFile(requestParameters: CallFlowAppsApiDeleteAudioFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAudioFile(requestParameters.id, requestParameters.callFlowAppsCallFlowAppDeleteAudioFileRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from CallFlowApps
         * @param {CallFlowAppsApiDeleteCallFlowAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCallFlowApp(requestParameters: CallFlowAppsApiDeleteCallFlowAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCallFlowApp(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAudioFiles
         * @param {CallFlowAppsApiGetAudioFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioFiles(requestParameters: CallFlowAppsApiGetAudioFilesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAudioFiles200Response> {
            return localVarFp.getAudioFiles(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from CallFlowApps by key
         * @param {CallFlowAppsApiGetCallFlowAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallFlowApp(requestParameters: CallFlowAppsApiGetCallFlowAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallFlowApp> {
            return localVarFp.getCallFlowApp(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from CallFlowApps
         * @param {CallFlowAppsApiListCallFlowAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallFlowApp(requestParameters: CallFlowAppsApiListCallFlowAppRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallFlowAppCollectionResponse> {
            return localVarFp.listCallFlowApp(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in CallFlowApps
         * @param {CallFlowAppsApiUpdateCallFlowAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallFlowApp(requestParameters: CallFlowAppsApiUpdateCallFlowAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCallFlowApp(requestParameters.id, requestParameters.pbxCallFlowApp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCallFlowApp operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiCreateCallFlowAppRequest
 */
export interface CallFlowAppsApiCreateCallFlowAppRequest {
    /**
     * New entity
     * @type {PbxCallFlowApp}
     * @memberof CallFlowAppsApiCreateCallFlowApp
     */
    readonly pbxCallFlowApp: PbxCallFlowApp
}

/**
 * Request parameters for deleteAudioFile operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiDeleteAudioFileRequest
 */
export interface CallFlowAppsApiDeleteAudioFileRequest {
    /**
     * The unique identifier of CallFlowApp
     * @type {number}
     * @memberof CallFlowAppsApiDeleteAudioFile
     */
    readonly id: number

    /**
     * Action parameters
     * @type {CallFlowAppsCallFlowAppDeleteAudioFileRequestBody}
     * @memberof CallFlowAppsApiDeleteAudioFile
     */
    readonly callFlowAppsCallFlowAppDeleteAudioFileRequestBody: CallFlowAppsCallFlowAppDeleteAudioFileRequestBody
}

/**
 * Request parameters for deleteCallFlowApp operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiDeleteCallFlowAppRequest
 */
export interface CallFlowAppsApiDeleteCallFlowAppRequest {
    /**
     * The unique identifier of CallFlowApp
     * @type {number}
     * @memberof CallFlowAppsApiDeleteCallFlowApp
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof CallFlowAppsApiDeleteCallFlowApp
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getAudioFiles operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiGetAudioFilesRequest
 */
export interface CallFlowAppsApiGetAudioFilesRequest {
    /**
     * The unique identifier of CallFlowApp
     * @type {number}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallFlowAppsApiGetAudioFiles
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getCallFlowApp operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiGetCallFlowAppRequest
 */
export interface CallFlowAppsApiGetCallFlowAppRequest {
    /**
     * The unique identifier of CallFlowApp
     * @type {number}
     * @memberof CallFlowAppsApiGetCallFlowApp
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallFlowAppsApiGetCallFlowApp
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallFlowAppsApiGetCallFlowApp
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listCallFlowApp operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiListCallFlowAppRequest
 */
export interface CallFlowAppsApiListCallFlowAppRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallFlowAppsApiListCallFlowApp
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCallFlowApp operation in CallFlowAppsApi.
 * @export
 * @interface CallFlowAppsApiUpdateCallFlowAppRequest
 */
export interface CallFlowAppsApiUpdateCallFlowAppRequest {
    /**
     * The unique identifier of CallFlowApp
     * @type {number}
     * @memberof CallFlowAppsApiUpdateCallFlowApp
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxCallFlowApp}
     * @memberof CallFlowAppsApiUpdateCallFlowApp
     */
    readonly pbxCallFlowApp: PbxCallFlowApp
}

/**
 * CallFlowAppsApi - object-oriented interface
 * @export
 * @class CallFlowAppsApi
 * @extends {BaseAPI}
 */
export class CallFlowAppsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to CallFlowApps
     * @param {CallFlowAppsApiCreateCallFlowAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public createCallFlowApp(requestParameters: CallFlowAppsApiCreateCallFlowAppRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).createCallFlowApp(requestParameters.pbxCallFlowApp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeleteAudioFile
     * @param {CallFlowAppsApiDeleteAudioFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public deleteAudioFile(requestParameters: CallFlowAppsApiDeleteAudioFileRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).deleteAudioFile(requestParameters.id, requestParameters.callFlowAppsCallFlowAppDeleteAudioFileRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from CallFlowApps
     * @param {CallFlowAppsApiDeleteCallFlowAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public deleteCallFlowApp(requestParameters: CallFlowAppsApiDeleteCallFlowAppRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).deleteCallFlowApp(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAudioFiles
     * @param {CallFlowAppsApiGetAudioFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public getAudioFiles(requestParameters: CallFlowAppsApiGetAudioFilesRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).getAudioFiles(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from CallFlowApps by key
     * @param {CallFlowAppsApiGetCallFlowAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public getCallFlowApp(requestParameters: CallFlowAppsApiGetCallFlowAppRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).getCallFlowApp(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from CallFlowApps
     * @param {CallFlowAppsApiListCallFlowAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public listCallFlowApp(requestParameters: CallFlowAppsApiListCallFlowAppRequest = {}, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).listCallFlowApp(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in CallFlowApps
     * @param {CallFlowAppsApiUpdateCallFlowAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowAppsApi
     */
    public updateCallFlowApp(requestParameters: CallFlowAppsApiUpdateCallFlowAppRequest, options?: RawAxiosRequestConfig) {
        return CallFlowAppsApiFp(this.configuration).updateCallFlowApp(requestParameters.id, requestParameters.pbxCallFlowApp, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallFlowScriptsApi - axios parameter creator
 * @export
 */
export const CallFlowScriptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from CallFlowScripts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallFlowScript: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallFlowScripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallFlowScriptsApi - functional programming interface
 * @export
 */
export const CallFlowScriptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallFlowScriptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from CallFlowScripts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCallFlowScript($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallFlowScriptCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCallFlowScript($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallFlowScriptsApi.listCallFlowScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallFlowScriptsApi - factory interface
 * @export
 */
export const CallFlowScriptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallFlowScriptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from CallFlowScripts
         * @param {CallFlowScriptsApiListCallFlowScriptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallFlowScript(requestParameters: CallFlowScriptsApiListCallFlowScriptRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallFlowScriptCollectionResponse> {
            return localVarFp.listCallFlowScript(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCallFlowScript operation in CallFlowScriptsApi.
 * @export
 * @interface CallFlowScriptsApiListCallFlowScriptRequest
 */
export interface CallFlowScriptsApiListCallFlowScriptRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallFlowScriptsApiListCallFlowScript
     */
    readonly $expand?: Set<string>
}

/**
 * CallFlowScriptsApi - object-oriented interface
 * @export
 * @class CallFlowScriptsApi
 * @extends {BaseAPI}
 */
export class CallFlowScriptsApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from CallFlowScripts
     * @param {CallFlowScriptsApiListCallFlowScriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallFlowScriptsApi
     */
    public listCallFlowScript(requestParameters: CallFlowScriptsApiListCallFlowScriptRequest = {}, options?: RawAxiosRequestConfig) {
        return CallFlowScriptsApiFp(this.configuration).listCallFlowScript(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallHistoryViewApi - axios parameter creator
 * @export
 */
export const CallHistoryViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadCallHistory
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallHistory: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallHistoryView/Pbx.DownloadCallHistory()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from CallHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallHistoryView: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallHistoryView`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallHistoryViewApi - functional programming interface
 * @export
 */
export const CallHistoryViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallHistoryViewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallHistory
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCallHistory($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCallHistoryView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCallHistory($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallHistoryViewApi.downloadCallHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from CallHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCallHistoryView($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallHistoryViewCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCallHistoryView($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallHistoryViewApi.listCallHistoryView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallHistoryViewApi - factory interface
 * @export
 */
export const CallHistoryViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallHistoryViewApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallHistory
         * @param {CallHistoryViewApiDownloadCallHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallHistory(requestParameters: CallHistoryViewApiDownloadCallHistoryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCallHistoryView> {
            return localVarFp.downloadCallHistory(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from CallHistoryView
         * @param {CallHistoryViewApiListCallHistoryViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCallHistoryView(requestParameters: CallHistoryViewApiListCallHistoryViewRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallHistoryViewCollectionResponse> {
            return localVarFp.listCallHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadCallHistory operation in CallHistoryViewApi.
 * @export
 * @interface CallHistoryViewApiDownloadCallHistoryRequest
 */
export interface CallHistoryViewApiDownloadCallHistoryRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallHistoryViewApiDownloadCallHistory
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listCallHistoryView operation in CallHistoryViewApi.
 * @export
 * @interface CallHistoryViewApiListCallHistoryViewRequest
 */
export interface CallHistoryViewApiListCallHistoryViewRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallHistoryViewApiListCallHistoryView
     */
    readonly $expand?: Set<string>
}

/**
 * CallHistoryViewApi - object-oriented interface
 * @export
 * @class CallHistoryViewApi
 * @extends {BaseAPI}
 */
export class CallHistoryViewApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadCallHistory
     * @param {CallHistoryViewApiDownloadCallHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallHistoryViewApi
     */
    public downloadCallHistory(requestParameters: CallHistoryViewApiDownloadCallHistoryRequest = {}, options?: RawAxiosRequestConfig) {
        return CallHistoryViewApiFp(this.configuration).downloadCallHistory(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from CallHistoryView
     * @param {CallHistoryViewApiListCallHistoryViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallHistoryViewApi
     */
    public listCallHistoryView(requestParameters: CallHistoryViewApiListCallHistoryViewRequest = {}, options?: RawAxiosRequestConfig) {
        return CallHistoryViewApiFp(this.configuration).listCallHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallParkingSettingsApi - axios parameter creator
 * @export
 */
export const CallParkingSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get CallParkingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallParkingSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallParkingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CallParkingSettings
         * @param {PbxCallParkingSettings} pbxCallParkingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallParkingSettings: async (pbxCallParkingSettings: PbxCallParkingSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCallParkingSettings' is not null or undefined
            assertParamExists('updateCallParkingSettings', 'pbxCallParkingSettings', pbxCallParkingSettings)
            const localVarPath = `/CallParkingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCallParkingSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallParkingSettingsApi - functional programming interface
 * @export
 */
export const CallParkingSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallParkingSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get CallParkingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallParkingSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallParkingSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallParkingSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallParkingSettingsApi.getCallParkingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CallParkingSettings
         * @param {PbxCallParkingSettings} pbxCallParkingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCallParkingSettings(pbxCallParkingSettings: PbxCallParkingSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCallParkingSettings(pbxCallParkingSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallParkingSettingsApi.updateCallParkingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallParkingSettingsApi - factory interface
 * @export
 */
export const CallParkingSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallParkingSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get CallParkingSettings
         * @param {CallParkingSettingsApiGetCallParkingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallParkingSettings(requestParameters: CallParkingSettingsApiGetCallParkingSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallParkingSettings> {
            return localVarFp.getCallParkingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CallParkingSettings
         * @param {CallParkingSettingsApiUpdateCallParkingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallParkingSettings(requestParameters: CallParkingSettingsApiUpdateCallParkingSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCallParkingSettings(requestParameters.pbxCallParkingSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCallParkingSettings operation in CallParkingSettingsApi.
 * @export
 * @interface CallParkingSettingsApiGetCallParkingSettingsRequest
 */
export interface CallParkingSettingsApiGetCallParkingSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallParkingSettingsApiGetCallParkingSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallParkingSettingsApiGetCallParkingSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCallParkingSettings operation in CallParkingSettingsApi.
 * @export
 * @interface CallParkingSettingsApiUpdateCallParkingSettingsRequest
 */
export interface CallParkingSettingsApiUpdateCallParkingSettingsRequest {
    /**
     * New property values
     * @type {PbxCallParkingSettings}
     * @memberof CallParkingSettingsApiUpdateCallParkingSettings
     */
    readonly pbxCallParkingSettings: PbxCallParkingSettings
}

/**
 * CallParkingSettingsApi - object-oriented interface
 * @export
 * @class CallParkingSettingsApi
 * @extends {BaseAPI}
 */
export class CallParkingSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get CallParkingSettings
     * @param {CallParkingSettingsApiGetCallParkingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallParkingSettingsApi
     */
    public getCallParkingSettings(requestParameters: CallParkingSettingsApiGetCallParkingSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return CallParkingSettingsApiFp(this.configuration).getCallParkingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CallParkingSettings
     * @param {CallParkingSettingsApiUpdateCallParkingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallParkingSettingsApi
     */
    public updateCallParkingSettings(requestParameters: CallParkingSettingsApiUpdateCallParkingSettingsRequest, options?: RawAxiosRequestConfig) {
        return CallParkingSettingsApiFp(this.configuration).updateCallParkingSettings(requestParameters.pbxCallParkingSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallTypesSettingsApi - axios parameter creator
 * @export
 */
export const CallTypesSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get CallTypesSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallTypesSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CallTypesSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CallTypesSettings
         * @param {PbxCallTypesSettings} pbxCallTypesSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallTypesSettings: async (pbxCallTypesSettings: PbxCallTypesSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCallTypesSettings' is not null or undefined
            assertParamExists('updateCallTypesSettings', 'pbxCallTypesSettings', pbxCallTypesSettings)
            const localVarPath = `/CallTypesSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCallTypesSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallTypesSettingsApi - functional programming interface
 * @export
 */
export const CallTypesSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallTypesSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get CallTypesSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallTypesSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCallTypesSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallTypesSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallTypesSettingsApi.getCallTypesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CallTypesSettings
         * @param {PbxCallTypesSettings} pbxCallTypesSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCallTypesSettings(pbxCallTypesSettings: PbxCallTypesSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCallTypesSettings(pbxCallTypesSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallTypesSettingsApi.updateCallTypesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallTypesSettingsApi - factory interface
 * @export
 */
export const CallTypesSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallTypesSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get CallTypesSettings
         * @param {CallTypesSettingsApiGetCallTypesSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallTypesSettings(requestParameters: CallTypesSettingsApiGetCallTypesSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCallTypesSettings> {
            return localVarFp.getCallTypesSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CallTypesSettings
         * @param {CallTypesSettingsApiUpdateCallTypesSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCallTypesSettings(requestParameters: CallTypesSettingsApiUpdateCallTypesSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCallTypesSettings(requestParameters.pbxCallTypesSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCallTypesSettings operation in CallTypesSettingsApi.
 * @export
 * @interface CallTypesSettingsApiGetCallTypesSettingsRequest
 */
export interface CallTypesSettingsApiGetCallTypesSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CallTypesSettingsApiGetCallTypesSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CallTypesSettingsApiGetCallTypesSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCallTypesSettings operation in CallTypesSettingsApi.
 * @export
 * @interface CallTypesSettingsApiUpdateCallTypesSettingsRequest
 */
export interface CallTypesSettingsApiUpdateCallTypesSettingsRequest {
    /**
     * New property values
     * @type {PbxCallTypesSettings}
     * @memberof CallTypesSettingsApiUpdateCallTypesSettings
     */
    readonly pbxCallTypesSettings: PbxCallTypesSettings
}

/**
 * CallTypesSettingsApi - object-oriented interface
 * @export
 * @class CallTypesSettingsApi
 * @extends {BaseAPI}
 */
export class CallTypesSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get CallTypesSettings
     * @param {CallTypesSettingsApiGetCallTypesSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTypesSettingsApi
     */
    public getCallTypesSettings(requestParameters: CallTypesSettingsApiGetCallTypesSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return CallTypesSettingsApiFp(this.configuration).getCallTypesSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CallTypesSettings
     * @param {CallTypesSettingsApiUpdateCallTypesSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTypesSettingsApi
     */
    public updateCallTypesSettings(requestParameters: CallTypesSettingsApiUpdateCallTypesSettingsRequest, options?: RawAxiosRequestConfig) {
        return CallTypesSettingsApiFp(this.configuration).updateCallTypesSettings(requestParameters.pbxCallTypesSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatHistoryViewApi - axios parameter creator
 * @export
 */
export const ChatHistoryViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadChatHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadChatHistory: async (clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadChatHistory', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ChatHistoryView/Pbx.DownloadChatHistory(clientTimeZone={clientTimeZone})`
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from ChatHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatHistoryView: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ChatHistoryView`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatHistoryViewApi - functional programming interface
 * @export
 */
export const ChatHistoryViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatHistoryViewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadChatHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadChatHistory(clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfChatHistoryView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadChatHistory(clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatHistoryViewApi.downloadChatHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from ChatHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChatHistoryView($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxChatHistoryViewCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChatHistoryView($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatHistoryViewApi.listChatHistoryView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatHistoryViewApi - factory interface
 * @export
 */
export const ChatHistoryViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatHistoryViewApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadChatHistory
         * @param {ChatHistoryViewApiDownloadChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadChatHistory(requestParameters: ChatHistoryViewApiDownloadChatHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfChatHistoryView> {
            return localVarFp.downloadChatHistory(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from ChatHistoryView
         * @param {ChatHistoryViewApiListChatHistoryViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatHistoryView(requestParameters: ChatHistoryViewApiListChatHistoryViewRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxChatHistoryViewCollectionResponse> {
            return localVarFp.listChatHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadChatHistory operation in ChatHistoryViewApi.
 * @export
 * @interface ChatHistoryViewApiDownloadChatHistoryRequest
 */
export interface ChatHistoryViewApiDownloadChatHistoryRequest {
    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiDownloadChatHistory
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listChatHistoryView operation in ChatHistoryViewApi.
 * @export
 * @interface ChatHistoryViewApiListChatHistoryViewRequest
 */
export interface ChatHistoryViewApiListChatHistoryViewRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ChatHistoryViewApiListChatHistoryView
     */
    readonly $expand?: Set<string>
}

/**
 * ChatHistoryViewApi - object-oriented interface
 * @export
 * @class ChatHistoryViewApi
 * @extends {BaseAPI}
 */
export class ChatHistoryViewApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadChatHistory
     * @param {ChatHistoryViewApiDownloadChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatHistoryViewApi
     */
    public downloadChatHistory(requestParameters: ChatHistoryViewApiDownloadChatHistoryRequest, options?: RawAxiosRequestConfig) {
        return ChatHistoryViewApiFp(this.configuration).downloadChatHistory(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from ChatHistoryView
     * @param {ChatHistoryViewApiListChatHistoryViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatHistoryViewApi
     */
    public listChatHistoryView(requestParameters: ChatHistoryViewApiListChatHistoryViewRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatHistoryViewApiFp(this.configuration).listChatHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatLogSettingsApi - axios parameter creator
 * @export
 */
export const ChatLogSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get ChatLogSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatLogSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ChatLogSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update ChatLogSettings
         * @param {PbxChatLogSettings} pbxChatLogSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatLogSettings: async (pbxChatLogSettings: PbxChatLogSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxChatLogSettings' is not null or undefined
            assertParamExists('updateChatLogSettings', 'pbxChatLogSettings', pbxChatLogSettings)
            const localVarPath = `/ChatLogSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxChatLogSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatLogSettingsApi - functional programming interface
 * @export
 */
export const ChatLogSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatLogSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get ChatLogSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatLogSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxChatLogSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatLogSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatLogSettingsApi.getChatLogSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update ChatLogSettings
         * @param {PbxChatLogSettings} pbxChatLogSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatLogSettings(pbxChatLogSettings: PbxChatLogSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatLogSettings(pbxChatLogSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatLogSettingsApi.updateChatLogSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatLogSettingsApi - factory interface
 * @export
 */
export const ChatLogSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatLogSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get ChatLogSettings
         * @param {ChatLogSettingsApiGetChatLogSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatLogSettings(requestParameters: ChatLogSettingsApiGetChatLogSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxChatLogSettings> {
            return localVarFp.getChatLogSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update ChatLogSettings
         * @param {ChatLogSettingsApiUpdateChatLogSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatLogSettings(requestParameters: ChatLogSettingsApiUpdateChatLogSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateChatLogSettings(requestParameters.pbxChatLogSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChatLogSettings operation in ChatLogSettingsApi.
 * @export
 * @interface ChatLogSettingsApiGetChatLogSettingsRequest
 */
export interface ChatLogSettingsApiGetChatLogSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ChatLogSettingsApiGetChatLogSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ChatLogSettingsApiGetChatLogSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateChatLogSettings operation in ChatLogSettingsApi.
 * @export
 * @interface ChatLogSettingsApiUpdateChatLogSettingsRequest
 */
export interface ChatLogSettingsApiUpdateChatLogSettingsRequest {
    /**
     * New property values
     * @type {PbxChatLogSettings}
     * @memberof ChatLogSettingsApiUpdateChatLogSettings
     */
    readonly pbxChatLogSettings: PbxChatLogSettings
}

/**
 * ChatLogSettingsApi - object-oriented interface
 * @export
 * @class ChatLogSettingsApi
 * @extends {BaseAPI}
 */
export class ChatLogSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get ChatLogSettings
     * @param {ChatLogSettingsApiGetChatLogSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatLogSettingsApi
     */
    public getChatLogSettings(requestParameters: ChatLogSettingsApiGetChatLogSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatLogSettingsApiFp(this.configuration).getChatLogSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update ChatLogSettings
     * @param {ChatLogSettingsApiUpdateChatLogSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatLogSettingsApi
     */
    public updateChatLogSettings(requestParameters: ChatLogSettingsApiUpdateChatLogSettingsRequest, options?: RawAxiosRequestConfig) {
        return ChatLogSettingsApiFp(this.configuration).updateChatLogSettings(requestParameters.pbxChatLogSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatMessagesHistoryViewApi - axios parameter creator
 * @export
 */
export const ChatMessagesHistoryViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadChatMessagesHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadChatMessagesHistory: async (clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadChatMessagesHistory', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ChatMessagesHistoryView/Pbx.DownloadChatMessagesHistory(clientTimeZone={clientTimeZone})`
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from ChatMessagesHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatMessagesHistoryView: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ChatMessagesHistoryView`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatMessagesHistoryViewApi - functional programming interface
 * @export
 */
export const ChatMessagesHistoryViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatMessagesHistoryViewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadChatMessagesHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadChatMessagesHistory(clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfChatMessagesHistoryView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadChatMessagesHistory(clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatMessagesHistoryViewApi.downloadChatMessagesHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from ChatMessagesHistoryView
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChatMessagesHistoryView($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxChatMessagesHistoryViewCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChatMessagesHistoryView($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatMessagesHistoryViewApi.listChatMessagesHistoryView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatMessagesHistoryViewApi - factory interface
 * @export
 */
export const ChatMessagesHistoryViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatMessagesHistoryViewApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadChatMessagesHistory
         * @param {ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadChatMessagesHistory(requestParameters: ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfChatMessagesHistoryView> {
            return localVarFp.downloadChatMessagesHistory(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from ChatMessagesHistoryView
         * @param {ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChatMessagesHistoryView(requestParameters: ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxChatMessagesHistoryViewCollectionResponse> {
            return localVarFp.listChatMessagesHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadChatMessagesHistory operation in ChatMessagesHistoryViewApi.
 * @export
 * @interface ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest
 */
export interface ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest {
    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiDownloadChatMessagesHistory
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listChatMessagesHistoryView operation in ChatMessagesHistoryViewApi.
 * @export
 * @interface ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest
 */
export interface ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ChatMessagesHistoryViewApiListChatMessagesHistoryView
     */
    readonly $expand?: Set<string>
}

/**
 * ChatMessagesHistoryViewApi - object-oriented interface
 * @export
 * @class ChatMessagesHistoryViewApi
 * @extends {BaseAPI}
 */
export class ChatMessagesHistoryViewApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadChatMessagesHistory
     * @param {ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatMessagesHistoryViewApi
     */
    public downloadChatMessagesHistory(requestParameters: ChatMessagesHistoryViewApiDownloadChatMessagesHistoryRequest, options?: RawAxiosRequestConfig) {
        return ChatMessagesHistoryViewApiFp(this.configuration).downloadChatMessagesHistory(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from ChatMessagesHistoryView
     * @param {ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatMessagesHistoryViewApi
     */
    public listChatMessagesHistoryView(requestParameters: ChatMessagesHistoryViewApiListChatMessagesHistoryViewRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatMessagesHistoryViewApiFp(this.configuration).listChatMessagesHistoryView(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CodecsSettingsApi - axios parameter creator
 * @export
 */
export const CodecsSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get CodecsSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodecsSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CodecsSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CodecsSettings
         * @param {PbxCodecsSettings} pbxCodecsSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCodecsSettings: async (pbxCodecsSettings: PbxCodecsSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCodecsSettings' is not null or undefined
            assertParamExists('updateCodecsSettings', 'pbxCodecsSettings', pbxCodecsSettings)
            const localVarPath = `/CodecsSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCodecsSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodecsSettingsApi - functional programming interface
 * @export
 */
export const CodecsSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CodecsSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get CodecsSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodecsSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCodecsSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodecsSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CodecsSettingsApi.getCodecsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CodecsSettings
         * @param {PbxCodecsSettings} pbxCodecsSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCodecsSettings(pbxCodecsSettings: PbxCodecsSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCodecsSettings(pbxCodecsSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CodecsSettingsApi.updateCodecsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CodecsSettingsApi - factory interface
 * @export
 */
export const CodecsSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CodecsSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get CodecsSettings
         * @param {CodecsSettingsApiGetCodecsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodecsSettings(requestParameters: CodecsSettingsApiGetCodecsSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCodecsSettings> {
            return localVarFp.getCodecsSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CodecsSettings
         * @param {CodecsSettingsApiUpdateCodecsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCodecsSettings(requestParameters: CodecsSettingsApiUpdateCodecsSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCodecsSettings(requestParameters.pbxCodecsSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCodecsSettings operation in CodecsSettingsApi.
 * @export
 * @interface CodecsSettingsApiGetCodecsSettingsRequest
 */
export interface CodecsSettingsApiGetCodecsSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CodecsSettingsApiGetCodecsSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CodecsSettingsApiGetCodecsSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCodecsSettings operation in CodecsSettingsApi.
 * @export
 * @interface CodecsSettingsApiUpdateCodecsSettingsRequest
 */
export interface CodecsSettingsApiUpdateCodecsSettingsRequest {
    /**
     * New property values
     * @type {PbxCodecsSettings}
     * @memberof CodecsSettingsApiUpdateCodecsSettings
     */
    readonly pbxCodecsSettings: PbxCodecsSettings
}

/**
 * CodecsSettingsApi - object-oriented interface
 * @export
 * @class CodecsSettingsApi
 * @extends {BaseAPI}
 */
export class CodecsSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get CodecsSettings
     * @param {CodecsSettingsApiGetCodecsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodecsSettingsApi
     */
    public getCodecsSettings(requestParameters: CodecsSettingsApiGetCodecsSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return CodecsSettingsApiFp(this.configuration).getCodecsSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CodecsSettings
     * @param {CodecsSettingsApiUpdateCodecsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodecsSettingsApi
     */
    public updateCodecsSettings(requestParameters: CodecsSettingsApiUpdateCodecsSettingsRequest, options?: RawAxiosRequestConfig) {
        return CodecsSettingsApiFp(this.configuration).updateCodecsSettings(requestParameters.pbxCodecsSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConferenceSettingsApi - axios parameter creator
 * @export
 */
export const ConferenceSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function GenerateApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GenerateApiKey()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ConferenceSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConferenceSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMCURequestStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURequestStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GetMCURequestStatus()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMCURow
         * @param {string} guid Usage: guid&#x3D;{guid}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURow: async (guid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('getMCURow', 'guid', guid)
            const localVarPath = `/ConferenceSettings/Pbx.GetMCURow(guid={guid})`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMCURows
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURows: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GetMCURows()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetOnboardMcuData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardMcuData: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GetOnboardMcuData()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetOnboardMeetings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardMeetings: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GetOnboardMeetings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetWebMeetingZones
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebMeetingZones: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConferenceSettings/Pbx.GetWebMeetingZones()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update ConferenceSettings
         * @param {PbxConferenceSettings} pbxConferenceSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConferenceSettings: async (pbxConferenceSettings: PbxConferenceSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxConferenceSettings' is not null or undefined
            assertParamExists('updateConferenceSettings', 'pbxConferenceSettings', pbxConferenceSettings)
            const localVarPath = `/ConferenceSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxConferenceSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UpdateMCURequestStatus
         * @param {ConferenceSettingsUpdateMCURequestStatusRequestBody} conferenceSettingsUpdateMCURequestStatusRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMCURequestStatus: async (conferenceSettingsUpdateMCURequestStatusRequestBody: ConferenceSettingsUpdateMCURequestStatusRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conferenceSettingsUpdateMCURequestStatusRequestBody' is not null or undefined
            assertParamExists('updateMCURequestStatus', 'conferenceSettingsUpdateMCURequestStatusRequestBody', conferenceSettingsUpdateMCURequestStatusRequestBody)
            const localVarPath = `/ConferenceSettings/Pbx.UpdateMCURequestStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conferenceSettingsUpdateMCURequestStatusRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConferenceSettingsApi - functional programming interface
 * @export
 */
export const ConferenceSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConferenceSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function GenerateApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateApiKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateApiKey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.generateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get ConferenceSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConferenceSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxConferenceSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConferenceSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getConferenceSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMCURequestStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMCURequestStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMCURequestStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMCURequestStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getMCURequestStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMCURow
         * @param {string} guid Usage: guid&#x3D;{guid}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMCURow(guid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOnBoardMcuRow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMCURow(guid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getMCURow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMCURows
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMCURows($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMCURows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMCURows($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getMCURows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetOnboardMcuData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardMcuData($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOnboardMcuData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardMcuData($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getOnboardMcuData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetOnboardMeetings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardMeetings($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOnboardMeetings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardMeetings($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getOnboardMeetings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetWebMeetingZones
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebMeetingZones($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebMeetingZones($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.getWebMeetingZones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update ConferenceSettings
         * @param {PbxConferenceSettings} pbxConferenceSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConferenceSettings(pbxConferenceSettings: PbxConferenceSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConferenceSettings(pbxConferenceSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.updateConferenceSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UpdateMCURequestStatus
         * @param {ConferenceSettingsUpdateMCURequestStatusRequestBody} conferenceSettingsUpdateMCURequestStatusRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMCURequestStatus(conferenceSettingsUpdateMCURequestStatusRequestBody: ConferenceSettingsUpdateMCURequestStatusRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMCURequestStatus(conferenceSettingsUpdateMCURequestStatusRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConferenceSettingsApi.updateMCURequestStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConferenceSettingsApi - factory interface
 * @export
 */
export const ConferenceSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConferenceSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function GenerateApiKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey(options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.generateApiKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ConferenceSettings
         * @param {ConferenceSettingsApiGetConferenceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConferenceSettings(requestParameters: ConferenceSettingsApiGetConferenceSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxConferenceSettings> {
            return localVarFp.getConferenceSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMCURequestStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURequestStatus(options?: RawAxiosRequestConfig): AxiosPromise<PbxMCURequestStatus> {
            return localVarFp.getMCURequestStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMCURow
         * @param {ConferenceSettingsApiGetMCURowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURow(requestParameters: ConferenceSettingsApiGetMCURowRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxOnBoardMcuRow> {
            return localVarFp.getMCURow(requestParameters.guid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMCURows
         * @param {ConferenceSettingsApiGetMCURowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMCURows(requestParameters: ConferenceSettingsApiGetMCURowsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetMCURows200Response> {
            return localVarFp.getMCURows(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetOnboardMcuData
         * @param {ConferenceSettingsApiGetOnboardMcuDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardMcuData(requestParameters: ConferenceSettingsApiGetOnboardMcuDataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetOnboardMcuData200Response> {
            return localVarFp.getOnboardMcuData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetOnboardMeetings
         * @param {ConferenceSettingsApiGetOnboardMeetingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardMeetings(requestParameters: ConferenceSettingsApiGetOnboardMeetingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetOnboardMeetings200Response> {
            return localVarFp.getOnboardMeetings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetWebMeetingZones
         * @param {ConferenceSettingsApiGetWebMeetingZonesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebMeetingZones(requestParameters: ConferenceSettingsApiGetWebMeetingZonesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAudioFiles200Response> {
            return localVarFp.getWebMeetingZones(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update ConferenceSettings
         * @param {ConferenceSettingsApiUpdateConferenceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConferenceSettings(requestParameters: ConferenceSettingsApiUpdateConferenceSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateConferenceSettings(requestParameters.pbxConferenceSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UpdateMCURequestStatus
         * @param {ConferenceSettingsApiUpdateMCURequestStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMCURequestStatus(requestParameters: ConferenceSettingsApiUpdateMCURequestStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMCURequestStatus(requestParameters.conferenceSettingsUpdateMCURequestStatusRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConferenceSettings operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetConferenceSettingsRequest
 */
export interface ConferenceSettingsApiGetConferenceSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ConferenceSettingsApiGetConferenceSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ConferenceSettingsApiGetConferenceSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getMCURow operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetMCURowRequest
 */
export interface ConferenceSettingsApiGetMCURowRequest {
    /**
     * Usage: guid&#x3D;{guid}
     * @type {string}
     * @memberof ConferenceSettingsApiGetMCURow
     */
    readonly guid: string
}

/**
 * Request parameters for getMCURows operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetMCURowsRequest
 */
export interface ConferenceSettingsApiGetMCURowsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetMCURows
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetMCURows
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ConferenceSettingsApiGetMCURows
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ConferenceSettingsApiGetMCURows
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ConferenceSettingsApiGetMCURows
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getOnboardMcuData operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetOnboardMcuDataRequest
 */
export interface ConferenceSettingsApiGetOnboardMcuDataRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetOnboardMcuData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetOnboardMcuData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ConferenceSettingsApiGetOnboardMcuData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ConferenceSettingsApiGetOnboardMcuData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ConferenceSettingsApiGetOnboardMcuData
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getOnboardMeetings operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetOnboardMeetingsRequest
 */
export interface ConferenceSettingsApiGetOnboardMeetingsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetOnboardMeetings
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetOnboardMeetings
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ConferenceSettingsApiGetOnboardMeetings
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ConferenceSettingsApiGetOnboardMeetings
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ConferenceSettingsApiGetOnboardMeetings
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getWebMeetingZones operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiGetWebMeetingZonesRequest
 */
export interface ConferenceSettingsApiGetWebMeetingZonesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetWebMeetingZones
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ConferenceSettingsApiGetWebMeetingZones
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ConferenceSettingsApiGetWebMeetingZones
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ConferenceSettingsApiGetWebMeetingZones
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ConferenceSettingsApiGetWebMeetingZones
     */
    readonly $count?: boolean
}

/**
 * Request parameters for updateConferenceSettings operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiUpdateConferenceSettingsRequest
 */
export interface ConferenceSettingsApiUpdateConferenceSettingsRequest {
    /**
     * New property values
     * @type {PbxConferenceSettings}
     * @memberof ConferenceSettingsApiUpdateConferenceSettings
     */
    readonly pbxConferenceSettings: PbxConferenceSettings
}

/**
 * Request parameters for updateMCURequestStatus operation in ConferenceSettingsApi.
 * @export
 * @interface ConferenceSettingsApiUpdateMCURequestStatusRequest
 */
export interface ConferenceSettingsApiUpdateMCURequestStatusRequest {
    /**
     * Action parameters
     * @type {ConferenceSettingsUpdateMCURequestStatusRequestBody}
     * @memberof ConferenceSettingsApiUpdateMCURequestStatus
     */
    readonly conferenceSettingsUpdateMCURequestStatusRequestBody: ConferenceSettingsUpdateMCURequestStatusRequestBody
}

/**
 * ConferenceSettingsApi - object-oriented interface
 * @export
 * @class ConferenceSettingsApi
 * @extends {BaseAPI}
 */
export class ConferenceSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function GenerateApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public generateApiKey(options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).generateApiKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ConferenceSettings
     * @param {ConferenceSettingsApiGetConferenceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getConferenceSettings(requestParameters: ConferenceSettingsApiGetConferenceSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getConferenceSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMCURequestStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getMCURequestStatus(options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getMCURequestStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMCURow
     * @param {ConferenceSettingsApiGetMCURowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getMCURow(requestParameters: ConferenceSettingsApiGetMCURowRequest, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getMCURow(requestParameters.guid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMCURows
     * @param {ConferenceSettingsApiGetMCURowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getMCURows(requestParameters: ConferenceSettingsApiGetMCURowsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getMCURows(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetOnboardMcuData
     * @param {ConferenceSettingsApiGetOnboardMcuDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getOnboardMcuData(requestParameters: ConferenceSettingsApiGetOnboardMcuDataRequest = {}, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getOnboardMcuData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetOnboardMeetings
     * @param {ConferenceSettingsApiGetOnboardMeetingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getOnboardMeetings(requestParameters: ConferenceSettingsApiGetOnboardMeetingsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getOnboardMeetings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetWebMeetingZones
     * @param {ConferenceSettingsApiGetWebMeetingZonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public getWebMeetingZones(requestParameters: ConferenceSettingsApiGetWebMeetingZonesRequest = {}, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).getWebMeetingZones(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update ConferenceSettings
     * @param {ConferenceSettingsApiUpdateConferenceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public updateConferenceSettings(requestParameters: ConferenceSettingsApiUpdateConferenceSettingsRequest, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).updateConferenceSettings(requestParameters.pbxConferenceSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UpdateMCURequestStatus
     * @param {ConferenceSettingsApiUpdateMCURequestStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConferenceSettingsApi
     */
    public updateMCURequestStatus(requestParameters: ConferenceSettingsApiUpdateMCURequestStatusRequest, options?: RawAxiosRequestConfig) {
        return ConferenceSettingsApiFp(this.configuration).updateMCURequestStatus(requestParameters.conferenceSettingsUpdateMCURequestStatusRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsoleRestrictionsApi - axios parameter creator
 * @export
 */
export const ConsoleRestrictionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get ConsoleRestrictions
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsoleRestrictions: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ConsoleRestrictions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update ConsoleRestrictions
         * @param {PbxConsoleRestrictions} pbxConsoleRestrictions New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsoleRestrictions: async (pbxConsoleRestrictions: PbxConsoleRestrictions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxConsoleRestrictions' is not null or undefined
            assertParamExists('updateConsoleRestrictions', 'pbxConsoleRestrictions', pbxConsoleRestrictions)
            const localVarPath = `/ConsoleRestrictions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxConsoleRestrictions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsoleRestrictionsApi - functional programming interface
 * @export
 */
export const ConsoleRestrictionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsoleRestrictionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get ConsoleRestrictions
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsoleRestrictions($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxConsoleRestrictions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsoleRestrictions($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsoleRestrictionsApi.getConsoleRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update ConsoleRestrictions
         * @param {PbxConsoleRestrictions} pbxConsoleRestrictions New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConsoleRestrictions(pbxConsoleRestrictions: PbxConsoleRestrictions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConsoleRestrictions(pbxConsoleRestrictions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsoleRestrictionsApi.updateConsoleRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsoleRestrictionsApi - factory interface
 * @export
 */
export const ConsoleRestrictionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsoleRestrictionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get ConsoleRestrictions
         * @param {ConsoleRestrictionsApiGetConsoleRestrictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsoleRestrictions(requestParameters: ConsoleRestrictionsApiGetConsoleRestrictionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxConsoleRestrictions> {
            return localVarFp.getConsoleRestrictions(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update ConsoleRestrictions
         * @param {ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsoleRestrictions(requestParameters: ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateConsoleRestrictions(requestParameters.pbxConsoleRestrictions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConsoleRestrictions operation in ConsoleRestrictionsApi.
 * @export
 * @interface ConsoleRestrictionsApiGetConsoleRestrictionsRequest
 */
export interface ConsoleRestrictionsApiGetConsoleRestrictionsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ConsoleRestrictionsApiGetConsoleRestrictions
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ConsoleRestrictionsApiGetConsoleRestrictions
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateConsoleRestrictions operation in ConsoleRestrictionsApi.
 * @export
 * @interface ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest
 */
export interface ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest {
    /**
     * New property values
     * @type {PbxConsoleRestrictions}
     * @memberof ConsoleRestrictionsApiUpdateConsoleRestrictions
     */
    readonly pbxConsoleRestrictions: PbxConsoleRestrictions
}

/**
 * ConsoleRestrictionsApi - object-oriented interface
 * @export
 * @class ConsoleRestrictionsApi
 * @extends {BaseAPI}
 */
export class ConsoleRestrictionsApi extends BaseAPI {
    /**
     * 
     * @summary Get ConsoleRestrictions
     * @param {ConsoleRestrictionsApiGetConsoleRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleRestrictionsApi
     */
    public getConsoleRestrictions(requestParameters: ConsoleRestrictionsApiGetConsoleRestrictionsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConsoleRestrictionsApiFp(this.configuration).getConsoleRestrictions(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update ConsoleRestrictions
     * @param {ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleRestrictionsApi
     */
    public updateConsoleRestrictions(requestParameters: ConsoleRestrictionsApiUpdateConsoleRestrictionsRequest, options?: RawAxiosRequestConfig) {
        return ConsoleRestrictionsApiFp(this.configuration).updateConsoleRestrictions(requestParameters.pbxConsoleRestrictions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action AllContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allContactsBulkDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.AllContactsBulkDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action BatchContactsDelete
         * @param {ContactsBatchContactsDeleteRequestBody} contactsBatchContactsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchContactsDelete: async (contactsBatchContactsDeleteRequestBody: ContactsBatchContactsDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactsBatchContactsDeleteRequestBody' is not null or undefined
            assertParamExists('batchContactsDelete', 'contactsBatchContactsDeleteRequestBody', contactsBatchContactsDeleteRequestBody)
            const localVarPath = `/Contacts/Pbx.BatchContactsDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsBatchContactsDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action CRMContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cRMContactsBulkDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.CRMContactsBulkDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to Contacts
         * @param {PbxContact} pbxContact New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: async (pbxContact: PbxContact, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxContact' is not null or undefined
            assertParamExists('createContact', 'pbxContact', pbxContact)
            const localVarPath = `/Contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxContact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Contacts
         * @param {number} id The unique identifier of Contact
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContact', 'id', id)
            const localVarPath = `/Contacts({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function ExportContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContacts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.ExportContacts()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Contacts by key
         * @param {number} id The unique identifier of Contact
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContact', 'id', id)
            const localVarPath = `/Contacts({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetDirSearchSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirSearchSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.GetDirSearchSettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Contacts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContact: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Office365ContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office365ContactsBulkDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.Office365ContactsBulkDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Office365PersonalContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office365PersonalContactsBulkDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Contacts/Pbx.Office365PersonalContactsBulkDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetDirSearchSettings
         * @param {ContactsSetDirSearchSettingsRequestBody} contactsSetDirSearchSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDirSearchSettings: async (contactsSetDirSearchSettingsRequestBody: ContactsSetDirSearchSettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactsSetDirSearchSettingsRequestBody' is not null or undefined
            assertParamExists('setDirSearchSettings', 'contactsSetDirSearchSettingsRequestBody', contactsSetDirSearchSettingsRequestBody)
            const localVarPath = `/Contacts/Pbx.SetDirSearchSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsSetDirSearchSettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Contacts
         * @param {number} id The unique identifier of Contact
         * @param {PbxContact} pbxContact New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (id: number, pbxContact: PbxContact, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContact', 'id', id)
            // verify required parameter 'pbxContact' is not null or undefined
            assertParamExists('updateContact', 'pbxContact', pbxContact)
            const localVarPath = `/Contacts({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxContact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action AllContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allContactsBulkDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allContactsBulkDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.allContactsBulkDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action BatchContactsDelete
         * @param {ContactsBatchContactsDeleteRequestBody} contactsBatchContactsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchContactsDelete(contactsBatchContactsDeleteRequestBody: ContactsBatchContactsDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchContactsDelete(contactsBatchContactsDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.batchContactsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action CRMContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cRMContactsBulkDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cRMContactsBulkDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.cRMContactsBulkDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to Contacts
         * @param {PbxContact} pbxContact New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContact(pbxContact: PbxContact, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxContact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(pbxContact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.createContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Contacts
         * @param {number} id The unique identifier of Contact
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContact(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.deleteContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function ExportContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportContacts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportContacts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.exportContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Contacts by key
         * @param {number} id The unique identifier of Contact
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxContact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetDirSearchSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirSearchSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxContactsDirSearchSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirSearchSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getDirSearchSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Contacts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContact($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxContactCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContact($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.listContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Office365ContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async office365ContactsBulkDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.office365ContactsBulkDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.office365ContactsBulkDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Office365PersonalContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async office365PersonalContactsBulkDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.office365PersonalContactsBulkDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.office365PersonalContactsBulkDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetDirSearchSettings
         * @param {ContactsSetDirSearchSettingsRequestBody} contactsSetDirSearchSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDirSearchSettings(contactsSetDirSearchSettingsRequestBody: ContactsSetDirSearchSettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDirSearchSettings(contactsSetDirSearchSettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.setDirSearchSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Contacts
         * @param {number} id The unique identifier of Contact
         * @param {PbxContact} pbxContact New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(id: number, pbxContact: PbxContact, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(id, pbxContact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.updateContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action AllContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allContactsBulkDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.allContactsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action BatchContactsDelete
         * @param {ContactsApiBatchContactsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchContactsDelete(requestParameters: ContactsApiBatchContactsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.batchContactsDelete(requestParameters.contactsBatchContactsDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action CRMContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cRMContactsBulkDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cRMContactsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to Contacts
         * @param {ContactsApiCreateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(requestParameters: ContactsApiCreateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxContact> {
            return localVarFp.createContact(requestParameters.pbxContact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Contacts
         * @param {ContactsApiDeleteContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(requestParameters: ContactsApiDeleteContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContact(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function ExportContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContacts(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.exportContacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Contacts by key
         * @param {ContactsApiGetContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(requestParameters: ContactsApiGetContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxContact> {
            return localVarFp.getContact(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetDirSearchSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirSearchSettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxContactsDirSearchSettings> {
            return localVarFp.getDirSearchSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Contacts
         * @param {ContactsApiListContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContact(requestParameters: ContactsApiListContactRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxContactCollectionResponse> {
            return localVarFp.listContact(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Office365ContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office365ContactsBulkDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.office365ContactsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Office365PersonalContactsBulkDelete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office365PersonalContactsBulkDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.office365PersonalContactsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetDirSearchSettings
         * @param {ContactsApiSetDirSearchSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDirSearchSettings(requestParameters: ContactsApiSetDirSearchSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setDirSearchSettings(requestParameters.contactsSetDirSearchSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Contacts
         * @param {ContactsApiUpdateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(requestParameters: ContactsApiUpdateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContact(requestParameters.id, requestParameters.pbxContact, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for batchContactsDelete operation in ContactsApi.
 * @export
 * @interface ContactsApiBatchContactsDeleteRequest
 */
export interface ContactsApiBatchContactsDeleteRequest {
    /**
     * Action parameters
     * @type {ContactsBatchContactsDeleteRequestBody}
     * @memberof ContactsApiBatchContactsDelete
     */
    readonly contactsBatchContactsDeleteRequestBody: ContactsBatchContactsDeleteRequestBody
}

/**
 * Request parameters for createContact operation in ContactsApi.
 * @export
 * @interface ContactsApiCreateContactRequest
 */
export interface ContactsApiCreateContactRequest {
    /**
     * New entity
     * @type {PbxContact}
     * @memberof ContactsApiCreateContact
     */
    readonly pbxContact: PbxContact
}

/**
 * Request parameters for deleteContact operation in ContactsApi.
 * @export
 * @interface ContactsApiDeleteContactRequest
 */
export interface ContactsApiDeleteContactRequest {
    /**
     * The unique identifier of Contact
     * @type {number}
     * @memberof ContactsApiDeleteContact
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ContactsApiDeleteContact
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getContact operation in ContactsApi.
 * @export
 * @interface ContactsApiGetContactRequest
 */
export interface ContactsApiGetContactRequest {
    /**
     * The unique identifier of Contact
     * @type {number}
     * @memberof ContactsApiGetContact
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ContactsApiGetContact
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ContactsApiGetContact
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listContact operation in ContactsApi.
 * @export
 * @interface ContactsApiListContactRequest
 */
export interface ContactsApiListContactRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ContactsApiListContact
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ContactsApiListContact
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ContactsApiListContact
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ContactsApiListContact
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ContactsApiListContact
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ContactsApiListContact
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ContactsApiListContact
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ContactsApiListContact
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for setDirSearchSettings operation in ContactsApi.
 * @export
 * @interface ContactsApiSetDirSearchSettingsRequest
 */
export interface ContactsApiSetDirSearchSettingsRequest {
    /**
     * Action parameters
     * @type {ContactsSetDirSearchSettingsRequestBody}
     * @memberof ContactsApiSetDirSearchSettings
     */
    readonly contactsSetDirSearchSettingsRequestBody: ContactsSetDirSearchSettingsRequestBody
}

/**
 * Request parameters for updateContact operation in ContactsApi.
 * @export
 * @interface ContactsApiUpdateContactRequest
 */
export interface ContactsApiUpdateContactRequest {
    /**
     * The unique identifier of Contact
     * @type {number}
     * @memberof ContactsApiUpdateContact
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxContact}
     * @memberof ContactsApiUpdateContact
     */
    readonly pbxContact: PbxContact
}

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action AllContactsBulkDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public allContactsBulkDelete(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).allContactsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action BatchContactsDelete
     * @param {ContactsApiBatchContactsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public batchContactsDelete(requestParameters: ContactsApiBatchContactsDeleteRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).batchContactsDelete(requestParameters.contactsBatchContactsDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action CRMContactsBulkDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public cRMContactsBulkDelete(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).cRMContactsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to Contacts
     * @param {ContactsApiCreateContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createContact(requestParameters: ContactsApiCreateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createContact(requestParameters.pbxContact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Contacts
     * @param {ContactsApiDeleteContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public deleteContact(requestParameters: ContactsApiDeleteContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).deleteContact(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function ExportContacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public exportContacts(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).exportContacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Contacts by key
     * @param {ContactsApiGetContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContact(requestParameters: ContactsApiGetContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContact(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetDirSearchSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getDirSearchSettings(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getDirSearchSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Contacts
     * @param {ContactsApiListContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public listContact(requestParameters: ContactsApiListContactRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).listContact(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Office365ContactsBulkDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public office365ContactsBulkDelete(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).office365ContactsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Office365PersonalContactsBulkDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public office365PersonalContactsBulkDelete(options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).office365PersonalContactsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetDirSearchSettings
     * @param {ContactsApiSetDirSearchSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public setDirSearchSettings(requestParameters: ContactsApiSetDirSearchSettingsRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).setDirSearchSettings(requestParameters.contactsSetDirSearchSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Contacts
     * @param {ContactsApiUpdateContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public updateContact(requestParameters: ContactsApiUpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).updateContact(requestParameters.id, requestParameters.pbxContact, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from Countries
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCountry: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from Countries
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCountry($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCountryCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCountry($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.listCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from Countries
         * @param {CountriesApiListCountryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCountry(requestParameters: CountriesApiListCountryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCountryCollectionResponse> {
            return localVarFp.listCountry(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCountry operation in CountriesApi.
 * @export
 * @interface CountriesApiListCountryRequest
 */
export interface CountriesApiListCountryRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CountriesApiListCountry
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CountriesApiListCountry
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CountriesApiListCountry
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CountriesApiListCountry
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CountriesApiListCountry
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CountriesApiListCountry
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CountriesApiListCountry
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CountriesApiListCountry
     */
    readonly $expand?: Set<string>
}

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from Countries
     * @param {CountriesApiListCountryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public listCountry(requestParameters: CountriesApiListCountryRequest = {}, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).listCountry(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryCodesApi - axios parameter creator
 * @export
 */
export const CountryCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get CountryCodes
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryCodes: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CountryCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CountryCodes
         * @param {PbxCountryCodes} pbxCountryCodes New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCountryCodes: async (pbxCountryCodes: PbxCountryCodes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCountryCodes' is not null or undefined
            assertParamExists('updateCountryCodes', 'pbxCountryCodes', pbxCountryCodes)
            const localVarPath = `/CountryCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCountryCodes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryCodesApi - functional programming interface
 * @export
 */
export const CountryCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get CountryCodes
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryCodes($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCountryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryCodes($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryCodesApi.getCountryCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CountryCodes
         * @param {PbxCountryCodes} pbxCountryCodes New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCountryCodes(pbxCountryCodes: PbxCountryCodes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCountryCodes(pbxCountryCodes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryCodesApi.updateCountryCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryCodesApi - factory interface
 * @export
 */
export const CountryCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get CountryCodes
         * @param {CountryCodesApiGetCountryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryCodes(requestParameters: CountryCodesApiGetCountryCodesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCountryCodes> {
            return localVarFp.getCountryCodes(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CountryCodes
         * @param {CountryCodesApiUpdateCountryCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCountryCodes(requestParameters: CountryCodesApiUpdateCountryCodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCountryCodes(requestParameters.pbxCountryCodes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCountryCodes operation in CountryCodesApi.
 * @export
 * @interface CountryCodesApiGetCountryCodesRequest
 */
export interface CountryCodesApiGetCountryCodesRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CountryCodesApiGetCountryCodes
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CountryCodesApiGetCountryCodes
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateCountryCodes operation in CountryCodesApi.
 * @export
 * @interface CountryCodesApiUpdateCountryCodesRequest
 */
export interface CountryCodesApiUpdateCountryCodesRequest {
    /**
     * New property values
     * @type {PbxCountryCodes}
     * @memberof CountryCodesApiUpdateCountryCodes
     */
    readonly pbxCountryCodes: PbxCountryCodes
}

/**
 * CountryCodesApi - object-oriented interface
 * @export
 * @class CountryCodesApi
 * @extends {BaseAPI}
 */
export class CountryCodesApi extends BaseAPI {
    /**
     * 
     * @summary Get CountryCodes
     * @param {CountryCodesApiGetCountryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryCodesApi
     */
    public getCountryCodes(requestParameters: CountryCodesApiGetCountryCodesRequest = {}, options?: RawAxiosRequestConfig) {
        return CountryCodesApiFp(this.configuration).getCountryCodes(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CountryCodes
     * @param {CountryCodesApiUpdateCountryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryCodesApi
     */
    public updateCountryCodes(requestParameters: CountryCodesApiUpdateCountryCodesRequest, options?: RawAxiosRequestConfig) {
        return CountryCodesApiFp(this.configuration).updateCountryCodes(requestParameters.pbxCountryCodes, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrmIntegrationApi - axios parameter creator
 * @export
 */
export const CrmIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action DeleteCrmContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrmContacts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CrmIntegration/Pbx.DeleteCrmContacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CrmIntegration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmIntegration: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CrmIntegration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCrmTemplateSource
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmTemplateSource: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCrmTemplateSource', 'name', name)
            const localVarPath = `/CrmIntegration/Pbx.GetCrmTemplateSource(name={name})`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetOAuth
         * @param {string} variable Usage: variable&#x3D;{variable}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth: async (variable: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variable' is not null or undefined
            assertParamExists('getOAuth', 'variable', variable)
            const localVarPath = `/CrmIntegration/Pbx.GetOAuth(variable={variable})`
                .replace(`{${"variable"}}`, encodeURIComponent(String(variable)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetOAuthState
         * @param {CrmIntegrationSetOAuthStateRequestBody} crmIntegrationSetOAuthStateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOAuthState: async (crmIntegrationSetOAuthStateRequestBody: CrmIntegrationSetOAuthStateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crmIntegrationSetOAuthStateRequestBody' is not null or undefined
            assertParamExists('setOAuthState', 'crmIntegrationSetOAuthStateRequestBody', crmIntegrationSetOAuthStateRequestBody)
            const localVarPath = `/CrmIntegration/Pbx.SetOAuthState`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmIntegrationSetOAuthStateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Test
         * @param {CrmIntegrationTestRequestBody} crmIntegrationTestRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (crmIntegrationTestRequestBody: CrmIntegrationTestRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crmIntegrationTestRequestBody' is not null or undefined
            assertParamExists('test', 'crmIntegrationTestRequestBody', crmIntegrationTestRequestBody)
            const localVarPath = `/CrmIntegration/Pbx.Test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmIntegrationTestRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CrmIntegration
         * @param {PbxCrmIntegration} pbxCrmIntegration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCrmIntegration: async (pbxCrmIntegration: PbxCrmIntegration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxCrmIntegration' is not null or undefined
            assertParamExists('updateCrmIntegration', 'pbxCrmIntegration', pbxCrmIntegration)
            const localVarPath = `/CrmIntegration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxCrmIntegration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrmIntegrationApi - functional programming interface
 * @export
 */
export const CrmIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrmIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action DeleteCrmContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCrmContacts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCrmContacts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.deleteCrmContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get CrmIntegration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrmIntegration($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCrmIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrmIntegration($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.getCrmIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCrmTemplateSource
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrmTemplateSource(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCrmTemplateSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrmTemplateSource(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.getCrmTemplateSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetOAuth
         * @param {string} variable Usage: variable&#x3D;{variable}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuth(variable: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuth(variable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.getOAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetOAuthState
         * @param {CrmIntegrationSetOAuthStateRequestBody} crmIntegrationSetOAuthStateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOAuthState(crmIntegrationSetOAuthStateRequestBody: CrmIntegrationSetOAuthStateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOauthState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOAuthState(crmIntegrationSetOAuthStateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.setOAuthState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Test
         * @param {CrmIntegrationTestRequestBody} crmIntegrationTestRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(crmIntegrationTestRequestBody: CrmIntegrationTestRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCrmTestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(crmIntegrationTestRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CrmIntegration
         * @param {PbxCrmIntegration} pbxCrmIntegration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCrmIntegration(pbxCrmIntegration: PbxCrmIntegration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCrmIntegration(pbxCrmIntegration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmIntegrationApi.updateCrmIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrmIntegrationApi - factory interface
 * @export
 */
export const CrmIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrmIntegrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action DeleteCrmContacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrmContacts(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCrmContacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CrmIntegration
         * @param {CrmIntegrationApiGetCrmIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmIntegration(requestParameters: CrmIntegrationApiGetCrmIntegrationRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCrmIntegration> {
            return localVarFp.getCrmIntegration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCrmTemplateSource
         * @param {CrmIntegrationApiGetCrmTemplateSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmTemplateSource(requestParameters: CrmIntegrationApiGetCrmTemplateSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCrmTemplateSource200Response> {
            return localVarFp.getCrmTemplateSource(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetOAuth
         * @param {CrmIntegrationApiGetOAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth(requestParameters: CrmIntegrationApiGetOAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOAuth200Response> {
            return localVarFp.getOAuth(requestParameters.variable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetOAuthState
         * @param {CrmIntegrationApiSetOAuthStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOAuthState(requestParameters: CrmIntegrationApiSetOAuthStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxOauthState> {
            return localVarFp.setOAuthState(requestParameters.crmIntegrationSetOAuthStateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Test
         * @param {CrmIntegrationApiTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(requestParameters: CrmIntegrationApiTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxCrmTestResult> {
            return localVarFp.test(requestParameters.crmIntegrationTestRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CrmIntegration
         * @param {CrmIntegrationApiUpdateCrmIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCrmIntegration(requestParameters: CrmIntegrationApiUpdateCrmIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCrmIntegration(requestParameters.pbxCrmIntegration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCrmIntegration operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiGetCrmIntegrationRequest
 */
export interface CrmIntegrationApiGetCrmIntegrationRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CrmIntegrationApiGetCrmIntegration
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CrmIntegrationApiGetCrmIntegration
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCrmTemplateSource operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiGetCrmTemplateSourceRequest
 */
export interface CrmIntegrationApiGetCrmTemplateSourceRequest {
    /**
     * Usage: name&#x3D;{name}
     * @type {string}
     * @memberof CrmIntegrationApiGetCrmTemplateSource
     */
    readonly name: string
}

/**
 * Request parameters for getOAuth operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiGetOAuthRequest
 */
export interface CrmIntegrationApiGetOAuthRequest {
    /**
     * Usage: variable&#x3D;{variable}
     * @type {string}
     * @memberof CrmIntegrationApiGetOAuth
     */
    readonly variable: string
}

/**
 * Request parameters for setOAuthState operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiSetOAuthStateRequest
 */
export interface CrmIntegrationApiSetOAuthStateRequest {
    /**
     * Action parameters
     * @type {CrmIntegrationSetOAuthStateRequestBody}
     * @memberof CrmIntegrationApiSetOAuthState
     */
    readonly crmIntegrationSetOAuthStateRequestBody: CrmIntegrationSetOAuthStateRequestBody
}

/**
 * Request parameters for test operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiTestRequest
 */
export interface CrmIntegrationApiTestRequest {
    /**
     * Action parameters
     * @type {CrmIntegrationTestRequestBody}
     * @memberof CrmIntegrationApiTest
     */
    readonly crmIntegrationTestRequestBody: CrmIntegrationTestRequestBody
}

/**
 * Request parameters for updateCrmIntegration operation in CrmIntegrationApi.
 * @export
 * @interface CrmIntegrationApiUpdateCrmIntegrationRequest
 */
export interface CrmIntegrationApiUpdateCrmIntegrationRequest {
    /**
     * New property values
     * @type {PbxCrmIntegration}
     * @memberof CrmIntegrationApiUpdateCrmIntegration
     */
    readonly pbxCrmIntegration: PbxCrmIntegration
}

/**
 * CrmIntegrationApi - object-oriented interface
 * @export
 * @class CrmIntegrationApi
 * @extends {BaseAPI}
 */
export class CrmIntegrationApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action DeleteCrmContacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public deleteCrmContacts(options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).deleteCrmContacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CrmIntegration
     * @param {CrmIntegrationApiGetCrmIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public getCrmIntegration(requestParameters: CrmIntegrationApiGetCrmIntegrationRequest = {}, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).getCrmIntegration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCrmTemplateSource
     * @param {CrmIntegrationApiGetCrmTemplateSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public getCrmTemplateSource(requestParameters: CrmIntegrationApiGetCrmTemplateSourceRequest, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).getCrmTemplateSource(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetOAuth
     * @param {CrmIntegrationApiGetOAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public getOAuth(requestParameters: CrmIntegrationApiGetOAuthRequest, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).getOAuth(requestParameters.variable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetOAuthState
     * @param {CrmIntegrationApiSetOAuthStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public setOAuthState(requestParameters: CrmIntegrationApiSetOAuthStateRequest, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).setOAuthState(requestParameters.crmIntegrationSetOAuthStateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Test
     * @param {CrmIntegrationApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public test(requestParameters: CrmIntegrationApiTestRequest, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).test(requestParameters.crmIntegrationTestRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CrmIntegration
     * @param {CrmIntegrationApiUpdateCrmIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmIntegrationApi
     */
    public updateCrmIntegration(requestParameters: CrmIntegrationApiUpdateCrmIntegrationRequest, options?: RawAxiosRequestConfig) {
        return CrmIntegrationApiFp(this.configuration).updateCrmIntegration(requestParameters.pbxCrmIntegration, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CrmTemplatesApi - axios parameter creator
 * @export
 */
export const CrmTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from CrmTemplates
         * @param {string} name The unique identifier of CrmTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrmTemplate: async (name: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCrmTemplate', 'name', name)
            const localVarPath = `/CrmTemplates({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GeCrmtTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geCrmtTemplates: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CrmTemplates/Pbx.GeCrmtTemplates()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from CrmTemplates by key
         * @param {string} name The unique identifier of CrmTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmTemplate: async (name: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCrmTemplate', 'name', name)
            const localVarPath = `/CrmTemplates({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrmTemplatesApi - functional programming interface
 * @export
 */
export const CrmTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrmTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from CrmTemplates
         * @param {string} name The unique identifier of CrmTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCrmTemplate(name: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCrmTemplate(name, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmTemplatesApi.deleteCrmTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GeCrmtTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geCrmtTemplates($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCrmTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geCrmtTemplates($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmTemplatesApi.geCrmtTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from CrmTemplates by key
         * @param {string} name The unique identifier of CrmTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrmTemplate(name: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCrmTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrmTemplate(name, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CrmTemplatesApi.getCrmTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CrmTemplatesApi - factory interface
 * @export
 */
export const CrmTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrmTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from CrmTemplates
         * @param {CrmTemplatesApiDeleteCrmTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCrmTemplate(requestParameters: CrmTemplatesApiDeleteCrmTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCrmTemplate(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GeCrmtTemplates
         * @param {CrmTemplatesApiGeCrmtTemplatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geCrmtTemplates(requestParameters: CrmTemplatesApiGeCrmtTemplatesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCrmTemplate> {
            return localVarFp.geCrmtTemplates(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from CrmTemplates by key
         * @param {CrmTemplatesApiGetCrmTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrmTemplate(requestParameters: CrmTemplatesApiGetCrmTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxCrmTemplate> {
            return localVarFp.getCrmTemplate(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteCrmTemplate operation in CrmTemplatesApi.
 * @export
 * @interface CrmTemplatesApiDeleteCrmTemplateRequest
 */
export interface CrmTemplatesApiDeleteCrmTemplateRequest {
    /**
     * The unique identifier of CrmTemplate
     * @type {string}
     * @memberof CrmTemplatesApiDeleteCrmTemplate
     */
    readonly name: string

    /**
     * ETag
     * @type {string}
     * @memberof CrmTemplatesApiDeleteCrmTemplate
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for geCrmtTemplates operation in CrmTemplatesApi.
 * @export
 * @interface CrmTemplatesApiGeCrmtTemplatesRequest
 */
export interface CrmTemplatesApiGeCrmtTemplatesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CrmTemplatesApiGeCrmtTemplates
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCrmTemplate operation in CrmTemplatesApi.
 * @export
 * @interface CrmTemplatesApiGetCrmTemplateRequest
 */
export interface CrmTemplatesApiGetCrmTemplateRequest {
    /**
     * The unique identifier of CrmTemplate
     * @type {string}
     * @memberof CrmTemplatesApiGetCrmTemplate
     */
    readonly name: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CrmTemplatesApiGetCrmTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CrmTemplatesApiGetCrmTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * CrmTemplatesApi - object-oriented interface
 * @export
 * @class CrmTemplatesApi
 * @extends {BaseAPI}
 */
export class CrmTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from CrmTemplates
     * @param {CrmTemplatesApiDeleteCrmTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmTemplatesApi
     */
    public deleteCrmTemplate(requestParameters: CrmTemplatesApiDeleteCrmTemplateRequest, options?: RawAxiosRequestConfig) {
        return CrmTemplatesApiFp(this.configuration).deleteCrmTemplate(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GeCrmtTemplates
     * @param {CrmTemplatesApiGeCrmtTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmTemplatesApi
     */
    public geCrmtTemplates(requestParameters: CrmTemplatesApiGeCrmtTemplatesRequest = {}, options?: RawAxiosRequestConfig) {
        return CrmTemplatesApiFp(this.configuration).geCrmtTemplates(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from CrmTemplates by key
     * @param {CrmTemplatesApiGetCrmTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrmTemplatesApi
     */
    public getCrmTemplate(requestParameters: CrmTemplatesApiGetCrmTemplateRequest, options?: RawAxiosRequestConfig) {
        return CrmTemplatesApiFp(this.configuration).getCrmTemplate(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomPromptsApi - axios parameter creator
 * @export
 */
export const CustomPromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from CustomPrompts
         * @param {string} filename The unique identifier of CustomPrompt
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPrompt: async (filename: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('deleteCustomPrompt', 'filename', filename)
            const localVarPath = `/CustomPrompts({Filename})`
                .replace(`{${"Filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from CustomPrompts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomPrompt: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/CustomPrompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MakeCallRecordCustomPrompt
         * @param {CustomPromptsMakeCallRecordCustomPromptRequestBody} customPromptsMakeCallRecordCustomPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCallRecordCustomPrompt: async (customPromptsMakeCallRecordCustomPromptRequestBody: CustomPromptsMakeCallRecordCustomPromptRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customPromptsMakeCallRecordCustomPromptRequestBody' is not null or undefined
            assertParamExists('makeCallRecordCustomPrompt', 'customPromptsMakeCallRecordCustomPromptRequestBody', customPromptsMakeCallRecordCustomPromptRequestBody)
            const localVarPath = `/CustomPrompts/Pbx.MakeCallRecordCustomPrompt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customPromptsMakeCallRecordCustomPromptRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomPromptsApi - functional programming interface
 * @export
 */
export const CustomPromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomPromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from CustomPrompts
         * @param {string} filename The unique identifier of CustomPrompt
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomPrompt(filename: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomPrompt(filename, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPromptsApi.deleteCustomPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from CustomPrompts
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomPrompt($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCustomPromptCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomPrompt($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPromptsApi.listCustomPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MakeCallRecordCustomPrompt
         * @param {CustomPromptsMakeCallRecordCustomPromptRequestBody} customPromptsMakeCallRecordCustomPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeCallRecordCustomPrompt(customPromptsMakeCallRecordCustomPromptRequestBody: CustomPromptsMakeCallRecordCustomPromptRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeCallRecordCustomPrompt(customPromptsMakeCallRecordCustomPromptRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPromptsApi.makeCallRecordCustomPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomPromptsApi - factory interface
 * @export
 */
export const CustomPromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomPromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from CustomPrompts
         * @param {CustomPromptsApiDeleteCustomPromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPrompt(requestParameters: CustomPromptsApiDeleteCustomPromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomPrompt(requestParameters.filename, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from CustomPrompts
         * @param {CustomPromptsApiListCustomPromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomPrompt(requestParameters: CustomPromptsApiListCustomPromptRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCustomPromptCollectionResponse> {
            return localVarFp.listCustomPrompt(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MakeCallRecordCustomPrompt
         * @param {CustomPromptsApiMakeCallRecordCustomPromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCallRecordCustomPrompt(requestParameters: CustomPromptsApiMakeCallRecordCustomPromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.makeCallRecordCustomPrompt(requestParameters.customPromptsMakeCallRecordCustomPromptRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteCustomPrompt operation in CustomPromptsApi.
 * @export
 * @interface CustomPromptsApiDeleteCustomPromptRequest
 */
export interface CustomPromptsApiDeleteCustomPromptRequest {
    /**
     * The unique identifier of CustomPrompt
     * @type {string}
     * @memberof CustomPromptsApiDeleteCustomPrompt
     */
    readonly filename: string

    /**
     * ETag
     * @type {string}
     * @memberof CustomPromptsApiDeleteCustomPrompt
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for listCustomPrompt operation in CustomPromptsApi.
 * @export
 * @interface CustomPromptsApiListCustomPromptRequest
 */
export interface CustomPromptsApiListCustomPromptRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof CustomPromptsApiListCustomPrompt
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for makeCallRecordCustomPrompt operation in CustomPromptsApi.
 * @export
 * @interface CustomPromptsApiMakeCallRecordCustomPromptRequest
 */
export interface CustomPromptsApiMakeCallRecordCustomPromptRequest {
    /**
     * Action parameters
     * @type {CustomPromptsMakeCallRecordCustomPromptRequestBody}
     * @memberof CustomPromptsApiMakeCallRecordCustomPrompt
     */
    readonly customPromptsMakeCallRecordCustomPromptRequestBody: CustomPromptsMakeCallRecordCustomPromptRequestBody
}

/**
 * CustomPromptsApi - object-oriented interface
 * @export
 * @class CustomPromptsApi
 * @extends {BaseAPI}
 */
export class CustomPromptsApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from CustomPrompts
     * @param {CustomPromptsApiDeleteCustomPromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPromptsApi
     */
    public deleteCustomPrompt(requestParameters: CustomPromptsApiDeleteCustomPromptRequest, options?: RawAxiosRequestConfig) {
        return CustomPromptsApiFp(this.configuration).deleteCustomPrompt(requestParameters.filename, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from CustomPrompts
     * @param {CustomPromptsApiListCustomPromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPromptsApi
     */
    public listCustomPrompt(requestParameters: CustomPromptsApiListCustomPromptRequest = {}, options?: RawAxiosRequestConfig) {
        return CustomPromptsApiFp(this.configuration).listCustomPrompt(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MakeCallRecordCustomPrompt
     * @param {CustomPromptsApiMakeCallRecordCustomPromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPromptsApi
     */
    public makeCallRecordCustomPrompt(requestParameters: CustomPromptsApiMakeCallRecordCustomPromptRequest, options?: RawAxiosRequestConfig) {
        return CustomPromptsApiFp(this.configuration).makeCallRecordCustomPrompt(requestParameters.customPromptsMakeCallRecordCustomPromptRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DNPropertiesApi - axios parameter creator
 * @export
 */
export const DNPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action CreateDNProperty
         * @param {DNPropertiesCreateDNPropertyRequestBody} dNPropertiesCreateDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDNProperty: async (dNPropertiesCreateDNPropertyRequestBody: DNPropertiesCreateDNPropertyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dNPropertiesCreateDNPropertyRequestBody' is not null or undefined
            assertParamExists('createDNProperty', 'dNPropertiesCreateDNPropertyRequestBody', dNPropertiesCreateDNPropertyRequestBody)
            const localVarPath = `/DNProperties/Pbx.CreateDNProperty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNPropertiesCreateDNPropertyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeleteDNProperty
         * @param {DNPropertiesDeleteDNPropertyRequestBody} dNPropertiesDeleteDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDNProperty: async (dNPropertiesDeleteDNPropertyRequestBody: DNPropertiesDeleteDNPropertyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dNPropertiesDeleteDNPropertyRequestBody' is not null or undefined
            assertParamExists('deleteDNProperty', 'dNPropertiesDeleteDNPropertyRequestBody', dNPropertiesDeleteDNPropertyRequestBody)
            const localVarPath = `/DNProperties/Pbx.DeleteDNProperty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNPropertiesDeleteDNPropertyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetDNPropertyByName
         * @param {string} dnNumber Usage: dnNumber&#x3D;{dnNumber}
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNPropertyByName: async (dnNumber: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dnNumber' is not null or undefined
            assertParamExists('getDNPropertyByName', 'dnNumber', dnNumber)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDNPropertyByName', 'name', name)
            const localVarPath = `/DNProperties/Pbx.GetDNPropertyByName(dnNumber={dnNumber},name={name})`
                .replace(`{${"dnNumber"}}`, encodeURIComponent(String(dnNumber)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetPropertiesByDn
         * @param {string} dnNumber Usage: dnNumber&#x3D;{dnNumber}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertiesByDn: async (dnNumber: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dnNumber' is not null or undefined
            assertParamExists('getPropertiesByDn', 'dnNumber', dnNumber)
            const localVarPath = `/DNProperties/Pbx.GetPropertiesByDn(dnNumber={dnNumber})`
                .replace(`{${"dnNumber"}}`, encodeURIComponent(String(dnNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UpdateDNProperty
         * @param {DNPropertiesUpdateDNPropertyRequestBody} dNPropertiesUpdateDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNProperty: async (dNPropertiesUpdateDNPropertyRequestBody: DNPropertiesUpdateDNPropertyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dNPropertiesUpdateDNPropertyRequestBody' is not null or undefined
            assertParamExists('updateDNProperty', 'dNPropertiesUpdateDNPropertyRequestBody', dNPropertiesUpdateDNPropertyRequestBody)
            const localVarPath = `/DNProperties/Pbx.UpdateDNProperty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNPropertiesUpdateDNPropertyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNPropertiesApi - functional programming interface
 * @export
 */
export const DNPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DNPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action CreateDNProperty
         * @param {DNPropertiesCreateDNPropertyRequestBody} dNPropertiesCreateDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDNProperty(dNPropertiesCreateDNPropertyRequestBody: DNPropertiesCreateDNPropertyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDNProperty(dNPropertiesCreateDNPropertyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DNPropertiesApi.createDNProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeleteDNProperty
         * @param {DNPropertiesDeleteDNPropertyRequestBody} dNPropertiesDeleteDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDNProperty(dNPropertiesDeleteDNPropertyRequestBody: DNPropertiesDeleteDNPropertyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDNProperty(dNPropertiesDeleteDNPropertyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DNPropertiesApi.deleteDNProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetDNPropertyByName
         * @param {string} dnNumber Usage: dnNumber&#x3D;{dnNumber}
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNPropertyByName(dnNumber: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDNProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNPropertyByName(dnNumber, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DNPropertiesApi.getDNPropertyByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetPropertiesByDn
         * @param {string} dnNumber Usage: dnNumber&#x3D;{dnNumber}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertiesByDn(dnNumber: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDNProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertiesByDn(dnNumber, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DNPropertiesApi.getPropertiesByDn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UpdateDNProperty
         * @param {DNPropertiesUpdateDNPropertyRequestBody} dNPropertiesUpdateDNPropertyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDNProperty(dNPropertiesUpdateDNPropertyRequestBody: DNPropertiesUpdateDNPropertyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDNProperty(dNPropertiesUpdateDNPropertyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DNPropertiesApi.updateDNProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DNPropertiesApi - factory interface
 * @export
 */
export const DNPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DNPropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action CreateDNProperty
         * @param {DNPropertiesApiCreateDNPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDNProperty(requestParameters: DNPropertiesApiCreateDNPropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createDNProperty(requestParameters.dNPropertiesCreateDNPropertyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeleteDNProperty
         * @param {DNPropertiesApiDeleteDNPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDNProperty(requestParameters: DNPropertiesApiDeleteDNPropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDNProperty(requestParameters.dNPropertiesDeleteDNPropertyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetDNPropertyByName
         * @param {DNPropertiesApiGetDNPropertyByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNPropertyByName(requestParameters: DNPropertiesApiGetDNPropertyByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxDNProperty> {
            return localVarFp.getDNPropertyByName(requestParameters.dnNumber, requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetPropertiesByDn
         * @param {DNPropertiesApiGetPropertiesByDnRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertiesByDn(requestParameters: DNPropertiesApiGetPropertiesByDnRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDNProperty> {
            return localVarFp.getPropertiesByDn(requestParameters.dnNumber, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UpdateDNProperty
         * @param {DNPropertiesApiUpdateDNPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNProperty(requestParameters: DNPropertiesApiUpdateDNPropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDNProperty(requestParameters.dNPropertiesUpdateDNPropertyRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDNProperty operation in DNPropertiesApi.
 * @export
 * @interface DNPropertiesApiCreateDNPropertyRequest
 */
export interface DNPropertiesApiCreateDNPropertyRequest {
    /**
     * Action parameters
     * @type {DNPropertiesCreateDNPropertyRequestBody}
     * @memberof DNPropertiesApiCreateDNProperty
     */
    readonly dNPropertiesCreateDNPropertyRequestBody: DNPropertiesCreateDNPropertyRequestBody
}

/**
 * Request parameters for deleteDNProperty operation in DNPropertiesApi.
 * @export
 * @interface DNPropertiesApiDeleteDNPropertyRequest
 */
export interface DNPropertiesApiDeleteDNPropertyRequest {
    /**
     * Action parameters
     * @type {DNPropertiesDeleteDNPropertyRequestBody}
     * @memberof DNPropertiesApiDeleteDNProperty
     */
    readonly dNPropertiesDeleteDNPropertyRequestBody: DNPropertiesDeleteDNPropertyRequestBody
}

/**
 * Request parameters for getDNPropertyByName operation in DNPropertiesApi.
 * @export
 * @interface DNPropertiesApiGetDNPropertyByNameRequest
 */
export interface DNPropertiesApiGetDNPropertyByNameRequest {
    /**
     * Usage: dnNumber&#x3D;{dnNumber}
     * @type {string}
     * @memberof DNPropertiesApiGetDNPropertyByName
     */
    readonly dnNumber: string

    /**
     * Usage: name&#x3D;{name}
     * @type {string}
     * @memberof DNPropertiesApiGetDNPropertyByName
     */
    readonly name: string
}

/**
 * Request parameters for getPropertiesByDn operation in DNPropertiesApi.
 * @export
 * @interface DNPropertiesApiGetPropertiesByDnRequest
 */
export interface DNPropertiesApiGetPropertiesByDnRequest {
    /**
     * Usage: dnNumber&#x3D;{dnNumber}
     * @type {string}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly dnNumber: string

    /**
     * Show only the first n items
     * @type {number}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DNPropertiesApiGetPropertiesByDn
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateDNProperty operation in DNPropertiesApi.
 * @export
 * @interface DNPropertiesApiUpdateDNPropertyRequest
 */
export interface DNPropertiesApiUpdateDNPropertyRequest {
    /**
     * Action parameters
     * @type {DNPropertiesUpdateDNPropertyRequestBody}
     * @memberof DNPropertiesApiUpdateDNProperty
     */
    readonly dNPropertiesUpdateDNPropertyRequestBody: DNPropertiesUpdateDNPropertyRequestBody
}

/**
 * DNPropertiesApi - object-oriented interface
 * @export
 * @class DNPropertiesApi
 * @extends {BaseAPI}
 */
export class DNPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action CreateDNProperty
     * @param {DNPropertiesApiCreateDNPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNPropertiesApi
     */
    public createDNProperty(requestParameters: DNPropertiesApiCreateDNPropertyRequest, options?: RawAxiosRequestConfig) {
        return DNPropertiesApiFp(this.configuration).createDNProperty(requestParameters.dNPropertiesCreateDNPropertyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeleteDNProperty
     * @param {DNPropertiesApiDeleteDNPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNPropertiesApi
     */
    public deleteDNProperty(requestParameters: DNPropertiesApiDeleteDNPropertyRequest, options?: RawAxiosRequestConfig) {
        return DNPropertiesApiFp(this.configuration).deleteDNProperty(requestParameters.dNPropertiesDeleteDNPropertyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetDNPropertyByName
     * @param {DNPropertiesApiGetDNPropertyByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNPropertiesApi
     */
    public getDNPropertyByName(requestParameters: DNPropertiesApiGetDNPropertyByNameRequest, options?: RawAxiosRequestConfig) {
        return DNPropertiesApiFp(this.configuration).getDNPropertyByName(requestParameters.dnNumber, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetPropertiesByDn
     * @param {DNPropertiesApiGetPropertiesByDnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNPropertiesApi
     */
    public getPropertiesByDn(requestParameters: DNPropertiesApiGetPropertiesByDnRequest, options?: RawAxiosRequestConfig) {
        return DNPropertiesApiFp(this.configuration).getPropertiesByDn(requestParameters.dnNumber, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UpdateDNProperty
     * @param {DNPropertiesApiUpdateDNPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNPropertiesApi
     */
    public updateDNProperty(requestParameters: DNPropertiesApiUpdateDNPropertyRequest, options?: RawAxiosRequestConfig) {
        return DNPropertiesApiFp(this.configuration).updateDNProperty(requestParameters.dNPropertiesUpdateDNPropertyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefsApi - axios parameter creator
 * @export
 */
export const DefsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Defs
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefs: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetRoutes
         * @param {DefsGetRoutesRequestBody} defsGetRoutesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes: async (defsGetRoutesRequestBody: DefsGetRoutesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'defsGetRoutesRequestBody' is not null or undefined
            assertParamExists('getRoutes', 'defsGetRoutesRequestBody', defsGetRoutesRequestBody)
            const localVarPath = `/Defs/Pbx.GetRoutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defsGetRoutesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetSystemParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemParameters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/Pbx.GetSystemParameters()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function HasSystemOwner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasSystemOwner: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/Pbx.HasSystemOwner()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Codecs from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodecs: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/Codecs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GatewayParameterValues from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewayParameterValues: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/GatewayParameterValues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GatewayParameters from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewayParameters: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/GatewayParameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TimeZones from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Defs/TimeZones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefsApi - functional programming interface
 * @export
 */
export const DefsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Defs
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefs($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDefs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefs($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.getDefs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetRoutes
         * @param {DefsGetRoutesRequestBody} defsGetRoutesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutes(defsGetRoutesRequestBody: DefsGetRoutesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoutes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutes(defsGetRoutesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.getRoutes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetSystemParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemParameters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSystemParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemParameters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.getSystemParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function HasSystemOwner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasSystemOwner(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasSystemOwner(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.hasSystemOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Codecs from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCodecs($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxCodecCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCodecs($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.listCodecs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GatewayParameterValues from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGatewayParameterValues($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGatewayParameterValueCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGatewayParameterValues($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.listGatewayParameterValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GatewayParameters from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGatewayParameters($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGatewayParameterCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGatewayParameters($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.listGatewayParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TimeZones from Defs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimeZones($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTimeZoneCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimeZones($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefsApi.listTimeZones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefsApi - factory interface
 * @export
 */
export const DefsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Defs
         * @param {DefsApiGetDefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefs(requestParameters: DefsApiGetDefsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxDefs> {
            return localVarFp.getDefs(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetRoutes
         * @param {DefsApiGetRoutesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(requestParameters: DefsApiGetRoutesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetRoutes200Response> {
            return localVarFp.getRoutes(requestParameters.defsGetRoutesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetSystemParameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemParameters(options?: RawAxiosRequestConfig): AxiosPromise<PbxSystemParameters> {
            return localVarFp.getSystemParameters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function HasSystemOwner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasSystemOwner(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.hasSystemOwner(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Codecs from Defs
         * @param {DefsApiListCodecsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodecs(requestParameters: DefsApiListCodecsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxCodecCollectionResponse> {
            return localVarFp.listCodecs(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GatewayParameterValues from Defs
         * @param {DefsApiListGatewayParameterValuesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewayParameterValues(requestParameters: DefsApiListGatewayParameterValuesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGatewayParameterValueCollectionResponse> {
            return localVarFp.listGatewayParameterValues(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GatewayParameters from Defs
         * @param {DefsApiListGatewayParametersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGatewayParameters(requestParameters: DefsApiListGatewayParametersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGatewayParameterCollectionResponse> {
            return localVarFp.listGatewayParameters(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TimeZones from Defs
         * @param {DefsApiListTimeZonesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones(requestParameters: DefsApiListTimeZonesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxTimeZoneCollectionResponse> {
            return localVarFp.listTimeZones(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDefs operation in DefsApi.
 * @export
 * @interface DefsApiGetDefsRequest
 */
export interface DefsApiGetDefsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DefsApiGetDefs
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DefsApiGetDefs
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getRoutes operation in DefsApi.
 * @export
 * @interface DefsApiGetRoutesRequest
 */
export interface DefsApiGetRoutesRequest {
    /**
     * Action parameters
     * @type {DefsGetRoutesRequestBody}
     * @memberof DefsApiGetRoutes
     */
    readonly defsGetRoutesRequestBody: DefsGetRoutesRequestBody
}

/**
 * Request parameters for listCodecs operation in DefsApi.
 * @export
 * @interface DefsApiListCodecsRequest
 */
export interface DefsApiListCodecsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DefsApiListCodecs
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DefsApiListCodecs
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DefsApiListCodecs
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DefsApiListCodecs
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DefsApiListCodecs
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DefsApiListCodecs
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DefsApiListCodecs
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DefsApiListCodecs
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listGatewayParameterValues operation in DefsApi.
 * @export
 * @interface DefsApiListGatewayParameterValuesRequest
 */
export interface DefsApiListGatewayParameterValuesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameterValues
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listGatewayParameters operation in DefsApi.
 * @export
 * @interface DefsApiListGatewayParametersRequest
 */
export interface DefsApiListGatewayParametersRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DefsApiListGatewayParameters
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listTimeZones operation in DefsApi.
 * @export
 * @interface DefsApiListTimeZonesRequest
 */
export interface DefsApiListTimeZonesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DefsApiListTimeZones
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DefsApiListTimeZones
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DefsApiListTimeZones
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DefsApiListTimeZones
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DefsApiListTimeZones
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DefsApiListTimeZones
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DefsApiListTimeZones
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DefsApiListTimeZones
     */
    readonly $expand?: Set<string>
}

/**
 * DefsApi - object-oriented interface
 * @export
 * @class DefsApi
 * @extends {BaseAPI}
 */
export class DefsApi extends BaseAPI {
    /**
     * 
     * @summary Get Defs
     * @param {DefsApiGetDefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public getDefs(requestParameters: DefsApiGetDefsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).getDefs(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetRoutes
     * @param {DefsApiGetRoutesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public getRoutes(requestParameters: DefsApiGetRoutesRequest, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).getRoutes(requestParameters.defsGetRoutesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetSystemParameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public getSystemParameters(options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).getSystemParameters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function HasSystemOwner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public hasSystemOwner(options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).hasSystemOwner(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Codecs from Defs
     * @param {DefsApiListCodecsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public listCodecs(requestParameters: DefsApiListCodecsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).listCodecs(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GatewayParameterValues from Defs
     * @param {DefsApiListGatewayParameterValuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public listGatewayParameterValues(requestParameters: DefsApiListGatewayParameterValuesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).listGatewayParameterValues(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GatewayParameters from Defs
     * @param {DefsApiListGatewayParametersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public listGatewayParameters(requestParameters: DefsApiListGatewayParametersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).listGatewayParameters(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TimeZones from Defs
     * @param {DefsApiListTimeZonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefsApi
     */
    public listTimeZones(requestParameters: DefsApiListTimeZonesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefsApiFp(this.configuration).listTimeZones(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceInfosApi - axios parameter creator
 * @export
 */
export const DeviceInfosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from DeviceInfos
         * @param {number} id The unique identifier of DeviceInfo
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceInfo: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeviceInfo', 'id', id)
            const localVarPath = `/DeviceInfos({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from DeviceInfos by key
         * @param {number} id The unique identifier of DeviceInfo
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceInfo', 'id', id)
            const localVarPath = `/DeviceInfos({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from DeviceInfos
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeviceInfo: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/DeviceInfos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Provision
         * @param {number} id The unique identifier of DeviceInfo
         * @param {DeviceInfosDeviceInfoProvisionRequestBody} deviceInfosDeviceInfoProvisionRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provision: async (id: number, deviceInfosDeviceInfoProvisionRequestBody: DeviceInfosDeviceInfoProvisionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provision', 'id', id)
            // verify required parameter 'deviceInfosDeviceInfoProvisionRequestBody' is not null or undefined
            assertParamExists('provision', 'deviceInfosDeviceInfoProvisionRequestBody', deviceInfosDeviceInfoProvisionRequestBody)
            const localVarPath = `/DeviceInfos({Id})/Pbx.Provision`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceInfosDeviceInfoProvisionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceInfosApi - functional programming interface
 * @export
 */
export const DeviceInfosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceInfosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from DeviceInfos
         * @param {number} id The unique identifier of DeviceInfo
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceInfo(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceInfo(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceInfosApi.deleteDeviceInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from DeviceInfos by key
         * @param {number} id The unique identifier of DeviceInfo
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInfo(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDeviceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceInfo(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceInfosApi.getDeviceInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from DeviceInfos
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeviceInfo($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDeviceInfoCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeviceInfo($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceInfosApi.listDeviceInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Provision
         * @param {number} id The unique identifier of DeviceInfo
         * @param {DeviceInfosDeviceInfoProvisionRequestBody} deviceInfosDeviceInfoProvisionRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provision(id: number, deviceInfosDeviceInfoProvisionRequestBody: DeviceInfosDeviceInfoProvisionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provision(id, deviceInfosDeviceInfoProvisionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceInfosApi.provision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceInfosApi - factory interface
 * @export
 */
export const DeviceInfosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceInfosApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from DeviceInfos
         * @param {DeviceInfosApiDeleteDeviceInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceInfo(requestParameters: DeviceInfosApiDeleteDeviceInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeviceInfo(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from DeviceInfos by key
         * @param {DeviceInfosApiGetDeviceInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo(requestParameters: DeviceInfosApiGetDeviceInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxDeviceInfo> {
            return localVarFp.getDeviceInfo(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from DeviceInfos
         * @param {DeviceInfosApiListDeviceInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeviceInfo(requestParameters: DeviceInfosApiListDeviceInfoRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxDeviceInfoCollectionResponse> {
            return localVarFp.listDeviceInfo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Provision
         * @param {DeviceInfosApiProvisionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provision(requestParameters: DeviceInfosApiProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provision(requestParameters.id, requestParameters.deviceInfosDeviceInfoProvisionRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteDeviceInfo operation in DeviceInfosApi.
 * @export
 * @interface DeviceInfosApiDeleteDeviceInfoRequest
 */
export interface DeviceInfosApiDeleteDeviceInfoRequest {
    /**
     * The unique identifier of DeviceInfo
     * @type {number}
     * @memberof DeviceInfosApiDeleteDeviceInfo
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof DeviceInfosApiDeleteDeviceInfo
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getDeviceInfo operation in DeviceInfosApi.
 * @export
 * @interface DeviceInfosApiGetDeviceInfoRequest
 */
export interface DeviceInfosApiGetDeviceInfoRequest {
    /**
     * The unique identifier of DeviceInfo
     * @type {number}
     * @memberof DeviceInfosApiGetDeviceInfo
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DeviceInfosApiGetDeviceInfo
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DeviceInfosApiGetDeviceInfo
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listDeviceInfo operation in DeviceInfosApi.
 * @export
 * @interface DeviceInfosApiListDeviceInfoRequest
 */
export interface DeviceInfosApiListDeviceInfoRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DeviceInfosApiListDeviceInfo
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for provision operation in DeviceInfosApi.
 * @export
 * @interface DeviceInfosApiProvisionRequest
 */
export interface DeviceInfosApiProvisionRequest {
    /**
     * The unique identifier of DeviceInfo
     * @type {number}
     * @memberof DeviceInfosApiProvision
     */
    readonly id: number

    /**
     * Action parameters
     * @type {DeviceInfosDeviceInfoProvisionRequestBody}
     * @memberof DeviceInfosApiProvision
     */
    readonly deviceInfosDeviceInfoProvisionRequestBody: DeviceInfosDeviceInfoProvisionRequestBody
}

/**
 * DeviceInfosApi - object-oriented interface
 * @export
 * @class DeviceInfosApi
 * @extends {BaseAPI}
 */
export class DeviceInfosApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from DeviceInfos
     * @param {DeviceInfosApiDeleteDeviceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfosApi
     */
    public deleteDeviceInfo(requestParameters: DeviceInfosApiDeleteDeviceInfoRequest, options?: RawAxiosRequestConfig) {
        return DeviceInfosApiFp(this.configuration).deleteDeviceInfo(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from DeviceInfos by key
     * @param {DeviceInfosApiGetDeviceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfosApi
     */
    public getDeviceInfo(requestParameters: DeviceInfosApiGetDeviceInfoRequest, options?: RawAxiosRequestConfig) {
        return DeviceInfosApiFp(this.configuration).getDeviceInfo(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from DeviceInfos
     * @param {DeviceInfosApiListDeviceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfosApi
     */
    public listDeviceInfo(requestParameters: DeviceInfosApiListDeviceInfoRequest = {}, options?: RawAxiosRequestConfig) {
        return DeviceInfosApiFp(this.configuration).listDeviceInfo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Provision
     * @param {DeviceInfosApiProvisionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfosApi
     */
    public provision(requestParameters: DeviceInfosApiProvisionRequest, options?: RawAxiosRequestConfig) {
        return DeviceInfosApiFp(this.configuration).provision(requestParameters.id, requestParameters.deviceInfosDeviceInfoProvisionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DialCodeSettingsApi - axios parameter creator
 * @export
 */
export const DialCodeSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DialCodeSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDialCodeSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/DialCodeSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update DialCodeSettings
         * @param {PbxDialCodeSettings} pbxDialCodeSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDialCodeSettings: async (pbxDialCodeSettings: PbxDialCodeSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxDialCodeSettings' is not null or undefined
            assertParamExists('updateDialCodeSettings', 'pbxDialCodeSettings', pbxDialCodeSettings)
            const localVarPath = `/DialCodeSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxDialCodeSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DialCodeSettingsApi - functional programming interface
 * @export
 */
export const DialCodeSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DialCodeSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get DialCodeSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDialCodeSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDialCodeSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDialCodeSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DialCodeSettingsApi.getDialCodeSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update DialCodeSettings
         * @param {PbxDialCodeSettings} pbxDialCodeSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDialCodeSettings(pbxDialCodeSettings: PbxDialCodeSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDialCodeSettings(pbxDialCodeSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DialCodeSettingsApi.updateDialCodeSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DialCodeSettingsApi - factory interface
 * @export
 */
export const DialCodeSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DialCodeSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get DialCodeSettings
         * @param {DialCodeSettingsApiGetDialCodeSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDialCodeSettings(requestParameters: DialCodeSettingsApiGetDialCodeSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxDialCodeSettings> {
            return localVarFp.getDialCodeSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update DialCodeSettings
         * @param {DialCodeSettingsApiUpdateDialCodeSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDialCodeSettings(requestParameters: DialCodeSettingsApiUpdateDialCodeSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDialCodeSettings(requestParameters.pbxDialCodeSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDialCodeSettings operation in DialCodeSettingsApi.
 * @export
 * @interface DialCodeSettingsApiGetDialCodeSettingsRequest
 */
export interface DialCodeSettingsApiGetDialCodeSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DialCodeSettingsApiGetDialCodeSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DialCodeSettingsApiGetDialCodeSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateDialCodeSettings operation in DialCodeSettingsApi.
 * @export
 * @interface DialCodeSettingsApiUpdateDialCodeSettingsRequest
 */
export interface DialCodeSettingsApiUpdateDialCodeSettingsRequest {
    /**
     * New property values
     * @type {PbxDialCodeSettings}
     * @memberof DialCodeSettingsApiUpdateDialCodeSettings
     */
    readonly pbxDialCodeSettings: PbxDialCodeSettings
}

/**
 * DialCodeSettingsApi - object-oriented interface
 * @export
 * @class DialCodeSettingsApi
 * @extends {BaseAPI}
 */
export class DialCodeSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get DialCodeSettings
     * @param {DialCodeSettingsApiGetDialCodeSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialCodeSettingsApi
     */
    public getDialCodeSettings(requestParameters: DialCodeSettingsApiGetDialCodeSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return DialCodeSettingsApiFp(this.configuration).getDialCodeSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update DialCodeSettings
     * @param {DialCodeSettingsApiUpdateDialCodeSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialCodeSettingsApi
     */
    public updateDialCodeSettings(requestParameters: DialCodeSettingsApiUpdateDialCodeSettingsRequest, options?: RawAxiosRequestConfig) {
        return DialCodeSettingsApiFp(this.configuration).updateDialCodeSettings(requestParameters.pbxDialCodeSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DidNumbersApi - axios parameter creator
 * @export
 */
export const DidNumbersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from DidNumbers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDidNumber: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/DidNumbers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DidNumbersApi - functional programming interface
 * @export
 */
export const DidNumbersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DidNumbersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from DidNumbers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDidNumber($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxDidNumberCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDidNumber($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DidNumbersApi.listDidNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DidNumbersApi - factory interface
 * @export
 */
export const DidNumbersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DidNumbersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from DidNumbers
         * @param {DidNumbersApiListDidNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDidNumber(requestParameters: DidNumbersApiListDidNumberRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxDidNumberCollectionResponse> {
            return localVarFp.listDidNumber(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listDidNumber operation in DidNumbersApi.
 * @export
 * @interface DidNumbersApiListDidNumberRequest
 */
export interface DidNumbersApiListDidNumberRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof DidNumbersApiListDidNumber
     */
    readonly $expand?: Set<string>
}

/**
 * DidNumbersApi - object-oriented interface
 * @export
 * @class DidNumbersApi
 * @extends {BaseAPI}
 */
export class DidNumbersApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from DidNumbers
     * @param {DidNumbersApiListDidNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DidNumbersApi
     */
    public listDidNumber(requestParameters: DidNumbersApiListDidNumberRequest = {}, options?: RawAxiosRequestConfig) {
        return DidNumbersApiFp(this.configuration).listDidNumber(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DirectoriesApi - axios parameter creator
 * @export
 */
export const DirectoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke actionImport GetDirectoryInfo
         * @param {ActionImportGetDirectoryInfoRequestBody} actionImportGetDirectoryInfoRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryInfo: async (actionImportGetDirectoryInfoRequestBody: ActionImportGetDirectoryInfoRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionImportGetDirectoryInfoRequestBody' is not null or undefined
            assertParamExists('getDirectoryInfo', 'actionImportGetDirectoryInfoRequestBody', actionImportGetDirectoryInfoRequestBody)
            const localVarPath = `/GetDirectoryInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionImportGetDirectoryInfoRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectoriesApi - functional programming interface
 * @export
 */
export const DirectoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DirectoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke actionImport GetDirectoryInfo
         * @param {ActionImportGetDirectoryInfoRequestBody} actionImportGetDirectoryInfoRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectoryInfo(actionImportGetDirectoryInfoRequestBody: ActionImportGetDirectoryInfoRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDirectoryInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectoryInfo(actionImportGetDirectoryInfoRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectoriesApi.getDirectoryInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DirectoriesApi - factory interface
 * @export
 */
export const DirectoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DirectoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke actionImport GetDirectoryInfo
         * @param {DirectoriesApiGetDirectoryInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryInfo(requestParameters: DirectoriesApiGetDirectoryInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetDirectoryInfo200Response> {
            return localVarFp.getDirectoryInfo(requestParameters.actionImportGetDirectoryInfoRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDirectoryInfo operation in DirectoriesApi.
 * @export
 * @interface DirectoriesApiGetDirectoryInfoRequest
 */
export interface DirectoriesApiGetDirectoryInfoRequest {
    /**
     * Action parameters
     * @type {ActionImportGetDirectoryInfoRequestBody}
     * @memberof DirectoriesApiGetDirectoryInfo
     */
    readonly actionImportGetDirectoryInfoRequestBody: ActionImportGetDirectoryInfoRequestBody
}

/**
 * DirectoriesApi - object-oriented interface
 * @export
 * @class DirectoriesApi
 * @extends {BaseAPI}
 */
export class DirectoriesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke actionImport GetDirectoryInfo
     * @param {DirectoriesApiGetDirectoryInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectoriesApi
     */
    public getDirectoryInfo(requestParameters: DirectoriesApiGetDirectoryInfoRequest, options?: RawAxiosRequestConfig) {
        return DirectoriesApiFp(this.configuration).getDirectoryInfo(requestParameters.actionImportGetDirectoryInfoRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E164SettingsApi - axios parameter creator
 * @export
 */
export const E164SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get E164Settings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getE164Settings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/E164Settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update E164Settings
         * @param {PbxE164Settings} pbxE164Settings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateE164Settings: async (pbxE164Settings: PbxE164Settings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxE164Settings' is not null or undefined
            assertParamExists('updateE164Settings', 'pbxE164Settings', pbxE164Settings)
            const localVarPath = `/E164Settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxE164Settings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E164SettingsApi - functional programming interface
 * @export
 */
export const E164SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E164SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get E164Settings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getE164Settings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxE164Settings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getE164Settings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E164SettingsApi.getE164Settings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update E164Settings
         * @param {PbxE164Settings} pbxE164Settings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateE164Settings(pbxE164Settings: PbxE164Settings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateE164Settings(pbxE164Settings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E164SettingsApi.updateE164Settings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E164SettingsApi - factory interface
 * @export
 */
export const E164SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E164SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get E164Settings
         * @param {E164SettingsApiGetE164SettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getE164Settings(requestParameters: E164SettingsApiGetE164SettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxE164Settings> {
            return localVarFp.getE164Settings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update E164Settings
         * @param {E164SettingsApiUpdateE164SettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateE164Settings(requestParameters: E164SettingsApiUpdateE164SettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateE164Settings(requestParameters.pbxE164Settings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getE164Settings operation in E164SettingsApi.
 * @export
 * @interface E164SettingsApiGetE164SettingsRequest
 */
export interface E164SettingsApiGetE164SettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof E164SettingsApiGetE164Settings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof E164SettingsApiGetE164Settings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateE164Settings operation in E164SettingsApi.
 * @export
 * @interface E164SettingsApiUpdateE164SettingsRequest
 */
export interface E164SettingsApiUpdateE164SettingsRequest {
    /**
     * New property values
     * @type {PbxE164Settings}
     * @memberof E164SettingsApiUpdateE164Settings
     */
    readonly pbxE164Settings: PbxE164Settings
}

/**
 * E164SettingsApi - object-oriented interface
 * @export
 * @class E164SettingsApi
 * @extends {BaseAPI}
 */
export class E164SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get E164Settings
     * @param {E164SettingsApiGetE164SettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E164SettingsApi
     */
    public getE164Settings(requestParameters: E164SettingsApiGetE164SettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return E164SettingsApiFp(this.configuration).getE164Settings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update E164Settings
     * @param {E164SettingsApiUpdateE164SettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E164SettingsApi
     */
    public updateE164Settings(requestParameters: E164SettingsApiUpdateE164SettingsRequest, options?: RawAxiosRequestConfig) {
        return E164SettingsApiFp(this.configuration).updateE164Settings(requestParameters.pbxE164Settings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailTemplateApi - axios parameter creator
 * @export
 */
export const EmailTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entity from EmailTemplate by key
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate: async (templatePath: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templatePath' is not null or undefined
            assertParamExists('getEmailTemplate', 'templatePath', templatePath)
            const localVarPath = `/EmailTemplate({TemplatePath})`
                .replace(`{${"TemplatePath"}}`, encodeURIComponent(String(templatePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from EmailTemplate
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplate: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EmailTemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetDefault
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefault: async (templatePath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templatePath' is not null or undefined
            assertParamExists('setDefault', 'templatePath', templatePath)
            const localVarPath = `/EmailTemplate({TemplatePath})/Pbx.SetDefault`
                .replace(`{${"TemplatePath"}}`, encodeURIComponent(String(templatePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in EmailTemplate
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {PbxEmailTemplate} pbxEmailTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailTemplate: async (templatePath: string, pbxEmailTemplate: PbxEmailTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templatePath' is not null or undefined
            assertParamExists('updateEmailTemplate', 'templatePath', templatePath)
            // verify required parameter 'pbxEmailTemplate' is not null or undefined
            assertParamExists('updateEmailTemplate', 'pbxEmailTemplate', pbxEmailTemplate)
            const localVarPath = `/EmailTemplate({TemplatePath})`
                .replace(`{${"TemplatePath"}}`, encodeURIComponent(String(templatePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxEmailTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailTemplateApi - functional programming interface
 * @export
 */
export const EmailTemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailTemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entity from EmailTemplate by key
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmailTemplate(templatePath: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxEmailTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmailTemplate(templatePath, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailTemplateApi.getEmailTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from EmailTemplate
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmailTemplate($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxEmailTemplateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmailTemplate($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailTemplateApi.listEmailTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetDefault
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefault(templatePath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefault(templatePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailTemplateApi.setDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in EmailTemplate
         * @param {string} templatePath The unique identifier of EmailTemplate
         * @param {PbxEmailTemplate} pbxEmailTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailTemplate(templatePath: string, pbxEmailTemplate: PbxEmailTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailTemplate(templatePath, pbxEmailTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailTemplateApi.updateEmailTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailTemplateApi - factory interface
 * @export
 */
export const EmailTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailTemplateApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entity from EmailTemplate by key
         * @param {EmailTemplateApiGetEmailTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(requestParameters: EmailTemplateApiGetEmailTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxEmailTemplate> {
            return localVarFp.getEmailTemplate(requestParameters.templatePath, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from EmailTemplate
         * @param {EmailTemplateApiListEmailTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplate(requestParameters: EmailTemplateApiListEmailTemplateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxEmailTemplateCollectionResponse> {
            return localVarFp.listEmailTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetDefault
         * @param {EmailTemplateApiSetDefaultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefault(requestParameters: EmailTemplateApiSetDefaultRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setDefault(requestParameters.templatePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in EmailTemplate
         * @param {EmailTemplateApiUpdateEmailTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailTemplate(requestParameters: EmailTemplateApiUpdateEmailTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEmailTemplate(requestParameters.templatePath, requestParameters.pbxEmailTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEmailTemplate operation in EmailTemplateApi.
 * @export
 * @interface EmailTemplateApiGetEmailTemplateRequest
 */
export interface EmailTemplateApiGetEmailTemplateRequest {
    /**
     * The unique identifier of EmailTemplate
     * @type {string}
     * @memberof EmailTemplateApiGetEmailTemplate
     */
    readonly templatePath: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof EmailTemplateApiGetEmailTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof EmailTemplateApiGetEmailTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listEmailTemplate operation in EmailTemplateApi.
 * @export
 * @interface EmailTemplateApiListEmailTemplateRequest
 */
export interface EmailTemplateApiListEmailTemplateRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof EmailTemplateApiListEmailTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for setDefault operation in EmailTemplateApi.
 * @export
 * @interface EmailTemplateApiSetDefaultRequest
 */
export interface EmailTemplateApiSetDefaultRequest {
    /**
     * The unique identifier of EmailTemplate
     * @type {string}
     * @memberof EmailTemplateApiSetDefault
     */
    readonly templatePath: string
}

/**
 * Request parameters for updateEmailTemplate operation in EmailTemplateApi.
 * @export
 * @interface EmailTemplateApiUpdateEmailTemplateRequest
 */
export interface EmailTemplateApiUpdateEmailTemplateRequest {
    /**
     * The unique identifier of EmailTemplate
     * @type {string}
     * @memberof EmailTemplateApiUpdateEmailTemplate
     */
    readonly templatePath: string

    /**
     * New property values
     * @type {PbxEmailTemplate}
     * @memberof EmailTemplateApiUpdateEmailTemplate
     */
    readonly pbxEmailTemplate: PbxEmailTemplate
}

/**
 * EmailTemplateApi - object-oriented interface
 * @export
 * @class EmailTemplateApi
 * @extends {BaseAPI}
 */
export class EmailTemplateApi extends BaseAPI {
    /**
     * 
     * @summary Get entity from EmailTemplate by key
     * @param {EmailTemplateApiGetEmailTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public getEmailTemplate(requestParameters: EmailTemplateApiGetEmailTemplateRequest, options?: RawAxiosRequestConfig) {
        return EmailTemplateApiFp(this.configuration).getEmailTemplate(requestParameters.templatePath, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from EmailTemplate
     * @param {EmailTemplateApiListEmailTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public listEmailTemplate(requestParameters: EmailTemplateApiListEmailTemplateRequest = {}, options?: RawAxiosRequestConfig) {
        return EmailTemplateApiFp(this.configuration).listEmailTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetDefault
     * @param {EmailTemplateApiSetDefaultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public setDefault(requestParameters: EmailTemplateApiSetDefaultRequest, options?: RawAxiosRequestConfig) {
        return EmailTemplateApiFp(this.configuration).setDefault(requestParameters.templatePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in EmailTemplate
     * @param {EmailTemplateApiUpdateEmailTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public updateEmailTemplate(requestParameters: EmailTemplateApiUpdateEmailTemplateRequest, options?: RawAxiosRequestConfig) {
        return EmailTemplateApiFp(this.configuration).updateEmailTemplate(requestParameters.templatePath, requestParameters.pbxEmailTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmergencyGeoLocationsApi - axios parameter creator
 * @export
 */
export const EmergencyGeoLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from EmergencyGeoLocations
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmergencyGeoLocation: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EmergencyGeoLocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Update
         * @param {EmergencyGeoLocationsUpdateRequestBody} emergencyGeoLocationsUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (emergencyGeoLocationsUpdateRequestBody: EmergencyGeoLocationsUpdateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emergencyGeoLocationsUpdateRequestBody' is not null or undefined
            assertParamExists('update', 'emergencyGeoLocationsUpdateRequestBody', emergencyGeoLocationsUpdateRequestBody)
            const localVarPath = `/EmergencyGeoLocations/Pbx.Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emergencyGeoLocationsUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmergencyGeoLocationsApi - functional programming interface
 * @export
 */
export const EmergencyGeoLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmergencyGeoLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from EmergencyGeoLocations
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmergencyGeoLocation($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxEmergencyGeoLocationCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmergencyGeoLocation($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmergencyGeoLocationsApi.listEmergencyGeoLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Update
         * @param {EmergencyGeoLocationsUpdateRequestBody} emergencyGeoLocationsUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(emergencyGeoLocationsUpdateRequestBody: EmergencyGeoLocationsUpdateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Update200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(emergencyGeoLocationsUpdateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmergencyGeoLocationsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmergencyGeoLocationsApi - factory interface
 * @export
 */
export const EmergencyGeoLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmergencyGeoLocationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from EmergencyGeoLocations
         * @param {EmergencyGeoLocationsApiListEmergencyGeoLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmergencyGeoLocation(requestParameters: EmergencyGeoLocationsApiListEmergencyGeoLocationRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxEmergencyGeoLocationCollectionResponse> {
            return localVarFp.listEmergencyGeoLocation(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Update
         * @param {EmergencyGeoLocationsApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: EmergencyGeoLocationsApiUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Update200Response> {
            return localVarFp.update(requestParameters.emergencyGeoLocationsUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listEmergencyGeoLocation operation in EmergencyGeoLocationsApi.
 * @export
 * @interface EmergencyGeoLocationsApiListEmergencyGeoLocationRequest
 */
export interface EmergencyGeoLocationsApiListEmergencyGeoLocationRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof EmergencyGeoLocationsApiListEmergencyGeoLocation
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for update operation in EmergencyGeoLocationsApi.
 * @export
 * @interface EmergencyGeoLocationsApiUpdateRequest
 */
export interface EmergencyGeoLocationsApiUpdateRequest {
    /**
     * Action parameters
     * @type {EmergencyGeoLocationsUpdateRequestBody}
     * @memberof EmergencyGeoLocationsApiUpdate
     */
    readonly emergencyGeoLocationsUpdateRequestBody: EmergencyGeoLocationsUpdateRequestBody
}

/**
 * EmergencyGeoLocationsApi - object-oriented interface
 * @export
 * @class EmergencyGeoLocationsApi
 * @extends {BaseAPI}
 */
export class EmergencyGeoLocationsApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from EmergencyGeoLocations
     * @param {EmergencyGeoLocationsApiListEmergencyGeoLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmergencyGeoLocationsApi
     */
    public listEmergencyGeoLocation(requestParameters: EmergencyGeoLocationsApiListEmergencyGeoLocationRequest = {}, options?: RawAxiosRequestConfig) {
        return EmergencyGeoLocationsApiFp(this.configuration).listEmergencyGeoLocation(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Update
     * @param {EmergencyGeoLocationsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmergencyGeoLocationsApi
     */
    public update(requestParameters: EmergencyGeoLocationsApiUpdateRequest, options?: RawAxiosRequestConfig) {
        return EmergencyGeoLocationsApiFp(this.configuration).update(requestParameters.emergencyGeoLocationsUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmergencyNotificationsSettingsApi - axios parameter creator
 * @export
 */
export const EmergencyNotificationsSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get EmergencyNotificationsSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmergencyNotificationsSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EmergencyNotificationsSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update EmergencyNotificationsSettings
         * @param {PbxEmergencyNotificationsSettings} pbxEmergencyNotificationsSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmergencyNotificationsSettings: async (pbxEmergencyNotificationsSettings: PbxEmergencyNotificationsSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxEmergencyNotificationsSettings' is not null or undefined
            assertParamExists('updateEmergencyNotificationsSettings', 'pbxEmergencyNotificationsSettings', pbxEmergencyNotificationsSettings)
            const localVarPath = `/EmergencyNotificationsSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxEmergencyNotificationsSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmergencyNotificationsSettingsApi - functional programming interface
 * @export
 */
export const EmergencyNotificationsSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmergencyNotificationsSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get EmergencyNotificationsSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmergencyNotificationsSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxEmergencyNotificationsSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmergencyNotificationsSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmergencyNotificationsSettingsApi.getEmergencyNotificationsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update EmergencyNotificationsSettings
         * @param {PbxEmergencyNotificationsSettings} pbxEmergencyNotificationsSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmergencyNotificationsSettings(pbxEmergencyNotificationsSettings: PbxEmergencyNotificationsSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmergencyNotificationsSettings(pbxEmergencyNotificationsSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmergencyNotificationsSettingsApi.updateEmergencyNotificationsSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmergencyNotificationsSettingsApi - factory interface
 * @export
 */
export const EmergencyNotificationsSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmergencyNotificationsSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get EmergencyNotificationsSettings
         * @param {EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmergencyNotificationsSettings(requestParameters: EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxEmergencyNotificationsSettings> {
            return localVarFp.getEmergencyNotificationsSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update EmergencyNotificationsSettings
         * @param {EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmergencyNotificationsSettings(requestParameters: EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateEmergencyNotificationsSettings(requestParameters.pbxEmergencyNotificationsSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEmergencyNotificationsSettings operation in EmergencyNotificationsSettingsApi.
 * @export
 * @interface EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest
 */
export interface EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateEmergencyNotificationsSettings operation in EmergencyNotificationsSettingsApi.
 * @export
 * @interface EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest
 */
export interface EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest {
    /**
     * New property values
     * @type {PbxEmergencyNotificationsSettings}
     * @memberof EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettings
     */
    readonly pbxEmergencyNotificationsSettings: PbxEmergencyNotificationsSettings
}

/**
 * EmergencyNotificationsSettingsApi - object-oriented interface
 * @export
 * @class EmergencyNotificationsSettingsApi
 * @extends {BaseAPI}
 */
export class EmergencyNotificationsSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get EmergencyNotificationsSettings
     * @param {EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmergencyNotificationsSettingsApi
     */
    public getEmergencyNotificationsSettings(requestParameters: EmergencyNotificationsSettingsApiGetEmergencyNotificationsSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return EmergencyNotificationsSettingsApiFp(this.configuration).getEmergencyNotificationsSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update EmergencyNotificationsSettings
     * @param {EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmergencyNotificationsSettingsApi
     */
    public updateEmergencyNotificationsSettings(requestParameters: EmergencyNotificationsSettingsApiUpdateEmergencyNotificationsSettingsRequest, options?: RawAxiosRequestConfig) {
        return EmergencyNotificationsSettingsApiFp(this.configuration).updateEmergencyNotificationsSettings(requestParameters.pbxEmergencyNotificationsSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventLogsApi - axios parameter creator
 * @export
 */
export const EventLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadEventLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEventLogs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EventLogs/Pbx.DownloadEventLogs()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from EventLogs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventLog: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EventLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PurgeEventLog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeEventLog: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/EventLogs/Pbx.PurgeEventLog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventLogsApi - functional programming interface
 * @export
 */
export const EventLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadEventLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadEventLogs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadEventLogs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventLogsApi.downloadEventLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from EventLogs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventLog($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxEventLogCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventLog($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventLogsApi.listEventLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PurgeEventLog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeEventLog(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeEventLog(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventLogsApi.purgeEventLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventLogsApi - factory interface
 * @export
 */
export const EventLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadEventLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEventLogs(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.downloadEventLogs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from EventLogs
         * @param {EventLogsApiListEventLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventLog(requestParameters: EventLogsApiListEventLogRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxEventLogCollectionResponse> {
            return localVarFp.listEventLog(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PurgeEventLog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeEventLog(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeEventLog(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listEventLog operation in EventLogsApi.
 * @export
 * @interface EventLogsApiListEventLogRequest
 */
export interface EventLogsApiListEventLogRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof EventLogsApiListEventLog
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof EventLogsApiListEventLog
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof EventLogsApiListEventLog
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof EventLogsApiListEventLog
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof EventLogsApiListEventLog
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof EventLogsApiListEventLog
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof EventLogsApiListEventLog
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof EventLogsApiListEventLog
     */
    readonly $expand?: Set<string>
}

/**
 * EventLogsApi - object-oriented interface
 * @export
 * @class EventLogsApi
 * @extends {BaseAPI}
 */
export class EventLogsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadEventLogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogsApi
     */
    public downloadEventLogs(options?: RawAxiosRequestConfig) {
        return EventLogsApiFp(this.configuration).downloadEventLogs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from EventLogs
     * @param {EventLogsApiListEventLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogsApi
     */
    public listEventLog(requestParameters: EventLogsApiListEventLogRequest = {}, options?: RawAxiosRequestConfig) {
        return EventLogsApiFp(this.configuration).listEventLog(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PurgeEventLog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogsApi
     */
    public purgeEventLog(options?: RawAxiosRequestConfig) {
        return EventLogsApiFp(this.configuration).purgeEventLog(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FaxApi - axios parameter creator
 * @export
 */
export const FaxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BulkFaxDelete
         * @param {FaxBulkFaxDeleteRequestBody} faxBulkFaxDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkFaxDelete: async (faxBulkFaxDeleteRequestBody: FaxBulkFaxDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faxBulkFaxDeleteRequestBody' is not null or undefined
            assertParamExists('bulkFaxDelete', 'faxBulkFaxDeleteRequestBody', faxBulkFaxDeleteRequestBody)
            const localVarPath = `/Fax/Pbx.BulkFaxDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faxBulkFaxDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to Fax
         * @param {PbxFax} pbxFax New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFax: async (pbxFax: PbxFax, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxFax' is not null or undefined
            assertParamExists('createFax', 'pbxFax', pbxFax)
            const localVarPath = `/Fax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFax, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Fax
         * @param {number} id The unique identifier of Fax
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFax: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFax', 'id', id)
            const localVarPath = `/Fax({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Fax by key
         * @param {number} id The unique identifier of Fax
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFax: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFax', 'id', id)
            const localVarPath = `/Fax({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getFaxByNumber', 'number', number)
            const localVarPath = `/Fax/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function InitFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initFax: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Fax/Pbx.InitFax()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Fax
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFax: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Fax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Fax
         * @param {number} id The unique identifier of Fax
         * @param {PbxFax} pbxFax New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFax: async (id: number, pbxFax: PbxFax, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFax', 'id', id)
            // verify required parameter 'pbxFax' is not null or undefined
            assertParamExists('updateFax', 'pbxFax', pbxFax)
            const localVarPath = `/Fax({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFax, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaxApi - functional programming interface
 * @export
 */
export const FaxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FaxApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkFaxDelete
         * @param {FaxBulkFaxDeleteRequestBody} faxBulkFaxDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkFaxDelete(faxBulkFaxDeleteRequestBody: FaxBulkFaxDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkFaxDelete(faxBulkFaxDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.bulkFaxDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to Fax
         * @param {PbxFax} pbxFax New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFax(pbxFax: PbxFax, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFax>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFax(pbxFax, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.createFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Fax
         * @param {number} id The unique identifier of Fax
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFax(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFax(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.deleteFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Fax by key
         * @param {number} id The unique identifier of Fax
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFax(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFax>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFax(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.getFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaxByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFax>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaxByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.getFaxByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function InitFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initFax(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFax>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initFax(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.initFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Fax
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFax($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFaxCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFax($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.listFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Fax
         * @param {number} id The unique identifier of Fax
         * @param {PbxFax} pbxFax New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFax(id: number, pbxFax: PbxFax, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFax(id, pbxFax, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxApi.updateFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FaxApi - factory interface
 * @export
 */
export const FaxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FaxApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkFaxDelete
         * @param {FaxApiBulkFaxDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkFaxDelete(requestParameters: FaxApiBulkFaxDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkFaxDelete(requestParameters.faxBulkFaxDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to Fax
         * @param {FaxApiCreateFaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFax(requestParameters: FaxApiCreateFaxRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFax> {
            return localVarFp.createFax(requestParameters.pbxFax, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Fax
         * @param {FaxApiDeleteFaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFax(requestParameters: FaxApiDeleteFaxRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFax(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Fax by key
         * @param {FaxApiGetFaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFax(requestParameters: FaxApiGetFaxRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFax> {
            return localVarFp.getFax(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {FaxApiGetFaxByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxByNumber(requestParameters: FaxApiGetFaxByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFax> {
            return localVarFp.getFaxByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function InitFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initFax(options?: RawAxiosRequestConfig): AxiosPromise<PbxFax> {
            return localVarFp.initFax(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Fax
         * @param {FaxApiListFaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFax(requestParameters: FaxApiListFaxRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFaxCollectionResponse> {
            return localVarFp.listFax(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Fax
         * @param {FaxApiUpdateFaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFax(requestParameters: FaxApiUpdateFaxRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFax(requestParameters.id, requestParameters.pbxFax, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkFaxDelete operation in FaxApi.
 * @export
 * @interface FaxApiBulkFaxDeleteRequest
 */
export interface FaxApiBulkFaxDeleteRequest {
    /**
     * Action parameters
     * @type {FaxBulkFaxDeleteRequestBody}
     * @memberof FaxApiBulkFaxDelete
     */
    readonly faxBulkFaxDeleteRequestBody: FaxBulkFaxDeleteRequestBody
}

/**
 * Request parameters for createFax operation in FaxApi.
 * @export
 * @interface FaxApiCreateFaxRequest
 */
export interface FaxApiCreateFaxRequest {
    /**
     * New entity
     * @type {PbxFax}
     * @memberof FaxApiCreateFax
     */
    readonly pbxFax: PbxFax
}

/**
 * Request parameters for deleteFax operation in FaxApi.
 * @export
 * @interface FaxApiDeleteFaxRequest
 */
export interface FaxApiDeleteFaxRequest {
    /**
     * The unique identifier of Fax
     * @type {number}
     * @memberof FaxApiDeleteFax
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof FaxApiDeleteFax
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getFax operation in FaxApi.
 * @export
 * @interface FaxApiGetFaxRequest
 */
export interface FaxApiGetFaxRequest {
    /**
     * The unique identifier of Fax
     * @type {number}
     * @memberof FaxApiGetFax
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FaxApiGetFax
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FaxApiGetFax
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getFaxByNumber operation in FaxApi.
 * @export
 * @interface FaxApiGetFaxByNumberRequest
 */
export interface FaxApiGetFaxByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof FaxApiGetFaxByNumber
     */
    readonly number: string
}

/**
 * Request parameters for listFax operation in FaxApi.
 * @export
 * @interface FaxApiListFaxRequest
 */
export interface FaxApiListFaxRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof FaxApiListFax
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof FaxApiListFax
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof FaxApiListFax
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof FaxApiListFax
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof FaxApiListFax
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof FaxApiListFax
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FaxApiListFax
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FaxApiListFax
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateFax operation in FaxApi.
 * @export
 * @interface FaxApiUpdateFaxRequest
 */
export interface FaxApiUpdateFaxRequest {
    /**
     * The unique identifier of Fax
     * @type {number}
     * @memberof FaxApiUpdateFax
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxFax}
     * @memberof FaxApiUpdateFax
     */
    readonly pbxFax: PbxFax
}

/**
 * FaxApi - object-oriented interface
 * @export
 * @class FaxApi
 * @extends {BaseAPI}
 */
export class FaxApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BulkFaxDelete
     * @param {FaxApiBulkFaxDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public bulkFaxDelete(requestParameters: FaxApiBulkFaxDeleteRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).bulkFaxDelete(requestParameters.faxBulkFaxDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to Fax
     * @param {FaxApiCreateFaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public createFax(requestParameters: FaxApiCreateFaxRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).createFax(requestParameters.pbxFax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Fax
     * @param {FaxApiDeleteFaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public deleteFax(requestParameters: FaxApiDeleteFaxRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).deleteFax(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Fax by key
     * @param {FaxApiGetFaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public getFax(requestParameters: FaxApiGetFaxRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).getFax(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {FaxApiGetFaxByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public getFaxByNumber(requestParameters: FaxApiGetFaxByNumberRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).getFaxByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function InitFax
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public initFax(options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).initFax(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Fax
     * @param {FaxApiListFaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public listFax(requestParameters: FaxApiListFaxRequest = {}, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).listFax(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Fax
     * @param {FaxApiUpdateFaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxApi
     */
    public updateFax(requestParameters: FaxApiUpdateFaxRequest, options?: RawAxiosRequestConfig) {
        return FaxApiFp(this.configuration).updateFax(requestParameters.id, requestParameters.pbxFax, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FaxServerSettingsApi - axios parameter creator
 * @export
 */
export const FaxServerSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action CleanUpFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanUpFax: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/FaxServerSettings/Pbx.CleanUpFax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFaxFilesSize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxFilesSize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/FaxServerSettings/Pbx.GetFaxFilesSize()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get FaxServerSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxServerSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/FaxServerSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update FaxServerSettings
         * @param {PbxFaxServerSettings} pbxFaxServerSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaxServerSettings: async (pbxFaxServerSettings: PbxFaxServerSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxFaxServerSettings' is not null or undefined
            assertParamExists('updateFaxServerSettings', 'pbxFaxServerSettings', pbxFaxServerSettings)
            const localVarPath = `/FaxServerSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFaxServerSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaxServerSettingsApi - functional programming interface
 * @export
 */
export const FaxServerSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FaxServerSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action CleanUpFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanUpFax(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanUpFax(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxServerSettingsApi.cleanUpFax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFaxFilesSize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaxFilesSize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFaxFilesSize200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaxFilesSize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxServerSettingsApi.getFaxFilesSize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get FaxServerSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaxServerSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFaxServerSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaxServerSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxServerSettingsApi.getFaxServerSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update FaxServerSettings
         * @param {PbxFaxServerSettings} pbxFaxServerSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFaxServerSettings(pbxFaxServerSettings: PbxFaxServerSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFaxServerSettings(pbxFaxServerSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FaxServerSettingsApi.updateFaxServerSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FaxServerSettingsApi - factory interface
 * @export
 */
export const FaxServerSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FaxServerSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action CleanUpFax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanUpFax(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cleanUpFax(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFaxFilesSize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxFilesSize(options?: RawAxiosRequestConfig): AxiosPromise<GetFaxFilesSize200Response> {
            return localVarFp.getFaxFilesSize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get FaxServerSettings
         * @param {FaxServerSettingsApiGetFaxServerSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaxServerSettings(requestParameters: FaxServerSettingsApiGetFaxServerSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFaxServerSettings> {
            return localVarFp.getFaxServerSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update FaxServerSettings
         * @param {FaxServerSettingsApiUpdateFaxServerSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaxServerSettings(requestParameters: FaxServerSettingsApiUpdateFaxServerSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFaxServerSettings(requestParameters.pbxFaxServerSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFaxServerSettings operation in FaxServerSettingsApi.
 * @export
 * @interface FaxServerSettingsApiGetFaxServerSettingsRequest
 */
export interface FaxServerSettingsApiGetFaxServerSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FaxServerSettingsApiGetFaxServerSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FaxServerSettingsApiGetFaxServerSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateFaxServerSettings operation in FaxServerSettingsApi.
 * @export
 * @interface FaxServerSettingsApiUpdateFaxServerSettingsRequest
 */
export interface FaxServerSettingsApiUpdateFaxServerSettingsRequest {
    /**
     * New property values
     * @type {PbxFaxServerSettings}
     * @memberof FaxServerSettingsApiUpdateFaxServerSettings
     */
    readonly pbxFaxServerSettings: PbxFaxServerSettings
}

/**
 * FaxServerSettingsApi - object-oriented interface
 * @export
 * @class FaxServerSettingsApi
 * @extends {BaseAPI}
 */
export class FaxServerSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action CleanUpFax
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxServerSettingsApi
     */
    public cleanUpFax(options?: RawAxiosRequestConfig) {
        return FaxServerSettingsApiFp(this.configuration).cleanUpFax(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFaxFilesSize
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxServerSettingsApi
     */
    public getFaxFilesSize(options?: RawAxiosRequestConfig) {
        return FaxServerSettingsApiFp(this.configuration).getFaxFilesSize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get FaxServerSettings
     * @param {FaxServerSettingsApiGetFaxServerSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxServerSettingsApi
     */
    public getFaxServerSettings(requestParameters: FaxServerSettingsApiGetFaxServerSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return FaxServerSettingsApiFp(this.configuration).getFaxServerSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update FaxServerSettings
     * @param {FaxServerSettingsApiUpdateFaxServerSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaxServerSettingsApi
     */
    public updateFaxServerSettings(requestParameters: FaxServerSettingsApiUpdateFaxServerSettingsRequest, options?: RawAxiosRequestConfig) {
        return FaxServerSettingsApiFp(this.configuration).updateFaxServerSettings(requestParameters.pbxFaxServerSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirewallApi - axios parameter creator
 * @export
 */
export const FirewallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Firewall
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallState: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firewall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetLastResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastResult: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firewall/Pbx.GetLastResult()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action StartCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firewall/Pbx.StartCheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action StopCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firewall/Pbx.StopCheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirewallApi - functional programming interface
 * @export
 */
export const FirewallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirewallApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Firewall
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallState($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirewallState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallState($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallApi.getFirewallState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetLastResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastResult(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastResult(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallApi.getLastResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action StartCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallApi.startCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action StopCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallApi.stopCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirewallApi - factory interface
 * @export
 */
export const FirewallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirewallApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Firewall
         * @param {FirewallApiGetFirewallStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallState(requestParameters: FirewallApiGetFirewallStateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFirewallState> {
            return localVarFp.getFirewallState(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetLastResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastResult(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.getLastResult(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action StartCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action StopCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCheck(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFirewallState operation in FirewallApi.
 * @export
 * @interface FirewallApiGetFirewallStateRequest
 */
export interface FirewallApiGetFirewallStateRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FirewallApiGetFirewallState
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FirewallApiGetFirewallState
     */
    readonly $expand?: Set<string>
}

/**
 * FirewallApi - object-oriented interface
 * @export
 * @class FirewallApi
 * @extends {BaseAPI}
 */
export class FirewallApi extends BaseAPI {
    /**
     * 
     * @summary Get Firewall
     * @param {FirewallApiGetFirewallStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallApi
     */
    public getFirewallState(requestParameters: FirewallApiGetFirewallStateRequest = {}, options?: RawAxiosRequestConfig) {
        return FirewallApiFp(this.configuration).getFirewallState(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetLastResult
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallApi
     */
    public getLastResult(options?: RawAxiosRequestConfig) {
        return FirewallApiFp(this.configuration).getLastResult(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action StartCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallApi
     */
    public startCheck(options?: RawAxiosRequestConfig) {
        return FirewallApiFp(this.configuration).startCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action StopCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallApi
     */
    public stopCheck(options?: RawAxiosRequestConfig) {
        return FirewallApiFp(this.configuration).stopCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirmwaresApi - axios parameter creator
 * @export
 */
export const FirmwaresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action CleanUp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanUp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firmwares/Pbx.CleanUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Firmwares
         * @param {string} id The unique identifier of Firmware
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirmware: async (id: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFirmware', 'id', id)
            const localVarPath = `/Firmwares({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirmwareState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirmwareState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firmwares/Pbx.GetFirmwareState()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Firmwares
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirmware: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Firmwares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PushFirmwareForPhones
         * @param {string} id The unique identifier of Firmware
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushFirmwareForPhones: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pushFirmwareForPhones', 'id', id)
            const localVarPath = `/Firmwares({Id})/Pbx.PushFirmwareForPhones`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirmwaresApi - functional programming interface
 * @export
 */
export const FirmwaresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirmwaresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action CleanUp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanUp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanUp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirmwaresApi.cleanUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Firmwares
         * @param {string} id The unique identifier of Firmware
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirmware(id: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirmware(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirmwaresApi.deleteFirmware']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirmwareState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirmwareState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirmwareState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirmwareState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirmwaresApi.getFirmwareState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Firmwares
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFirmware($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirmwareCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFirmware($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirmwaresApi.listFirmware']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PushFirmwareForPhones
         * @param {string} id The unique identifier of Firmware
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushFirmwareForPhones(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushFirmwareForPhones(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirmwaresApi.pushFirmwareForPhones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirmwaresApi - factory interface
 * @export
 */
export const FirmwaresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirmwaresApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action CleanUp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanUp(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cleanUp(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Firmwares
         * @param {FirmwaresApiDeleteFirmwareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirmware(requestParameters: FirmwaresApiDeleteFirmwareRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFirmware(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirmwareState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirmwareState(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirmwareState> {
            return localVarFp.getFirmwareState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Firmwares
         * @param {FirmwaresApiListFirmwareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirmware(requestParameters: FirmwaresApiListFirmwareRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFirmwareCollectionResponse> {
            return localVarFp.listFirmware(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PushFirmwareForPhones
         * @param {FirmwaresApiPushFirmwareForPhonesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushFirmwareForPhones(requestParameters: FirmwaresApiPushFirmwareForPhonesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushFirmwareForPhones(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteFirmware operation in FirmwaresApi.
 * @export
 * @interface FirmwaresApiDeleteFirmwareRequest
 */
export interface FirmwaresApiDeleteFirmwareRequest {
    /**
     * The unique identifier of Firmware
     * @type {string}
     * @memberof FirmwaresApiDeleteFirmware
     */
    readonly id: string

    /**
     * ETag
     * @type {string}
     * @memberof FirmwaresApiDeleteFirmware
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for listFirmware operation in FirmwaresApi.
 * @export
 * @interface FirmwaresApiListFirmwareRequest
 */
export interface FirmwaresApiListFirmwareRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FirmwaresApiListFirmware
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for pushFirmwareForPhones operation in FirmwaresApi.
 * @export
 * @interface FirmwaresApiPushFirmwareForPhonesRequest
 */
export interface FirmwaresApiPushFirmwareForPhonesRequest {
    /**
     * The unique identifier of Firmware
     * @type {string}
     * @memberof FirmwaresApiPushFirmwareForPhones
     */
    readonly id: string
}

/**
 * FirmwaresApi - object-oriented interface
 * @export
 * @class FirmwaresApi
 * @extends {BaseAPI}
 */
export class FirmwaresApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action CleanUp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirmwaresApi
     */
    public cleanUp(options?: RawAxiosRequestConfig) {
        return FirmwaresApiFp(this.configuration).cleanUp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Firmwares
     * @param {FirmwaresApiDeleteFirmwareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirmwaresApi
     */
    public deleteFirmware(requestParameters: FirmwaresApiDeleteFirmwareRequest, options?: RawAxiosRequestConfig) {
        return FirmwaresApiFp(this.configuration).deleteFirmware(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirmwareState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirmwaresApi
     */
    public getFirmwareState(options?: RawAxiosRequestConfig) {
        return FirmwaresApiFp(this.configuration).getFirmwareState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Firmwares
     * @param {FirmwaresApiListFirmwareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirmwaresApi
     */
    public listFirmware(requestParameters: FirmwaresApiListFirmwareRequest = {}, options?: RawAxiosRequestConfig) {
        return FirmwaresApiFp(this.configuration).listFirmware(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PushFirmwareForPhones
     * @param {FirmwaresApiPushFirmwareForPhonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirmwaresApi
     */
    public pushFirmwareForPhones(requestParameters: FirmwaresApiPushFirmwareForPhonesRequest, options?: RawAxiosRequestConfig) {
        return FirmwaresApiFp(this.configuration).pushFirmwareForPhones(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FxsApi - axios parameter creator
 * @export
 */
export const FxsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Fxs
         * @param {PbxFxs} pbxFxs New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFxs: async (pbxFxs: PbxFxs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxFxs' is not null or undefined
            assertParamExists('createFxs', 'pbxFxs', pbxFxs)
            const localVarPath = `/Fxs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFxs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Fxs
         * @param {string} macAddress The unique identifier of Fxs
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFxs: async (macAddress: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'macAddress' is not null or undefined
            assertParamExists('deleteFxs', 'macAddress', macAddress)
            const localVarPath = `/Fxs({MacAddress})`
                .replace(`{${"MacAddress"}}`, encodeURIComponent(String(macAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Fxs by key
         * @param {string} macAddress The unique identifier of Fxs
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFxs: async (macAddress: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'macAddress' is not null or undefined
            assertParamExists('getFxs', 'macAddress', macAddress)
            const localVarPath = `/Fxs({MacAddress})`
                .replace(`{${"MacAddress"}}`, encodeURIComponent(String(macAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Fxs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFxs: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Fxs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RegenerateWebCredentials
         * @param {string} macAddress The unique identifier of Fxs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateWebCredentials: async (macAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'macAddress' is not null or undefined
            assertParamExists('regenerateWebCredentials', 'macAddress', macAddress)
            const localVarPath = `/Fxs({MacAddress})/Pbx.RegenerateWebCredentials`
                .replace(`{${"MacAddress"}}`, encodeURIComponent(String(macAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Fxs
         * @param {string} macAddress The unique identifier of Fxs
         * @param {PbxFxs} pbxFxs New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFxs: async (macAddress: string, pbxFxs: PbxFxs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'macAddress' is not null or undefined
            assertParamExists('updateFxs', 'macAddress', macAddress)
            // verify required parameter 'pbxFxs' is not null or undefined
            assertParamExists('updateFxs', 'pbxFxs', pbxFxs)
            const localVarPath = `/Fxs({MacAddress})`
                .replace(`{${"MacAddress"}}`, encodeURIComponent(String(macAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFxs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FxsApi - functional programming interface
 * @export
 */
export const FxsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FxsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Fxs
         * @param {PbxFxs} pbxFxs New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFxs(pbxFxs: PbxFxs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFxs(pbxFxs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.createFxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Fxs
         * @param {string} macAddress The unique identifier of Fxs
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFxs(macAddress: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFxs(macAddress, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.deleteFxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Fxs by key
         * @param {string} macAddress The unique identifier of Fxs
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFxs(macAddress: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFxs(macAddress, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.getFxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Fxs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFxs($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxsCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFxs($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.listFxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RegenerateWebCredentials
         * @param {string} macAddress The unique identifier of Fxs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateWebCredentials(macAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegenerateWebCredentials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateWebCredentials(macAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.regenerateWebCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Fxs
         * @param {string} macAddress The unique identifier of Fxs
         * @param {PbxFxs} pbxFxs New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFxs(macAddress: string, pbxFxs: PbxFxs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFxs(macAddress, pbxFxs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsApi.updateFxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FxsApi - factory interface
 * @export
 */
export const FxsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FxsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Fxs
         * @param {FxsApiCreateFxsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFxs(requestParameters: FxsApiCreateFxsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxs> {
            return localVarFp.createFxs(requestParameters.pbxFxs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Fxs
         * @param {FxsApiDeleteFxsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFxs(requestParameters: FxsApiDeleteFxsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFxs(requestParameters.macAddress, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Fxs by key
         * @param {FxsApiGetFxsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFxs(requestParameters: FxsApiGetFxsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxs> {
            return localVarFp.getFxs(requestParameters.macAddress, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Fxs
         * @param {FxsApiListFxsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFxs(requestParameters: FxsApiListFxsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxsCollectionResponse> {
            return localVarFp.listFxs(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RegenerateWebCredentials
         * @param {FxsApiRegenerateWebCredentialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateWebCredentials(requestParameters: FxsApiRegenerateWebCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<RegenerateWebCredentials200Response> {
            return localVarFp.regenerateWebCredentials(requestParameters.macAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Fxs
         * @param {FxsApiUpdateFxsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFxs(requestParameters: FxsApiUpdateFxsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFxs(requestParameters.macAddress, requestParameters.pbxFxs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFxs operation in FxsApi.
 * @export
 * @interface FxsApiCreateFxsRequest
 */
export interface FxsApiCreateFxsRequest {
    /**
     * New entity
     * @type {PbxFxs}
     * @memberof FxsApiCreateFxs
     */
    readonly pbxFxs: PbxFxs
}

/**
 * Request parameters for deleteFxs operation in FxsApi.
 * @export
 * @interface FxsApiDeleteFxsRequest
 */
export interface FxsApiDeleteFxsRequest {
    /**
     * The unique identifier of Fxs
     * @type {string}
     * @memberof FxsApiDeleteFxs
     */
    readonly macAddress: string

    /**
     * ETag
     * @type {string}
     * @memberof FxsApiDeleteFxs
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getFxs operation in FxsApi.
 * @export
 * @interface FxsApiGetFxsRequest
 */
export interface FxsApiGetFxsRequest {
    /**
     * The unique identifier of Fxs
     * @type {string}
     * @memberof FxsApiGetFxs
     */
    readonly macAddress: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FxsApiGetFxs
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FxsApiGetFxs
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listFxs operation in FxsApi.
 * @export
 * @interface FxsApiListFxsRequest
 */
export interface FxsApiListFxsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof FxsApiListFxs
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof FxsApiListFxs
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof FxsApiListFxs
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof FxsApiListFxs
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof FxsApiListFxs
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof FxsApiListFxs
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FxsApiListFxs
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FxsApiListFxs
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for regenerateWebCredentials operation in FxsApi.
 * @export
 * @interface FxsApiRegenerateWebCredentialsRequest
 */
export interface FxsApiRegenerateWebCredentialsRequest {
    /**
     * The unique identifier of Fxs
     * @type {string}
     * @memberof FxsApiRegenerateWebCredentials
     */
    readonly macAddress: string
}

/**
 * Request parameters for updateFxs operation in FxsApi.
 * @export
 * @interface FxsApiUpdateFxsRequest
 */
export interface FxsApiUpdateFxsRequest {
    /**
     * The unique identifier of Fxs
     * @type {string}
     * @memberof FxsApiUpdateFxs
     */
    readonly macAddress: string

    /**
     * New property values
     * @type {PbxFxs}
     * @memberof FxsApiUpdateFxs
     */
    readonly pbxFxs: PbxFxs
}

/**
 * FxsApi - object-oriented interface
 * @export
 * @class FxsApi
 * @extends {BaseAPI}
 */
export class FxsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Fxs
     * @param {FxsApiCreateFxsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public createFxs(requestParameters: FxsApiCreateFxsRequest, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).createFxs(requestParameters.pbxFxs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Fxs
     * @param {FxsApiDeleteFxsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public deleteFxs(requestParameters: FxsApiDeleteFxsRequest, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).deleteFxs(requestParameters.macAddress, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Fxs by key
     * @param {FxsApiGetFxsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public getFxs(requestParameters: FxsApiGetFxsRequest, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).getFxs(requestParameters.macAddress, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Fxs
     * @param {FxsApiListFxsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public listFxs(requestParameters: FxsApiListFxsRequest = {}, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).listFxs(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RegenerateWebCredentials
     * @param {FxsApiRegenerateWebCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public regenerateWebCredentials(requestParameters: FxsApiRegenerateWebCredentialsRequest, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).regenerateWebCredentials(requestParameters.macAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Fxs
     * @param {FxsApiUpdateFxsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsApi
     */
    public updateFxs(requestParameters: FxsApiUpdateFxsRequest, options?: RawAxiosRequestConfig) {
        return FxsApiFp(this.configuration).updateFxs(requestParameters.macAddress, requestParameters.pbxFxs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FxsTemplatesApi - axios parameter creator
 * @export
 */
export const FxsTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to FxsTemplates
         * @param {PbxFxsTemplate} pbxFxsTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFxsTemplate: async (pbxFxsTemplate: PbxFxsTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxFxsTemplate' is not null or undefined
            assertParamExists('createFxsTemplate', 'pbxFxsTemplate', pbxFxsTemplate)
            const localVarPath = `/FxsTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFxsTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from FxsTemplates
         * @param {string} id The unique identifier of FxsTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFxsTemplate: async (id: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFxsTemplate', 'id', id)
            const localVarPath = `/FxsTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from FxsTemplates by key
         * @param {string} id The unique identifier of FxsTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFxsTemplate: async (id: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFxsTemplate', 'id', id)
            const localVarPath = `/FxsTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from FxsTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFxsTemplate: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/FxsTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in FxsTemplates
         * @param {string} id The unique identifier of FxsTemplate
         * @param {PbxFxsTemplate} pbxFxsTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFxsTemplate: async (id: string, pbxFxsTemplate: PbxFxsTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFxsTemplate', 'id', id)
            // verify required parameter 'pbxFxsTemplate' is not null or undefined
            assertParamExists('updateFxsTemplate', 'pbxFxsTemplate', pbxFxsTemplate)
            const localVarPath = `/FxsTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxFxsTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FxsTemplatesApi - functional programming interface
 * @export
 */
export const FxsTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FxsTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to FxsTemplates
         * @param {PbxFxsTemplate} pbxFxsTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFxsTemplate(pbxFxsTemplate: PbxFxsTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxsTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFxsTemplate(pbxFxsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsTemplatesApi.createFxsTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from FxsTemplates
         * @param {string} id The unique identifier of FxsTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFxsTemplate(id: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFxsTemplate(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsTemplatesApi.deleteFxsTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from FxsTemplates by key
         * @param {string} id The unique identifier of FxsTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFxsTemplate(id: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxsTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFxsTemplate(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsTemplatesApi.getFxsTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from FxsTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFxsTemplate($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFxsTemplateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFxsTemplate($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsTemplatesApi.listFxsTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in FxsTemplates
         * @param {string} id The unique identifier of FxsTemplate
         * @param {PbxFxsTemplate} pbxFxsTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFxsTemplate(id: string, pbxFxsTemplate: PbxFxsTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFxsTemplate(id, pbxFxsTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FxsTemplatesApi.updateFxsTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FxsTemplatesApi - factory interface
 * @export
 */
export const FxsTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FxsTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to FxsTemplates
         * @param {FxsTemplatesApiCreateFxsTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFxsTemplate(requestParameters: FxsTemplatesApiCreateFxsTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxsTemplate> {
            return localVarFp.createFxsTemplate(requestParameters.pbxFxsTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from FxsTemplates
         * @param {FxsTemplatesApiDeleteFxsTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFxsTemplate(requestParameters: FxsTemplatesApiDeleteFxsTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFxsTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from FxsTemplates by key
         * @param {FxsTemplatesApiGetFxsTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFxsTemplate(requestParameters: FxsTemplatesApiGetFxsTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxsTemplate> {
            return localVarFp.getFxsTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from FxsTemplates
         * @param {FxsTemplatesApiListFxsTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFxsTemplate(requestParameters: FxsTemplatesApiListFxsTemplateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxFxsTemplateCollectionResponse> {
            return localVarFp.listFxsTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in FxsTemplates
         * @param {FxsTemplatesApiUpdateFxsTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFxsTemplate(requestParameters: FxsTemplatesApiUpdateFxsTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateFxsTemplate(requestParameters.id, requestParameters.pbxFxsTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createFxsTemplate operation in FxsTemplatesApi.
 * @export
 * @interface FxsTemplatesApiCreateFxsTemplateRequest
 */
export interface FxsTemplatesApiCreateFxsTemplateRequest {
    /**
     * New entity
     * @type {PbxFxsTemplate}
     * @memberof FxsTemplatesApiCreateFxsTemplate
     */
    readonly pbxFxsTemplate: PbxFxsTemplate
}

/**
 * Request parameters for deleteFxsTemplate operation in FxsTemplatesApi.
 * @export
 * @interface FxsTemplatesApiDeleteFxsTemplateRequest
 */
export interface FxsTemplatesApiDeleteFxsTemplateRequest {
    /**
     * The unique identifier of FxsTemplate
     * @type {string}
     * @memberof FxsTemplatesApiDeleteFxsTemplate
     */
    readonly id: string

    /**
     * ETag
     * @type {string}
     * @memberof FxsTemplatesApiDeleteFxsTemplate
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getFxsTemplate operation in FxsTemplatesApi.
 * @export
 * @interface FxsTemplatesApiGetFxsTemplateRequest
 */
export interface FxsTemplatesApiGetFxsTemplateRequest {
    /**
     * The unique identifier of FxsTemplate
     * @type {string}
     * @memberof FxsTemplatesApiGetFxsTemplate
     */
    readonly id: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FxsTemplatesApiGetFxsTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FxsTemplatesApiGetFxsTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listFxsTemplate operation in FxsTemplatesApi.
 * @export
 * @interface FxsTemplatesApiListFxsTemplateRequest
 */
export interface FxsTemplatesApiListFxsTemplateRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof FxsTemplatesApiListFxsTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateFxsTemplate operation in FxsTemplatesApi.
 * @export
 * @interface FxsTemplatesApiUpdateFxsTemplateRequest
 */
export interface FxsTemplatesApiUpdateFxsTemplateRequest {
    /**
     * The unique identifier of FxsTemplate
     * @type {string}
     * @memberof FxsTemplatesApiUpdateFxsTemplate
     */
    readonly id: string

    /**
     * New property values
     * @type {PbxFxsTemplate}
     * @memberof FxsTemplatesApiUpdateFxsTemplate
     */
    readonly pbxFxsTemplate: PbxFxsTemplate
}

/**
 * FxsTemplatesApi - object-oriented interface
 * @export
 * @class FxsTemplatesApi
 * @extends {BaseAPI}
 */
export class FxsTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to FxsTemplates
     * @param {FxsTemplatesApiCreateFxsTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsTemplatesApi
     */
    public createFxsTemplate(requestParameters: FxsTemplatesApiCreateFxsTemplateRequest, options?: RawAxiosRequestConfig) {
        return FxsTemplatesApiFp(this.configuration).createFxsTemplate(requestParameters.pbxFxsTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from FxsTemplates
     * @param {FxsTemplatesApiDeleteFxsTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsTemplatesApi
     */
    public deleteFxsTemplate(requestParameters: FxsTemplatesApiDeleteFxsTemplateRequest, options?: RawAxiosRequestConfig) {
        return FxsTemplatesApiFp(this.configuration).deleteFxsTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from FxsTemplates by key
     * @param {FxsTemplatesApiGetFxsTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsTemplatesApi
     */
    public getFxsTemplate(requestParameters: FxsTemplatesApiGetFxsTemplateRequest, options?: RawAxiosRequestConfig) {
        return FxsTemplatesApiFp(this.configuration).getFxsTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from FxsTemplates
     * @param {FxsTemplatesApiListFxsTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsTemplatesApi
     */
    public listFxsTemplate(requestParameters: FxsTemplatesApiListFxsTemplateRequest = {}, options?: RawAxiosRequestConfig) {
        return FxsTemplatesApiFp(this.configuration).listFxsTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in FxsTemplates
     * @param {FxsTemplatesApiUpdateFxsTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FxsTemplatesApi
     */
    public updateFxsTemplate(requestParameters: FxsTemplatesApiUpdateFxsTemplateRequest, options?: RawAxiosRequestConfig) {
        return FxsTemplatesApiFp(this.configuration).updateFxsTemplate(requestParameters.id, requestParameters.pbxFxsTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeneralSettingsForAppsApi - axios parameter creator
 * @export
 */
export const GeneralSettingsForAppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get GeneralSettingsForApps
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSettingsForApps: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GeneralSettingsForApps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update GeneralSettingsForApps
         * @param {PbxGeneralSettingsForApps} pbxGeneralSettingsForApps New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralSettingsForApps: async (pbxGeneralSettingsForApps: PbxGeneralSettingsForApps, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxGeneralSettingsForApps' is not null or undefined
            assertParamExists('updateGeneralSettingsForApps', 'pbxGeneralSettingsForApps', pbxGeneralSettingsForApps)
            const localVarPath = `/GeneralSettingsForApps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGeneralSettingsForApps, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralSettingsForAppsApi - functional programming interface
 * @export
 */
export const GeneralSettingsForAppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralSettingsForAppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get GeneralSettingsForApps
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralSettingsForApps($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGeneralSettingsForApps>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralSettingsForApps($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSettingsForAppsApi.getGeneralSettingsForApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update GeneralSettingsForApps
         * @param {PbxGeneralSettingsForApps} pbxGeneralSettingsForApps New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGeneralSettingsForApps(pbxGeneralSettingsForApps: PbxGeneralSettingsForApps, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGeneralSettingsForApps(pbxGeneralSettingsForApps, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSettingsForAppsApi.updateGeneralSettingsForApps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeneralSettingsForAppsApi - factory interface
 * @export
 */
export const GeneralSettingsForAppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralSettingsForAppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get GeneralSettingsForApps
         * @param {GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSettingsForApps(requestParameters: GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGeneralSettingsForApps> {
            return localVarFp.getGeneralSettingsForApps(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update GeneralSettingsForApps
         * @param {GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralSettingsForApps(requestParameters: GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGeneralSettingsForApps(requestParameters.pbxGeneralSettingsForApps, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGeneralSettingsForApps operation in GeneralSettingsForAppsApi.
 * @export
 * @interface GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest
 */
export interface GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GeneralSettingsForAppsApiGetGeneralSettingsForApps
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GeneralSettingsForAppsApiGetGeneralSettingsForApps
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateGeneralSettingsForApps operation in GeneralSettingsForAppsApi.
 * @export
 * @interface GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest
 */
export interface GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest {
    /**
     * New property values
     * @type {PbxGeneralSettingsForApps}
     * @memberof GeneralSettingsForAppsApiUpdateGeneralSettingsForApps
     */
    readonly pbxGeneralSettingsForApps: PbxGeneralSettingsForApps
}

/**
 * GeneralSettingsForAppsApi - object-oriented interface
 * @export
 * @class GeneralSettingsForAppsApi
 * @extends {BaseAPI}
 */
export class GeneralSettingsForAppsApi extends BaseAPI {
    /**
     * 
     * @summary Get GeneralSettingsForApps
     * @param {GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralSettingsForAppsApi
     */
    public getGeneralSettingsForApps(requestParameters: GeneralSettingsForAppsApiGetGeneralSettingsForAppsRequest = {}, options?: RawAxiosRequestConfig) {
        return GeneralSettingsForAppsApiFp(this.configuration).getGeneralSettingsForApps(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update GeneralSettingsForApps
     * @param {GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralSettingsForAppsApi
     */
    public updateGeneralSettingsForApps(requestParameters: GeneralSettingsForAppsApiUpdateGeneralSettingsForAppsRequest, options?: RawAxiosRequestConfig) {
        return GeneralSettingsForAppsApiFp(this.configuration).updateGeneralSettingsForApps(requestParameters.pbxGeneralSettingsForApps, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeneralSettingsForPbxApi - axios parameter creator
 * @export
 */
export const GeneralSettingsForPbxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get GeneralSettingsForPbx
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSettingsForPbx: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GeneralSettingsForPbx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update GeneralSettingsForPbx
         * @param {PbxGeneralSettingsForPbx} pbxGeneralSettingsForPbx New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralSettingsForPbx: async (pbxGeneralSettingsForPbx: PbxGeneralSettingsForPbx, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxGeneralSettingsForPbx' is not null or undefined
            assertParamExists('updateGeneralSettingsForPbx', 'pbxGeneralSettingsForPbx', pbxGeneralSettingsForPbx)
            const localVarPath = `/GeneralSettingsForPbx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGeneralSettingsForPbx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralSettingsForPbxApi - functional programming interface
 * @export
 */
export const GeneralSettingsForPbxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralSettingsForPbxApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get GeneralSettingsForPbx
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralSettingsForPbx($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGeneralSettingsForPbx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralSettingsForPbx($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSettingsForPbxApi.getGeneralSettingsForPbx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update GeneralSettingsForPbx
         * @param {PbxGeneralSettingsForPbx} pbxGeneralSettingsForPbx New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGeneralSettingsForPbx(pbxGeneralSettingsForPbx: PbxGeneralSettingsForPbx, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGeneralSettingsForPbx(pbxGeneralSettingsForPbx, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSettingsForPbxApi.updateGeneralSettingsForPbx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeneralSettingsForPbxApi - factory interface
 * @export
 */
export const GeneralSettingsForPbxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralSettingsForPbxApiFp(configuration)
    return {
        /**
         * 
         * @summary Get GeneralSettingsForPbx
         * @param {GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSettingsForPbx(requestParameters: GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGeneralSettingsForPbx> {
            return localVarFp.getGeneralSettingsForPbx(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update GeneralSettingsForPbx
         * @param {GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralSettingsForPbx(requestParameters: GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGeneralSettingsForPbx(requestParameters.pbxGeneralSettingsForPbx, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGeneralSettingsForPbx operation in GeneralSettingsForPbxApi.
 * @export
 * @interface GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest
 */
export interface GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GeneralSettingsForPbxApiGetGeneralSettingsForPbx
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GeneralSettingsForPbxApiGetGeneralSettingsForPbx
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateGeneralSettingsForPbx operation in GeneralSettingsForPbxApi.
 * @export
 * @interface GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest
 */
export interface GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest {
    /**
     * New property values
     * @type {PbxGeneralSettingsForPbx}
     * @memberof GeneralSettingsForPbxApiUpdateGeneralSettingsForPbx
     */
    readonly pbxGeneralSettingsForPbx: PbxGeneralSettingsForPbx
}

/**
 * GeneralSettingsForPbxApi - object-oriented interface
 * @export
 * @class GeneralSettingsForPbxApi
 * @extends {BaseAPI}
 */
export class GeneralSettingsForPbxApi extends BaseAPI {
    /**
     * 
     * @summary Get GeneralSettingsForPbx
     * @param {GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralSettingsForPbxApi
     */
    public getGeneralSettingsForPbx(requestParameters: GeneralSettingsForPbxApiGetGeneralSettingsForPbxRequest = {}, options?: RawAxiosRequestConfig) {
        return GeneralSettingsForPbxApiFp(this.configuration).getGeneralSettingsForPbx(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update GeneralSettingsForPbx
     * @param {GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralSettingsForPbxApi
     */
    public updateGeneralSettingsForPbx(requestParameters: GeneralSettingsForPbxApiUpdateGeneralSettingsForPbxRequest, options?: RawAxiosRequestConfig) {
        return GeneralSettingsForPbxApiFp(this.configuration).updateGeneralSettingsForPbx(requestParameters.pbxGeneralSettingsForPbx, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleSettingsApi - axios parameter creator
 * @export
 */
export const GoogleSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get GoogleSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GoogleSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update GoogleSettings
         * @param {PbxGoogleSettings} pbxGoogleSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleSettings: async (pbxGoogleSettings: PbxGoogleSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxGoogleSettings' is not null or undefined
            assertParamExists('updateGoogleSettings', 'pbxGoogleSettings', pbxGoogleSettings)
            const localVarPath = `/GoogleSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGoogleSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleSettingsApi - functional programming interface
 * @export
 */
export const GoogleSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get GoogleSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGoogleSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSettingsApi.getGoogleSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update GoogleSettings
         * @param {PbxGoogleSettings} pbxGoogleSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleSettings(pbxGoogleSettings: PbxGoogleSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleSettings(pbxGoogleSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSettingsApi.updateGoogleSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleSettingsApi - factory interface
 * @export
 */
export const GoogleSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get GoogleSettings
         * @param {GoogleSettingsApiGetGoogleSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleSettings(requestParameters: GoogleSettingsApiGetGoogleSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGoogleSettings> {
            return localVarFp.getGoogleSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update GoogleSettings
         * @param {GoogleSettingsApiUpdateGoogleSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleSettings(requestParameters: GoogleSettingsApiUpdateGoogleSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGoogleSettings(requestParameters.pbxGoogleSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGoogleSettings operation in GoogleSettingsApi.
 * @export
 * @interface GoogleSettingsApiGetGoogleSettingsRequest
 */
export interface GoogleSettingsApiGetGoogleSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GoogleSettingsApiGetGoogleSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GoogleSettingsApiGetGoogleSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateGoogleSettings operation in GoogleSettingsApi.
 * @export
 * @interface GoogleSettingsApiUpdateGoogleSettingsRequest
 */
export interface GoogleSettingsApiUpdateGoogleSettingsRequest {
    /**
     * New property values
     * @type {PbxGoogleSettings}
     * @memberof GoogleSettingsApiUpdateGoogleSettings
     */
    readonly pbxGoogleSettings: PbxGoogleSettings
}

/**
 * GoogleSettingsApi - object-oriented interface
 * @export
 * @class GoogleSettingsApi
 * @extends {BaseAPI}
 */
export class GoogleSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get GoogleSettings
     * @param {GoogleSettingsApiGetGoogleSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSettingsApi
     */
    public getGoogleSettings(requestParameters: GoogleSettingsApiGetGoogleSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return GoogleSettingsApiFp(this.configuration).getGoogleSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update GoogleSettings
     * @param {GoogleSettingsApiUpdateGoogleSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSettingsApi
     */
    public updateGoogleSettings(requestParameters: GoogleSettingsApiUpdateGoogleSettingsRequest, options?: RawAxiosRequestConfig) {
        return GoogleSettingsApiFp(this.configuration).updateGoogleSettings(requestParameters.pbxGoogleSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Groups
         * @param {PbxGroup} pbxGroup New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (pbxGroup: PbxGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxGroup' is not null or undefined
            assertParamExists('createGroup', 'pbxGroup', pbxGroup)
            const localVarPath = `/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyById
         * @param {GroupsDeleteCompanyByIdRequestBody} groupsDeleteCompanyByIdRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyById: async (groupsDeleteCompanyByIdRequestBody: GroupsDeleteCompanyByIdRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupsDeleteCompanyByIdRequestBody' is not null or undefined
            assertParamExists('deleteCompanyById', 'groupsDeleteCompanyByIdRequestBody', groupsDeleteCompanyByIdRequestBody)
            const localVarPath = `/Groups/Pbx.DeleteCompanyById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupsDeleteCompanyByIdRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyByNumber
         * @param {GroupsDeleteCompanyByNumberRequestBody} groupsDeleteCompanyByNumberRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyByNumber: async (groupsDeleteCompanyByNumberRequestBody: GroupsDeleteCompanyByNumberRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupsDeleteCompanyByNumberRequestBody' is not null or undefined
            assertParamExists('deleteCompanyByNumber', 'groupsDeleteCompanyByNumberRequestBody', groupsDeleteCompanyByNumberRequestBody)
            const localVarPath = `/Groups/Pbx.DeleteCompanyByNumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupsDeleteCompanyByNumberRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Groups
         * @param {number} id The unique identifier of Group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/Groups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Groups by key
         * @param {number} id The unique identifier of Group
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/Groups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {number} id The unique identifier of Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictions: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRestrictions', 'id', id)
            const localVarPath = `/Groups({Id})/Pbx.GetRestrictions()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action LinkGroupPartner
         * @param {GroupsLinkGroupPartnerRequestBody} groupsLinkGroupPartnerRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkGroupPartner: async (groupsLinkGroupPartnerRequestBody: GroupsLinkGroupPartnerRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupsLinkGroupPartnerRequestBody' is not null or undefined
            assertParamExists('linkGroupPartner', 'groupsLinkGroupPartnerRequestBody', groupsLinkGroupPartnerRequestBody)
            const localVarPath = `/Groups/Pbx.LinkGroupPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupsLinkGroupPartnerRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Groups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Members from Groups
         * @param {number} id The unique identifier of Group
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listMembers', 'id', id)
            const localVarPath = `/Groups({Id})/Members`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rights from Groups
         * @param {number} id The unique identifier of Group
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRights: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRights', 'id', id)
            const localVarPath = `/Groups({Id})/Rights`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ReplaceGroupLicenseKey
         * @param {GroupsReplaceGroupLicenseKeyRequestBody} groupsReplaceGroupLicenseKeyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceGroupLicenseKey: async (groupsReplaceGroupLicenseKeyRequestBody: GroupsReplaceGroupLicenseKeyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupsReplaceGroupLicenseKeyRequestBody' is not null or undefined
            assertParamExists('replaceGroupLicenseKey', 'groupsReplaceGroupLicenseKeyRequestBody', groupsReplaceGroupLicenseKeyRequestBody)
            const localVarPath = `/Groups/Pbx.ReplaceGroupLicenseKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupsReplaceGroupLicenseKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UnlinkGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkGroupPartner: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Groups/Pbx.UnlinkGroupPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Groups
         * @param {number} id The unique identifier of Group
         * @param {PbxGroup} pbxGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: number, pbxGroup: PbxGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            // verify required parameter 'pbxGroup' is not null or undefined
            assertParamExists('updateGroup', 'pbxGroup', pbxGroup)
            const localVarPath = `/Groups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Groups
         * @param {PbxGroup} pbxGroup New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(pbxGroup: PbxGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(pbxGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyById
         * @param {GroupsDeleteCompanyByIdRequestBody} groupsDeleteCompanyByIdRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompanyById(groupsDeleteCompanyByIdRequestBody: GroupsDeleteCompanyByIdRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanyById(groupsDeleteCompanyByIdRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteCompanyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyByNumber
         * @param {GroupsDeleteCompanyByNumberRequestBody} groupsDeleteCompanyByNumberRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompanyByNumber(groupsDeleteCompanyByNumberRequestBody: GroupsDeleteCompanyByNumberRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanyByNumber(groupsDeleteCompanyByNumberRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteCompanyByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Groups
         * @param {number} id The unique identifier of Group
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Groups by key
         * @param {number} id The unique identifier of Group
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {number} id The unique identifier of Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestrictions(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRestrictions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestrictions(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action LinkGroupPartner
         * @param {GroupsLinkGroupPartnerRequestBody} groupsLinkGroupPartnerRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkGroupPartner(groupsLinkGroupPartnerRequestBody: GroupsLinkGroupPartnerRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkGroupPartner(groupsLinkGroupPartnerRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.linkGroupPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Groups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Members from Groups
         * @param {number} id The unique identifier of Group
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rights from Groups
         * @param {number} id The unique identifier of Group
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRights(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRightsCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRights(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ReplaceGroupLicenseKey
         * @param {GroupsReplaceGroupLicenseKeyRequestBody} groupsReplaceGroupLicenseKeyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceGroupLicenseKey(groupsReplaceGroupLicenseKeyRequestBody: GroupsReplaceGroupLicenseKeyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceGroupLicenseKey(groupsReplaceGroupLicenseKeyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.replaceGroupLicenseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UnlinkGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkGroupPartner(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkGroupPartner(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.unlinkGroupPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Groups
         * @param {number} id The unique identifier of Group
         * @param {PbxGroup} pbxGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: number, pbxGroup: PbxGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, pbxGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Groups
         * @param {GroupsApiCreateGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(requestParameters: GroupsApiCreateGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxGroup> {
            return localVarFp.createGroup(requestParameters.pbxGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyById
         * @param {GroupsApiDeleteCompanyByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyById(requestParameters: GroupsApiDeleteCompanyByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCompanyById(requestParameters.groupsDeleteCompanyByIdRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeleteCompanyByNumber
         * @param {GroupsApiDeleteCompanyByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyByNumber(requestParameters: GroupsApiDeleteCompanyByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCompanyByNumber(requestParameters.groupsDeleteCompanyByNumberRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Groups
         * @param {GroupsApiDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(requestParameters: GroupsApiDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Groups by key
         * @param {GroupsApiGetGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(requestParameters: GroupsApiGetGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxGroup> {
            return localVarFp.getGroup(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {GroupsApiGetRestrictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictions(requestParameters: GroupsApiGetRestrictionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRestrictions> {
            return localVarFp.getRestrictions(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action LinkGroupPartner
         * @param {GroupsApiLinkGroupPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkGroupPartner(requestParameters: GroupsApiLinkGroupPartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.linkGroupPartner(requestParameters.groupsLinkGroupPartnerRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Groups
         * @param {GroupsApiListGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(requestParameters: GroupsApiListGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGroupCollectionResponse> {
            return localVarFp.listGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Members from Groups
         * @param {GroupsApiListMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(requestParameters: GroupsApiListMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserGroupCollectionResponse> {
            return localVarFp.listMembers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rights from Groups
         * @param {GroupsApiListRightsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRights(requestParameters: GroupsApiListRightsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRightsCollectionResponse> {
            return localVarFp.listRights(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ReplaceGroupLicenseKey
         * @param {GroupsApiReplaceGroupLicenseKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceGroupLicenseKey(requestParameters: GroupsApiReplaceGroupLicenseKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceGroupLicenseKey(requestParameters.groupsReplaceGroupLicenseKeyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UnlinkGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkGroupPartner(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlinkGroupPartner(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Groups
         * @param {GroupsApiUpdateGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(requestParameters: GroupsApiUpdateGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGroup(requestParameters.id, requestParameters.pbxGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiCreateGroupRequest
 */
export interface GroupsApiCreateGroupRequest {
    /**
     * New entity
     * @type {PbxGroup}
     * @memberof GroupsApiCreateGroup
     */
    readonly pbxGroup: PbxGroup
}

/**
 * Request parameters for deleteCompanyById operation in GroupsApi.
 * @export
 * @interface GroupsApiDeleteCompanyByIdRequest
 */
export interface GroupsApiDeleteCompanyByIdRequest {
    /**
     * Action parameters
     * @type {GroupsDeleteCompanyByIdRequestBody}
     * @memberof GroupsApiDeleteCompanyById
     */
    readonly groupsDeleteCompanyByIdRequestBody: GroupsDeleteCompanyByIdRequestBody
}

/**
 * Request parameters for deleteCompanyByNumber operation in GroupsApi.
 * @export
 * @interface GroupsApiDeleteCompanyByNumberRequest
 */
export interface GroupsApiDeleteCompanyByNumberRequest {
    /**
     * Action parameters
     * @type {GroupsDeleteCompanyByNumberRequestBody}
     * @memberof GroupsApiDeleteCompanyByNumber
     */
    readonly groupsDeleteCompanyByNumberRequestBody: GroupsDeleteCompanyByNumberRequestBody
}

/**
 * Request parameters for deleteGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiDeleteGroupRequest
 */
export interface GroupsApiDeleteGroupRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiDeleteGroup
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof GroupsApiDeleteGroup
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiGetGroupRequest
 */
export interface GroupsApiGetGroupRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiGetGroup
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GroupsApiGetGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GroupsApiGetGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getRestrictions operation in GroupsApi.
 * @export
 * @interface GroupsApiGetRestrictionsRequest
 */
export interface GroupsApiGetRestrictionsRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiGetRestrictions
     */
    readonly id: number
}

/**
 * Request parameters for linkGroupPartner operation in GroupsApi.
 * @export
 * @interface GroupsApiLinkGroupPartnerRequest
 */
export interface GroupsApiLinkGroupPartnerRequest {
    /**
     * Action parameters
     * @type {GroupsLinkGroupPartnerRequestBody}
     * @memberof GroupsApiLinkGroupPartner
     */
    readonly groupsLinkGroupPartnerRequestBody: GroupsLinkGroupPartnerRequestBody
}

/**
 * Request parameters for listGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiListGroupRequest
 */
export interface GroupsApiListGroupRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof GroupsApiListGroup
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof GroupsApiListGroup
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof GroupsApiListGroup
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof GroupsApiListGroup
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof GroupsApiListGroup
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof GroupsApiListGroup
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GroupsApiListGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GroupsApiListGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listMembers operation in GroupsApi.
 * @export
 * @interface GroupsApiListMembersRequest
 */
export interface GroupsApiListMembersRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiListMembers
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof GroupsApiListMembers
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof GroupsApiListMembers
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof GroupsApiListMembers
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof GroupsApiListMembers
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof GroupsApiListMembers
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof GroupsApiListMembers
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GroupsApiListMembers
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GroupsApiListMembers
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listRights operation in GroupsApi.
 * @export
 * @interface GroupsApiListRightsRequest
 */
export interface GroupsApiListRightsRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiListRights
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof GroupsApiListRights
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof GroupsApiListRights
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof GroupsApiListRights
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof GroupsApiListRights
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof GroupsApiListRights
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof GroupsApiListRights
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof GroupsApiListRights
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof GroupsApiListRights
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for replaceGroupLicenseKey operation in GroupsApi.
 * @export
 * @interface GroupsApiReplaceGroupLicenseKeyRequest
 */
export interface GroupsApiReplaceGroupLicenseKeyRequest {
    /**
     * Action parameters
     * @type {GroupsReplaceGroupLicenseKeyRequestBody}
     * @memberof GroupsApiReplaceGroupLicenseKey
     */
    readonly groupsReplaceGroupLicenseKeyRequestBody: GroupsReplaceGroupLicenseKeyRequestBody
}

/**
 * Request parameters for updateGroup operation in GroupsApi.
 * @export
 * @interface GroupsApiUpdateGroupRequest
 */
export interface GroupsApiUpdateGroupRequest {
    /**
     * The unique identifier of Group
     * @type {number}
     * @memberof GroupsApiUpdateGroup
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxGroup}
     * @memberof GroupsApiUpdateGroup
     */
    readonly pbxGroup: PbxGroup
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Groups
     * @param {GroupsApiCreateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(requestParameters: GroupsApiCreateGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(requestParameters.pbxGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeleteCompanyById
     * @param {GroupsApiDeleteCompanyByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteCompanyById(requestParameters: GroupsApiDeleteCompanyByIdRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteCompanyById(requestParameters.groupsDeleteCompanyByIdRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeleteCompanyByNumber
     * @param {GroupsApiDeleteCompanyByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteCompanyByNumber(requestParameters: GroupsApiDeleteCompanyByNumberRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteCompanyByNumber(requestParameters.groupsDeleteCompanyByNumberRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Groups
     * @param {GroupsApiDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(requestParameters: GroupsApiDeleteGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Groups by key
     * @param {GroupsApiGetGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(requestParameters: GroupsApiGetGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRestrictions
     * @param {GroupsApiGetRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getRestrictions(requestParameters: GroupsApiGetRestrictionsRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getRestrictions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action LinkGroupPartner
     * @param {GroupsApiLinkGroupPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public linkGroupPartner(requestParameters: GroupsApiLinkGroupPartnerRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).linkGroupPartner(requestParameters.groupsLinkGroupPartnerRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Groups
     * @param {GroupsApiListGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroup(requestParameters: GroupsApiListGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Members from Groups
     * @param {GroupsApiListMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listMembers(requestParameters: GroupsApiListMembersRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listMembers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rights from Groups
     * @param {GroupsApiListRightsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listRights(requestParameters: GroupsApiListRightsRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listRights(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ReplaceGroupLicenseKey
     * @param {GroupsApiReplaceGroupLicenseKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public replaceGroupLicenseKey(requestParameters: GroupsApiReplaceGroupLicenseKeyRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).replaceGroupLicenseKey(requestParameters.groupsReplaceGroupLicenseKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UnlinkGroupPartner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public unlinkGroupPartner(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).unlinkGroupPartner(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Groups
     * @param {GroupsApiUpdateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(requestParameters: GroupsApiUpdateGroupRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroup(requestParameters.id, requestParameters.pbxGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HotelServicesApi - axios parameter creator
 * @export
 */
export const HotelServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get HotelServices
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotelServices: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/HotelServices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update HotelServices
         * @param {PbxHotelServices} pbxHotelServices New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHotelServices: async (pbxHotelServices: PbxHotelServices, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxHotelServices' is not null or undefined
            assertParamExists('updateHotelServices', 'pbxHotelServices', pbxHotelServices)
            const localVarPath = `/HotelServices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxHotelServices, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotelServicesApi - functional programming interface
 * @export
 */
export const HotelServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotelServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get HotelServices
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHotelServices($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxHotelServices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHotelServices($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelServicesApi.getHotelServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update HotelServices
         * @param {PbxHotelServices} pbxHotelServices New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHotelServices(pbxHotelServices: PbxHotelServices, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHotelServices(pbxHotelServices, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HotelServicesApi.updateHotelServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HotelServicesApi - factory interface
 * @export
 */
export const HotelServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotelServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get HotelServices
         * @param {HotelServicesApiGetHotelServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotelServices(requestParameters: HotelServicesApiGetHotelServicesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxHotelServices> {
            return localVarFp.getHotelServices(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update HotelServices
         * @param {HotelServicesApiUpdateHotelServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHotelServices(requestParameters: HotelServicesApiUpdateHotelServicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateHotelServices(requestParameters.pbxHotelServices, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHotelServices operation in HotelServicesApi.
 * @export
 * @interface HotelServicesApiGetHotelServicesRequest
 */
export interface HotelServicesApiGetHotelServicesRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof HotelServicesApiGetHotelServices
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof HotelServicesApiGetHotelServices
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateHotelServices operation in HotelServicesApi.
 * @export
 * @interface HotelServicesApiUpdateHotelServicesRequest
 */
export interface HotelServicesApiUpdateHotelServicesRequest {
    /**
     * New property values
     * @type {PbxHotelServices}
     * @memberof HotelServicesApiUpdateHotelServices
     */
    readonly pbxHotelServices: PbxHotelServices
}

/**
 * HotelServicesApi - object-oriented interface
 * @export
 * @class HotelServicesApi
 * @extends {BaseAPI}
 */
export class HotelServicesApi extends BaseAPI {
    /**
     * 
     * @summary Get HotelServices
     * @param {HotelServicesApiGetHotelServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelServicesApi
     */
    public getHotelServices(requestParameters: HotelServicesApiGetHotelServicesRequest = {}, options?: RawAxiosRequestConfig) {
        return HotelServicesApiFp(this.configuration).getHotelServices(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update HotelServices
     * @param {HotelServicesApiUpdateHotelServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelServicesApi
     */
    public updateHotelServices(requestParameters: HotelServicesApiUpdateHotelServicesRequest, options?: RawAxiosRequestConfig) {
        return HotelServicesApiFp(this.configuration).updateHotelServices(requestParameters.pbxHotelServices, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InboundRulesApi - axios parameter creator
 * @export
 */
export const InboundRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BulkInboundRulesDelete
         * @param {InboundRulesBulkInboundRulesDeleteRequestBody} inboundRulesBulkInboundRulesDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkInboundRulesDelete: async (inboundRulesBulkInboundRulesDeleteRequestBody: InboundRulesBulkInboundRulesDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inboundRulesBulkInboundRulesDeleteRequestBody' is not null or undefined
            assertParamExists('bulkInboundRulesDelete', 'inboundRulesBulkInboundRulesDeleteRequestBody', inboundRulesBulkInboundRulesDeleteRequestBody)
            const localVarPath = `/InboundRules/Pbx.BulkInboundRulesDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inboundRulesBulkInboundRulesDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to InboundRules
         * @param {PbxInboundRule} pbxInboundRule New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundRule: async (pbxInboundRule: PbxInboundRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxInboundRule' is not null or undefined
            assertParamExists('createInboundRule', 'pbxInboundRule', pbxInboundRule)
            const localVarPath = `/InboundRules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxInboundRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from InboundRules
         * @param {number} id The unique identifier of InboundRule
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboundRule: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInboundRule', 'id', id)
            const localVarPath = `/InboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from InboundRules by key
         * @param {number} id The unique identifier of InboundRule
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundRule: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInboundRule', 'id', id)
            const localVarPath = `/InboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from InboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInboundRule: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/InboundRules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in InboundRules
         * @param {number} id The unique identifier of InboundRule
         * @param {PbxInboundRule} pbxInboundRule New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInboundRule: async (id: number, pbxInboundRule: PbxInboundRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInboundRule', 'id', id)
            // verify required parameter 'pbxInboundRule' is not null or undefined
            assertParamExists('updateInboundRule', 'pbxInboundRule', pbxInboundRule)
            const localVarPath = `/InboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxInboundRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboundRulesApi - functional programming interface
 * @export
 */
export const InboundRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InboundRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkInboundRulesDelete
         * @param {InboundRulesBulkInboundRulesDeleteRequestBody} inboundRulesBulkInboundRulesDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkInboundRulesDelete(inboundRulesBulkInboundRulesDeleteRequestBody: InboundRulesBulkInboundRulesDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkInboundRulesDelete(inboundRulesBulkInboundRulesDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.bulkInboundRulesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to InboundRules
         * @param {PbxInboundRule} pbxInboundRule New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInboundRule(pbxInboundRule: PbxInboundRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxInboundRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInboundRule(pbxInboundRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.createInboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from InboundRules
         * @param {number} id The unique identifier of InboundRule
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInboundRule(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInboundRule(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.deleteInboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from InboundRules by key
         * @param {number} id The unique identifier of InboundRule
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundRule(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxInboundRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundRule(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.getInboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from InboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInboundRule($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxInboundRuleCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInboundRule($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.listInboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in InboundRules
         * @param {number} id The unique identifier of InboundRule
         * @param {PbxInboundRule} pbxInboundRule New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInboundRule(id: number, pbxInboundRule: PbxInboundRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInboundRule(id, pbxInboundRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboundRulesApi.updateInboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InboundRulesApi - factory interface
 * @export
 */
export const InboundRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InboundRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkInboundRulesDelete
         * @param {InboundRulesApiBulkInboundRulesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkInboundRulesDelete(requestParameters: InboundRulesApiBulkInboundRulesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkInboundRulesDelete(requestParameters.inboundRulesBulkInboundRulesDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to InboundRules
         * @param {InboundRulesApiCreateInboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboundRule(requestParameters: InboundRulesApiCreateInboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxInboundRule> {
            return localVarFp.createInboundRule(requestParameters.pbxInboundRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from InboundRules
         * @param {InboundRulesApiDeleteInboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInboundRule(requestParameters: InboundRulesApiDeleteInboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInboundRule(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from InboundRules by key
         * @param {InboundRulesApiGetInboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundRule(requestParameters: InboundRulesApiGetInboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxInboundRule> {
            return localVarFp.getInboundRule(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from InboundRules
         * @param {InboundRulesApiListInboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInboundRule(requestParameters: InboundRulesApiListInboundRuleRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxInboundRuleCollectionResponse> {
            return localVarFp.listInboundRule(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in InboundRules
         * @param {InboundRulesApiUpdateInboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInboundRule(requestParameters: InboundRulesApiUpdateInboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateInboundRule(requestParameters.id, requestParameters.pbxInboundRule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkInboundRulesDelete operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiBulkInboundRulesDeleteRequest
 */
export interface InboundRulesApiBulkInboundRulesDeleteRequest {
    /**
     * Action parameters
     * @type {InboundRulesBulkInboundRulesDeleteRequestBody}
     * @memberof InboundRulesApiBulkInboundRulesDelete
     */
    readonly inboundRulesBulkInboundRulesDeleteRequestBody: InboundRulesBulkInboundRulesDeleteRequestBody
}

/**
 * Request parameters for createInboundRule operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiCreateInboundRuleRequest
 */
export interface InboundRulesApiCreateInboundRuleRequest {
    /**
     * New entity
     * @type {PbxInboundRule}
     * @memberof InboundRulesApiCreateInboundRule
     */
    readonly pbxInboundRule: PbxInboundRule
}

/**
 * Request parameters for deleteInboundRule operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiDeleteInboundRuleRequest
 */
export interface InboundRulesApiDeleteInboundRuleRequest {
    /**
     * The unique identifier of InboundRule
     * @type {number}
     * @memberof InboundRulesApiDeleteInboundRule
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof InboundRulesApiDeleteInboundRule
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getInboundRule operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiGetInboundRuleRequest
 */
export interface InboundRulesApiGetInboundRuleRequest {
    /**
     * The unique identifier of InboundRule
     * @type {number}
     * @memberof InboundRulesApiGetInboundRule
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof InboundRulesApiGetInboundRule
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof InboundRulesApiGetInboundRule
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listInboundRule operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiListInboundRuleRequest
 */
export interface InboundRulesApiListInboundRuleRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof InboundRulesApiListInboundRule
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateInboundRule operation in InboundRulesApi.
 * @export
 * @interface InboundRulesApiUpdateInboundRuleRequest
 */
export interface InboundRulesApiUpdateInboundRuleRequest {
    /**
     * The unique identifier of InboundRule
     * @type {number}
     * @memberof InboundRulesApiUpdateInboundRule
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxInboundRule}
     * @memberof InboundRulesApiUpdateInboundRule
     */
    readonly pbxInboundRule: PbxInboundRule
}

/**
 * InboundRulesApi - object-oriented interface
 * @export
 * @class InboundRulesApi
 * @extends {BaseAPI}
 */
export class InboundRulesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BulkInboundRulesDelete
     * @param {InboundRulesApiBulkInboundRulesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public bulkInboundRulesDelete(requestParameters: InboundRulesApiBulkInboundRulesDeleteRequest, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).bulkInboundRulesDelete(requestParameters.inboundRulesBulkInboundRulesDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to InboundRules
     * @param {InboundRulesApiCreateInboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public createInboundRule(requestParameters: InboundRulesApiCreateInboundRuleRequest, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).createInboundRule(requestParameters.pbxInboundRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from InboundRules
     * @param {InboundRulesApiDeleteInboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public deleteInboundRule(requestParameters: InboundRulesApiDeleteInboundRuleRequest, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).deleteInboundRule(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from InboundRules by key
     * @param {InboundRulesApiGetInboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public getInboundRule(requestParameters: InboundRulesApiGetInboundRuleRequest, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).getInboundRule(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from InboundRules
     * @param {InboundRulesApiListInboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public listInboundRule(requestParameters: InboundRulesApiListInboundRuleRequest = {}, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).listInboundRule(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in InboundRules
     * @param {InboundRulesApiUpdateInboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboundRulesApi
     */
    public updateInboundRule(requestParameters: InboundRulesApiUpdateInboundRuleRequest, options?: RawAxiosRequestConfig) {
        return InboundRulesApiFp(this.configuration).updateInboundRule(requestParameters.id, requestParameters.pbxInboundRule, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseStatusApi - axios parameter creator
 * @export
 */
export const LicenseStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action EditLicenseInfo
         * @param {LicenseStatusEditLicenseInfoRequestBody} licenseStatusEditLicenseInfoRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLicenseInfo: async (licenseStatusEditLicenseInfoRequestBody: LicenseStatusEditLicenseInfoRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseStatusEditLicenseInfoRequestBody' is not null or undefined
            assertParamExists('editLicenseInfo', 'licenseStatusEditLicenseInfoRequestBody', licenseStatusEditLicenseInfoRequestBody)
            const localVarPath = `/LicenseStatus/Pbx.EditLicenseInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseStatusEditLicenseInfoRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get LicenseStatus
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LicenseStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action LinkPartner
         * @param {LicenseStatusLinkPartnerRequestBody} licenseStatusLinkPartnerRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPartner: async (licenseStatusLinkPartnerRequestBody: LicenseStatusLinkPartnerRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseStatusLinkPartnerRequestBody' is not null or undefined
            assertParamExists('linkPartner', 'licenseStatusLinkPartnerRequestBody', licenseStatusLinkPartnerRequestBody)
            const localVarPath = `/LicenseStatus/Pbx.LinkPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseStatusLinkPartnerRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function PartnerInfo
         * @param {string} resellerId Usage: resellerId&#x3D;{resellerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerInfo: async (resellerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resellerId' is not null or undefined
            assertParamExists('partnerInfo', 'resellerId', resellerId)
            const localVarPath = `/LicenseStatus/Pbx.PartnerInfo(resellerId={resellerId})`
                .replace(`{${"resellerId"}}`, encodeURIComponent(String(resellerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RefreshLicenseStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LicenseStatus/Pbx.RefreshLicenseStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ReplaceLicenseKey
         * @param {LicenseStatusReplaceLicenseKeyRequestBody} licenseStatusReplaceLicenseKeyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceLicenseKey: async (licenseStatusReplaceLicenseKeyRequestBody: LicenseStatusReplaceLicenseKeyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseStatusReplaceLicenseKeyRequestBody' is not null or undefined
            assertParamExists('replaceLicenseKey', 'licenseStatusReplaceLicenseKeyRequestBody', licenseStatusReplaceLicenseKeyRequestBody)
            const localVarPath = `/LicenseStatus/Pbx.ReplaceLicenseKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(licenseStatusReplaceLicenseKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UnlinkPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPartner: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LicenseStatus/Pbx.UnlinkPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseStatusApi - functional programming interface
 * @export
 */
export const LicenseStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action EditLicenseInfo
         * @param {LicenseStatusEditLicenseInfoRequestBody} licenseStatusEditLicenseInfoRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLicenseInfo(licenseStatusEditLicenseInfoRequestBody: LicenseStatusEditLicenseInfoRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLicenseInfo(licenseStatusEditLicenseInfoRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.editLicenseInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get LicenseStatus
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseStatus($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxLicenseStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseStatus($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.getLicenseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action LinkPartner
         * @param {LicenseStatusLinkPartnerRequestBody} licenseStatusLinkPartnerRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPartner(licenseStatusLinkPartnerRequestBody: LicenseStatusLinkPartnerRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkPartner(licenseStatusLinkPartnerRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.linkPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function PartnerInfo
         * @param {string} resellerId Usage: resellerId&#x3D;{resellerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerInfo(resellerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxResellerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerInfo(resellerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.partnerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RefreshLicenseStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLicenseStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLicenseStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.refreshLicenseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ReplaceLicenseKey
         * @param {LicenseStatusReplaceLicenseKeyRequestBody} licenseStatusReplaceLicenseKeyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceLicenseKey(licenseStatusReplaceLicenseKeyRequestBody: LicenseStatusReplaceLicenseKeyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceLicenseKey(licenseStatusReplaceLicenseKeyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.replaceLicenseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UnlinkPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPartner(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkPartner(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseStatusApi.unlinkPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseStatusApi - factory interface
 * @export
 */
export const LicenseStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseStatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action EditLicenseInfo
         * @param {LicenseStatusApiEditLicenseInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLicenseInfo(requestParameters: LicenseStatusApiEditLicenseInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editLicenseInfo(requestParameters.licenseStatusEditLicenseInfoRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get LicenseStatus
         * @param {LicenseStatusApiGetLicenseStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseStatus(requestParameters: LicenseStatusApiGetLicenseStatusRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxLicenseStatus> {
            return localVarFp.getLicenseStatus(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action LinkPartner
         * @param {LicenseStatusApiLinkPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPartner(requestParameters: LicenseStatusApiLinkPartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.linkPartner(requestParameters.licenseStatusLinkPartnerRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function PartnerInfo
         * @param {LicenseStatusApiPartnerInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerInfo(requestParameters: LicenseStatusApiPartnerInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxResellerInfo> {
            return localVarFp.partnerInfo(requestParameters.resellerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RefreshLicenseStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStatus(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.refreshLicenseStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ReplaceLicenseKey
         * @param {LicenseStatusApiReplaceLicenseKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceLicenseKey(requestParameters: LicenseStatusApiReplaceLicenseKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceLicenseKey(requestParameters.licenseStatusReplaceLicenseKeyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UnlinkPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPartner(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlinkPartner(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for editLicenseInfo operation in LicenseStatusApi.
 * @export
 * @interface LicenseStatusApiEditLicenseInfoRequest
 */
export interface LicenseStatusApiEditLicenseInfoRequest {
    /**
     * Action parameters
     * @type {LicenseStatusEditLicenseInfoRequestBody}
     * @memberof LicenseStatusApiEditLicenseInfo
     */
    readonly licenseStatusEditLicenseInfoRequestBody: LicenseStatusEditLicenseInfoRequestBody
}

/**
 * Request parameters for getLicenseStatus operation in LicenseStatusApi.
 * @export
 * @interface LicenseStatusApiGetLicenseStatusRequest
 */
export interface LicenseStatusApiGetLicenseStatusRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof LicenseStatusApiGetLicenseStatus
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof LicenseStatusApiGetLicenseStatus
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for linkPartner operation in LicenseStatusApi.
 * @export
 * @interface LicenseStatusApiLinkPartnerRequest
 */
export interface LicenseStatusApiLinkPartnerRequest {
    /**
     * Action parameters
     * @type {LicenseStatusLinkPartnerRequestBody}
     * @memberof LicenseStatusApiLinkPartner
     */
    readonly licenseStatusLinkPartnerRequestBody: LicenseStatusLinkPartnerRequestBody
}

/**
 * Request parameters for partnerInfo operation in LicenseStatusApi.
 * @export
 * @interface LicenseStatusApiPartnerInfoRequest
 */
export interface LicenseStatusApiPartnerInfoRequest {
    /**
     * Usage: resellerId&#x3D;{resellerId}
     * @type {string}
     * @memberof LicenseStatusApiPartnerInfo
     */
    readonly resellerId: string
}

/**
 * Request parameters for replaceLicenseKey operation in LicenseStatusApi.
 * @export
 * @interface LicenseStatusApiReplaceLicenseKeyRequest
 */
export interface LicenseStatusApiReplaceLicenseKeyRequest {
    /**
     * Action parameters
     * @type {LicenseStatusReplaceLicenseKeyRequestBody}
     * @memberof LicenseStatusApiReplaceLicenseKey
     */
    readonly licenseStatusReplaceLicenseKeyRequestBody: LicenseStatusReplaceLicenseKeyRequestBody
}

/**
 * LicenseStatusApi - object-oriented interface
 * @export
 * @class LicenseStatusApi
 * @extends {BaseAPI}
 */
export class LicenseStatusApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action EditLicenseInfo
     * @param {LicenseStatusApiEditLicenseInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public editLicenseInfo(requestParameters: LicenseStatusApiEditLicenseInfoRequest, options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).editLicenseInfo(requestParameters.licenseStatusEditLicenseInfoRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get LicenseStatus
     * @param {LicenseStatusApiGetLicenseStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public getLicenseStatus(requestParameters: LicenseStatusApiGetLicenseStatusRequest = {}, options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).getLicenseStatus(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action LinkPartner
     * @param {LicenseStatusApiLinkPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public linkPartner(requestParameters: LicenseStatusApiLinkPartnerRequest, options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).linkPartner(requestParameters.licenseStatusLinkPartnerRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function PartnerInfo
     * @param {LicenseStatusApiPartnerInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public partnerInfo(requestParameters: LicenseStatusApiPartnerInfoRequest, options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).partnerInfo(requestParameters.resellerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RefreshLicenseStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public refreshLicenseStatus(options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).refreshLicenseStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ReplaceLicenseKey
     * @param {LicenseStatusApiReplaceLicenseKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public replaceLicenseKey(requestParameters: LicenseStatusApiReplaceLicenseKeyRequest, options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).replaceLicenseKey(requestParameters.licenseStatusReplaceLicenseKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UnlinkPartner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseStatusApi
     */
    public unlinkPartner(options?: RawAxiosRequestConfig) {
        return LicenseStatusApiFp(this.configuration).unlinkPartner(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LoggingSettingsApi - axios parameter creator
 * @export
 */
export const LoggingSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get LoggingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggingSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LoggingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update LoggingSettings
         * @param {PbxLoggingSettings} pbxLoggingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggingSettings: async (pbxLoggingSettings: PbxLoggingSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxLoggingSettings' is not null or undefined
            assertParamExists('updateLoggingSettings', 'pbxLoggingSettings', pbxLoggingSettings)
            const localVarPath = `/LoggingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxLoggingSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoggingSettingsApi - functional programming interface
 * @export
 */
export const LoggingSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoggingSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get LoggingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggingSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxLoggingSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoggingSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoggingSettingsApi.getLoggingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update LoggingSettings
         * @param {PbxLoggingSettings} pbxLoggingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoggingSettings(pbxLoggingSettings: PbxLoggingSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoggingSettings(pbxLoggingSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoggingSettingsApi.updateLoggingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LoggingSettingsApi - factory interface
 * @export
 */
export const LoggingSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoggingSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get LoggingSettings
         * @param {LoggingSettingsApiGetLoggingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggingSettings(requestParameters: LoggingSettingsApiGetLoggingSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxLoggingSettings> {
            return localVarFp.getLoggingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update LoggingSettings
         * @param {LoggingSettingsApiUpdateLoggingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggingSettings(requestParameters: LoggingSettingsApiUpdateLoggingSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateLoggingSettings(requestParameters.pbxLoggingSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLoggingSettings operation in LoggingSettingsApi.
 * @export
 * @interface LoggingSettingsApiGetLoggingSettingsRequest
 */
export interface LoggingSettingsApiGetLoggingSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof LoggingSettingsApiGetLoggingSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof LoggingSettingsApiGetLoggingSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateLoggingSettings operation in LoggingSettingsApi.
 * @export
 * @interface LoggingSettingsApiUpdateLoggingSettingsRequest
 */
export interface LoggingSettingsApiUpdateLoggingSettingsRequest {
    /**
     * New property values
     * @type {PbxLoggingSettings}
     * @memberof LoggingSettingsApiUpdateLoggingSettings
     */
    readonly pbxLoggingSettings: PbxLoggingSettings
}

/**
 * LoggingSettingsApi - object-oriented interface
 * @export
 * @class LoggingSettingsApi
 * @extends {BaseAPI}
 */
export class LoggingSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get LoggingSettings
     * @param {LoggingSettingsApiGetLoggingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoggingSettingsApi
     */
    public getLoggingSettings(requestParameters: LoggingSettingsApiGetLoggingSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return LoggingSettingsApiFp(this.configuration).getLoggingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update LoggingSettings
     * @param {LoggingSettingsApiUpdateLoggingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoggingSettingsApi
     */
    public updateLoggingSettings(requestParameters: LoggingSettingsApiUpdateLoggingSettingsRequest, options?: RawAxiosRequestConfig) {
        return LoggingSettingsApiFp(this.configuration).updateLoggingSettings(requestParameters.pbxLoggingSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Microsoft365IntegrationApi - axios parameter creator
 * @export
 */
export const Microsoft365IntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action AuthorizePresence
         * @param {Microsoft365IntegrationAuthorizePresenceRequestBody} microsoft365IntegrationAuthorizePresenceRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizePresence: async (microsoft365IntegrationAuthorizePresenceRequestBody: Microsoft365IntegrationAuthorizePresenceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microsoft365IntegrationAuthorizePresenceRequestBody' is not null or undefined
            assertParamExists('authorizePresence', 'microsoft365IntegrationAuthorizePresenceRequestBody', microsoft365IntegrationAuthorizePresenceRequestBody)
            const localVarPath = `/Microsoft365Integration/Pbx.AuthorizePresence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(microsoft365IntegrationAuthorizePresenceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeauthorizePresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorizePresence: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration/Pbx.DeauthorizePresence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMicrosoft365Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365Directory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration/Pbx.GetMicrosoft365Directory()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Microsoft365Integration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365Integration: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMicrosoftAccessToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoftAccessToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration/Pbx.GetMicrosoftAccessToken()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetUsers
         * @param {Microsoft365IntegrationGetUsersRequestBody} microsoft365IntegrationGetUsersRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (microsoft365IntegrationGetUsersRequestBody: Microsoft365IntegrationGetUsersRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microsoft365IntegrationGetUsersRequestBody' is not null or undefined
            assertParamExists('getUsers', 'microsoft365IntegrationGetUsersRequestBody', microsoft365IntegrationGetUsersRequestBody)
            const localVarPath = `/Microsoft365Integration/Pbx.GetUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(microsoft365IntegrationGetUsersRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetUsersByPrincipalNames
         * @param {Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody} microsoft365IntegrationGetUsersByPrincipalNamesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByPrincipalNames: async (microsoft365IntegrationGetUsersByPrincipalNamesRequestBody: Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microsoft365IntegrationGetUsersByPrincipalNamesRequestBody' is not null or undefined
            assertParamExists('getUsersByPrincipalNames', 'microsoft365IntegrationGetUsersByPrincipalNamesRequestBody', microsoft365IntegrationGetUsersByPrincipalNamesRequestBody)
            const localVarPath = `/Microsoft365Integration/Pbx.GetUsersByPrincipalNames`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action TestPresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPresence: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration/Pbx.TestPresence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function TestSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365Integration/Pbx.TestSubscription()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Microsoft365Integration
         * @param {PbxMicrosoft365Integration} pbxMicrosoft365Integration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMicrosoft365Integration: async (pbxMicrosoft365Integration: PbxMicrosoft365Integration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxMicrosoft365Integration' is not null or undefined
            assertParamExists('updateMicrosoft365Integration', 'pbxMicrosoft365Integration', pbxMicrosoft365Integration)
            const localVarPath = `/Microsoft365Integration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxMicrosoft365Integration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Microsoft365IntegrationApi - functional programming interface
 * @export
 */
export const Microsoft365IntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Microsoft365IntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action AuthorizePresence
         * @param {Microsoft365IntegrationAuthorizePresenceRequestBody} microsoft365IntegrationAuthorizePresenceRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizePresence(microsoft365IntegrationAuthorizePresenceRequestBody: Microsoft365IntegrationAuthorizePresenceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizePresence(microsoft365IntegrationAuthorizePresenceRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.authorizePresence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeauthorizePresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deauthorizePresence(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deauthorizePresence(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.deauthorizePresence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMicrosoft365Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMicrosoft365Directory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMicrosoft365Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMicrosoft365Directory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.getMicrosoft365Directory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Microsoft365Integration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMicrosoft365Integration($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMicrosoft365Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMicrosoft365Integration($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.getMicrosoft365Integration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMicrosoftAccessToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMicrosoftAccessToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMicrosoftAccessToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.getMicrosoftAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetUsers
         * @param {Microsoft365IntegrationGetUsersRequestBody} microsoft365IntegrationGetUsersRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(microsoft365IntegrationGetUsersRequestBody: Microsoft365IntegrationGetUsersRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMicrosoft365UsersPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(microsoft365IntegrationGetUsersRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetUsersByPrincipalNames
         * @param {Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody} microsoft365IntegrationGetUsersByPrincipalNamesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByPrincipalNames(microsoft365IntegrationGetUsersByPrincipalNamesRequestBody: Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersByPrincipalNames200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByPrincipalNames(microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.getUsersByPrincipalNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action TestPresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPresence(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPresence(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.testPresence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function TestSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMicrosoft365SubscriptionTestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.testSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Microsoft365Integration
         * @param {PbxMicrosoft365Integration} pbxMicrosoft365Integration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMicrosoft365Integration(pbxMicrosoft365Integration: PbxMicrosoft365Integration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMicrosoft365Integration(pbxMicrosoft365Integration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365IntegrationApi.updateMicrosoft365Integration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Microsoft365IntegrationApi - factory interface
 * @export
 */
export const Microsoft365IntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Microsoft365IntegrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action AuthorizePresence
         * @param {Microsoft365IntegrationApiAuthorizePresenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizePresence(requestParameters: Microsoft365IntegrationApiAuthorizePresenceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorizePresence(requestParameters.microsoft365IntegrationAuthorizePresenceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeauthorizePresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorizePresence(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deauthorizePresence(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMicrosoft365Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365Directory(options?: RawAxiosRequestConfig): AxiosPromise<PbxMicrosoft365Status> {
            return localVarFp.getMicrosoft365Directory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Microsoft365Integration
         * @param {Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365Integration(requestParameters: Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxMicrosoft365Integration> {
            return localVarFp.getMicrosoft365Integration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMicrosoftAccessToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoftAccessToken(options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.getMicrosoftAccessToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetUsers
         * @param {Microsoft365IntegrationApiGetUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(requestParameters: Microsoft365IntegrationApiGetUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxMicrosoft365UsersPage> {
            return localVarFp.getUsers(requestParameters.microsoft365IntegrationGetUsersRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetUsersByPrincipalNames
         * @param {Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByPrincipalNames(requestParameters: Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetUsersByPrincipalNames200Response> {
            return localVarFp.getUsersByPrincipalNames(requestParameters.microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action TestPresence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPresence(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.testPresence(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function TestSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSubscription(options?: RawAxiosRequestConfig): AxiosPromise<PbxMicrosoft365SubscriptionTestResult> {
            return localVarFp.testSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Microsoft365Integration
         * @param {Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMicrosoft365Integration(requestParameters: Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMicrosoft365Integration(requestParameters.pbxMicrosoft365Integration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorizePresence operation in Microsoft365IntegrationApi.
 * @export
 * @interface Microsoft365IntegrationApiAuthorizePresenceRequest
 */
export interface Microsoft365IntegrationApiAuthorizePresenceRequest {
    /**
     * Action parameters
     * @type {Microsoft365IntegrationAuthorizePresenceRequestBody}
     * @memberof Microsoft365IntegrationApiAuthorizePresence
     */
    readonly microsoft365IntegrationAuthorizePresenceRequestBody: Microsoft365IntegrationAuthorizePresenceRequestBody
}

/**
 * Request parameters for getMicrosoft365Integration operation in Microsoft365IntegrationApi.
 * @export
 * @interface Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest
 */
export interface Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof Microsoft365IntegrationApiGetMicrosoft365Integration
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof Microsoft365IntegrationApiGetMicrosoft365Integration
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getUsers operation in Microsoft365IntegrationApi.
 * @export
 * @interface Microsoft365IntegrationApiGetUsersRequest
 */
export interface Microsoft365IntegrationApiGetUsersRequest {
    /**
     * Action parameters
     * @type {Microsoft365IntegrationGetUsersRequestBody}
     * @memberof Microsoft365IntegrationApiGetUsers
     */
    readonly microsoft365IntegrationGetUsersRequestBody: Microsoft365IntegrationGetUsersRequestBody
}

/**
 * Request parameters for getUsersByPrincipalNames operation in Microsoft365IntegrationApi.
 * @export
 * @interface Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest
 */
export interface Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest {
    /**
     * Action parameters
     * @type {Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody}
     * @memberof Microsoft365IntegrationApiGetUsersByPrincipalNames
     */
    readonly microsoft365IntegrationGetUsersByPrincipalNamesRequestBody: Microsoft365IntegrationGetUsersByPrincipalNamesRequestBody
}

/**
 * Request parameters for updateMicrosoft365Integration operation in Microsoft365IntegrationApi.
 * @export
 * @interface Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest
 */
export interface Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest {
    /**
     * New property values
     * @type {PbxMicrosoft365Integration}
     * @memberof Microsoft365IntegrationApiUpdateMicrosoft365Integration
     */
    readonly pbxMicrosoft365Integration: PbxMicrosoft365Integration
}

/**
 * Microsoft365IntegrationApi - object-oriented interface
 * @export
 * @class Microsoft365IntegrationApi
 * @extends {BaseAPI}
 */
export class Microsoft365IntegrationApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action AuthorizePresence
     * @param {Microsoft365IntegrationApiAuthorizePresenceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public authorizePresence(requestParameters: Microsoft365IntegrationApiAuthorizePresenceRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).authorizePresence(requestParameters.microsoft365IntegrationAuthorizePresenceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeauthorizePresence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public deauthorizePresence(options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).deauthorizePresence(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMicrosoft365Directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public getMicrosoft365Directory(options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).getMicrosoft365Directory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Microsoft365Integration
     * @param {Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public getMicrosoft365Integration(requestParameters: Microsoft365IntegrationApiGetMicrosoft365IntegrationRequest = {}, options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).getMicrosoft365Integration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMicrosoftAccessToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public getMicrosoftAccessToken(options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).getMicrosoftAccessToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetUsers
     * @param {Microsoft365IntegrationApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public getUsers(requestParameters: Microsoft365IntegrationApiGetUsersRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).getUsers(requestParameters.microsoft365IntegrationGetUsersRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetUsersByPrincipalNames
     * @param {Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public getUsersByPrincipalNames(requestParameters: Microsoft365IntegrationApiGetUsersByPrincipalNamesRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).getUsersByPrincipalNames(requestParameters.microsoft365IntegrationGetUsersByPrincipalNamesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action TestPresence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public testPresence(options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).testPresence(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function TestSubscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public testSubscription(options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).testSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Microsoft365Integration
     * @param {Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365IntegrationApi
     */
    public updateMicrosoft365Integration(requestParameters: Microsoft365IntegrationApiUpdateMicrosoft365IntegrationRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365IntegrationApiFp(this.configuration).updateMicrosoft365Integration(requestParameters.pbxMicrosoft365Integration, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Microsoft365TeamsIntegrationApi - axios parameter creator
 * @export
 */
export const Microsoft365TeamsIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function CheckFqdnRecord
         * @param {string} fqdn Usage: fqdn&#x3D;{fqdn}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFqdnRecord: async (fqdn: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fqdn' is not null or undefined
            assertParamExists('checkFqdnRecord', 'fqdn', fqdn)
            const localVarPath = `/Microsoft365TeamsIntegration/Pbx.CheckFqdnRecord(fqdn={fqdn})`
                .replace(`{${"fqdn"}}`, encodeURIComponent(String(fqdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function CheckMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMapUsersScript: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365TeamsIntegration/Pbx.CheckMapUsersScript()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetDialPlanScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDialPlanScript: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365TeamsIntegration/Pbx.GetDialPlanScript()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapUsersScript: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365TeamsIntegration/Pbx.GetMapUsersScript()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Microsoft365TeamsIntegration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365TeamsIntegration: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Microsoft365TeamsIntegration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Microsoft365TeamsIntegration
         * @param {PbxMicrosoft365TeamsIntegration} pbxMicrosoft365TeamsIntegration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMicrosoft365TeamsIntegration: async (pbxMicrosoft365TeamsIntegration: PbxMicrosoft365TeamsIntegration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxMicrosoft365TeamsIntegration' is not null or undefined
            assertParamExists('updateMicrosoft365TeamsIntegration', 'pbxMicrosoft365TeamsIntegration', pbxMicrosoft365TeamsIntegration)
            const localVarPath = `/Microsoft365TeamsIntegration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxMicrosoft365TeamsIntegration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Microsoft365TeamsIntegrationApi - functional programming interface
 * @export
 */
export const Microsoft365TeamsIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Microsoft365TeamsIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function CheckFqdnRecord
         * @param {string} fqdn Usage: fqdn&#x3D;{fqdn}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFqdnRecord(fqdn: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFqdnRecord(fqdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.checkFqdnRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function CheckMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkMapUsersScript(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkMapUsersScript(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.checkMapUsersScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetDialPlanScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDialPlanScript(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDialPlanScript(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.getDialPlanScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapUsersScript(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapUsersScript(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.getMapUsersScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Microsoft365TeamsIntegration
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMicrosoft365TeamsIntegration($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMicrosoft365TeamsIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMicrosoft365TeamsIntegration($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.getMicrosoft365TeamsIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Microsoft365TeamsIntegration
         * @param {PbxMicrosoft365TeamsIntegration} pbxMicrosoft365TeamsIntegration New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMicrosoft365TeamsIntegration(pbxMicrosoft365TeamsIntegration: PbxMicrosoft365TeamsIntegration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMicrosoft365TeamsIntegration(pbxMicrosoft365TeamsIntegration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Microsoft365TeamsIntegrationApi.updateMicrosoft365TeamsIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Microsoft365TeamsIntegrationApi - factory interface
 * @export
 */
export const Microsoft365TeamsIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Microsoft365TeamsIntegrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function CheckFqdnRecord
         * @param {Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFqdnRecord(requestParameters: Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.checkFqdnRecord(requestParameters.fqdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function CheckMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMapUsersScript(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.checkMapUsersScript(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetDialPlanScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDialPlanScript(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getDialPlanScript(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMapUsersScript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapUsersScript(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getMapUsersScript(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Microsoft365TeamsIntegration
         * @param {Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMicrosoft365TeamsIntegration(requestParameters: Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxMicrosoft365TeamsIntegration> {
            return localVarFp.getMicrosoft365TeamsIntegration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Microsoft365TeamsIntegration
         * @param {Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMicrosoft365TeamsIntegration(requestParameters: Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMicrosoft365TeamsIntegration(requestParameters.pbxMicrosoft365TeamsIntegration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkFqdnRecord operation in Microsoft365TeamsIntegrationApi.
 * @export
 * @interface Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest
 */
export interface Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest {
    /**
     * Usage: fqdn&#x3D;{fqdn}
     * @type {string}
     * @memberof Microsoft365TeamsIntegrationApiCheckFqdnRecord
     */
    readonly fqdn: string
}

/**
 * Request parameters for getMicrosoft365TeamsIntegration operation in Microsoft365TeamsIntegrationApi.
 * @export
 * @interface Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest
 */
export interface Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegration
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegration
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateMicrosoft365TeamsIntegration operation in Microsoft365TeamsIntegrationApi.
 * @export
 * @interface Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest
 */
export interface Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest {
    /**
     * New property values
     * @type {PbxMicrosoft365TeamsIntegration}
     * @memberof Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegration
     */
    readonly pbxMicrosoft365TeamsIntegration: PbxMicrosoft365TeamsIntegration
}

/**
 * Microsoft365TeamsIntegrationApi - object-oriented interface
 * @export
 * @class Microsoft365TeamsIntegrationApi
 * @extends {BaseAPI}
 */
export class Microsoft365TeamsIntegrationApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function CheckFqdnRecord
     * @param {Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public checkFqdnRecord(requestParameters: Microsoft365TeamsIntegrationApiCheckFqdnRecordRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).checkFqdnRecord(requestParameters.fqdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function CheckMapUsersScript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public checkMapUsersScript(options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).checkMapUsersScript(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetDialPlanScript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public getDialPlanScript(options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).getDialPlanScript(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMapUsersScript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public getMapUsersScript(options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).getMapUsersScript(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Microsoft365TeamsIntegration
     * @param {Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public getMicrosoft365TeamsIntegration(requestParameters: Microsoft365TeamsIntegrationApiGetMicrosoft365TeamsIntegrationRequest = {}, options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).getMicrosoft365TeamsIntegration(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Microsoft365TeamsIntegration
     * @param {Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Microsoft365TeamsIntegrationApi
     */
    public updateMicrosoft365TeamsIntegration(requestParameters: Microsoft365TeamsIntegrationApiUpdateMicrosoft365TeamsIntegrationRequest, options?: RawAxiosRequestConfig) {
        return Microsoft365TeamsIntegrationApiFp(this.configuration).updateMicrosoft365TeamsIntegration(requestParameters.pbxMicrosoft365TeamsIntegration, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MusicOnHoldSettingsApi - axios parameter creator
 * @export
 */
export const MusicOnHoldSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get MusicOnHoldSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicOnHoldSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MusicOnHoldSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update MusicOnHoldSettings
         * @param {PbxMusicOnHoldSettings} pbxMusicOnHoldSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMusicOnHoldSettings: async (pbxMusicOnHoldSettings: PbxMusicOnHoldSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxMusicOnHoldSettings' is not null or undefined
            assertParamExists('updateMusicOnHoldSettings', 'pbxMusicOnHoldSettings', pbxMusicOnHoldSettings)
            const localVarPath = `/MusicOnHoldSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxMusicOnHoldSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicOnHoldSettingsApi - functional programming interface
 * @export
 */
export const MusicOnHoldSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MusicOnHoldSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get MusicOnHoldSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicOnHoldSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxMusicOnHoldSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMusicOnHoldSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MusicOnHoldSettingsApi.getMusicOnHoldSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update MusicOnHoldSettings
         * @param {PbxMusicOnHoldSettings} pbxMusicOnHoldSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMusicOnHoldSettings(pbxMusicOnHoldSettings: PbxMusicOnHoldSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMusicOnHoldSettings(pbxMusicOnHoldSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MusicOnHoldSettingsApi.updateMusicOnHoldSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MusicOnHoldSettingsApi - factory interface
 * @export
 */
export const MusicOnHoldSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MusicOnHoldSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get MusicOnHoldSettings
         * @param {MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicOnHoldSettings(requestParameters: MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxMusicOnHoldSettings> {
            return localVarFp.getMusicOnHoldSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update MusicOnHoldSettings
         * @param {MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMusicOnHoldSettings(requestParameters: MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMusicOnHoldSettings(requestParameters.pbxMusicOnHoldSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMusicOnHoldSettings operation in MusicOnHoldSettingsApi.
 * @export
 * @interface MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest
 */
export interface MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MusicOnHoldSettingsApiGetMusicOnHoldSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MusicOnHoldSettingsApiGetMusicOnHoldSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateMusicOnHoldSettings operation in MusicOnHoldSettingsApi.
 * @export
 * @interface MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest
 */
export interface MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest {
    /**
     * New property values
     * @type {PbxMusicOnHoldSettings}
     * @memberof MusicOnHoldSettingsApiUpdateMusicOnHoldSettings
     */
    readonly pbxMusicOnHoldSettings: PbxMusicOnHoldSettings
}

/**
 * MusicOnHoldSettingsApi - object-oriented interface
 * @export
 * @class MusicOnHoldSettingsApi
 * @extends {BaseAPI}
 */
export class MusicOnHoldSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get MusicOnHoldSettings
     * @param {MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicOnHoldSettingsApi
     */
    public getMusicOnHoldSettings(requestParameters: MusicOnHoldSettingsApiGetMusicOnHoldSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return MusicOnHoldSettingsApiFp(this.configuration).getMusicOnHoldSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update MusicOnHoldSettings
     * @param {MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicOnHoldSettingsApi
     */
    public updateMusicOnHoldSettings(requestParameters: MusicOnHoldSettingsApiUpdateMusicOnHoldSettingsRequest, options?: RawAxiosRequestConfig) {
        return MusicOnHoldSettingsApiFp(this.configuration).updateMusicOnHoldSettings(requestParameters.pbxMusicOnHoldSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyGroupApi - axios parameter creator
 * @export
 */
export const MyGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get MyGroup
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroup: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMyGroupPartnerInfo
         * @param {string} resellerId Usage: resellerId&#x3D;{resellerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroupPartnerInfo: async (resellerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resellerId' is not null or undefined
            assertParamExists('getMyGroupPartnerInfo', 'resellerId', resellerId)
            const localVarPath = `/MyGroup/Pbx.GetMyGroupPartnerInfo(resellerId={resellerId})`
                .replace(`{${"resellerId"}}`, encodeURIComponent(String(resellerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroupRestrictions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Pbx.GetRestrictions()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action LinkMyGroupPartner
         * @param {LinkMyGroupPartnerRequestBody} [linkMyGroupPartnerRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMyGroupPartner: async (linkMyGroupPartnerRequestBody?: LinkMyGroupPartnerRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Pbx.LinkMyGroupPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkMyGroupPartnerRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Members from MyGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGroupMembers: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Rights from MyGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGroupRights: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ReplaceMyGroupLicenseKey
         * @param {ReplaceMyGroupLicenseKeyRequestBody} [replaceMyGroupLicenseKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceMyGroupLicenseKey: async (replaceMyGroupLicenseKeyRequestBody?: ReplaceMyGroupLicenseKeyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Pbx.ReplaceMyGroupLicenseKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceMyGroupLicenseKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UnlinkMyGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkMyGroupPartner: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyGroup/Pbx.UnlinkMyGroupPartner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update MyGroup
         * @param {PbxGroup} pbxGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGroup: async (pbxGroup: PbxGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxGroup' is not null or undefined
            assertParamExists('updateMyGroup', 'pbxGroup', pbxGroup)
            const localVarPath = `/MyGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyGroupApi - functional programming interface
 * @export
 */
export const MyGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get MyGroup
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGroup($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGroup($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.getMyGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMyGroupPartnerInfo
         * @param {string} resellerId Usage: resellerId&#x3D;{resellerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGroupPartnerInfo(resellerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxResellerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGroupPartnerInfo(resellerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.getMyGroupPartnerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGroupRestrictions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRestrictions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGroupRestrictions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.getMyGroupRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action LinkMyGroupPartner
         * @param {LinkMyGroupPartnerRequestBody} [linkMyGroupPartnerRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkMyGroupPartner(linkMyGroupPartnerRequestBody?: LinkMyGroupPartnerRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkMyGroupPartner(linkMyGroupPartnerRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.linkMyGroupPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Members from MyGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyGroupMembers($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyGroupMembers($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.listMyGroupMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Rights from MyGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyGroupRights($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRightsCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyGroupRights($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.listMyGroupRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ReplaceMyGroupLicenseKey
         * @param {ReplaceMyGroupLicenseKeyRequestBody} [replaceMyGroupLicenseKeyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceMyGroupLicenseKey(replaceMyGroupLicenseKeyRequestBody?: ReplaceMyGroupLicenseKeyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceMyGroupLicenseKey(replaceMyGroupLicenseKeyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.replaceMyGroupLicenseKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UnlinkMyGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkMyGroupPartner(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkMyGroupPartner(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.unlinkMyGroupPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update MyGroup
         * @param {PbxGroup} pbxGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyGroup(pbxGroup: PbxGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyGroup(pbxGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyGroupApi.updateMyGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyGroupApi - factory interface
 * @export
 */
export const MyGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Get MyGroup
         * @param {MyGroupApiGetMyGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroup(requestParameters: MyGroupApiGetMyGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGroup> {
            return localVarFp.getMyGroup(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMyGroupPartnerInfo
         * @param {MyGroupApiGetMyGroupPartnerInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroupPartnerInfo(requestParameters: MyGroupApiGetMyGroupPartnerInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxResellerInfo> {
            return localVarFp.getMyGroupPartnerInfo(requestParameters.resellerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRestrictions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroupRestrictions(options?: RawAxiosRequestConfig): AxiosPromise<PbxRestrictions> {
            return localVarFp.getMyGroupRestrictions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action LinkMyGroupPartner
         * @param {MyGroupApiLinkMyGroupPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMyGroupPartner(requestParameters: MyGroupApiLinkMyGroupPartnerRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.linkMyGroupPartner(requestParameters.linkMyGroupPartnerRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Members from MyGroup
         * @param {MyGroupApiListMyGroupMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGroupMembers(requestParameters: MyGroupApiListMyGroupMembersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserGroupCollectionResponse> {
            return localVarFp.listMyGroupMembers(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Rights from MyGroup
         * @param {MyGroupApiListMyGroupRightsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyGroupRights(requestParameters: MyGroupApiListMyGroupRightsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRightsCollectionResponse> {
            return localVarFp.listMyGroupRights(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ReplaceMyGroupLicenseKey
         * @param {MyGroupApiReplaceMyGroupLicenseKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceMyGroupLicenseKey(requestParameters: MyGroupApiReplaceMyGroupLicenseKeyRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceMyGroupLicenseKey(requestParameters.replaceMyGroupLicenseKeyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UnlinkMyGroupPartner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkMyGroupPartner(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlinkMyGroupPartner(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update MyGroup
         * @param {MyGroupApiUpdateMyGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGroup(requestParameters: MyGroupApiUpdateMyGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMyGroup(requestParameters.pbxGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMyGroup operation in MyGroupApi.
 * @export
 * @interface MyGroupApiGetMyGroupRequest
 */
export interface MyGroupApiGetMyGroupRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyGroupApiGetMyGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyGroupApiGetMyGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getMyGroupPartnerInfo operation in MyGroupApi.
 * @export
 * @interface MyGroupApiGetMyGroupPartnerInfoRequest
 */
export interface MyGroupApiGetMyGroupPartnerInfoRequest {
    /**
     * Usage: resellerId&#x3D;{resellerId}
     * @type {string}
     * @memberof MyGroupApiGetMyGroupPartnerInfo
     */
    readonly resellerId: string
}

/**
 * Request parameters for linkMyGroupPartner operation in MyGroupApi.
 * @export
 * @interface MyGroupApiLinkMyGroupPartnerRequest
 */
export interface MyGroupApiLinkMyGroupPartnerRequest {
    /**
     * 
     * @type {LinkMyGroupPartnerRequestBody}
     * @memberof MyGroupApiLinkMyGroupPartner
     */
    readonly linkMyGroupPartnerRequestBody?: LinkMyGroupPartnerRequestBody
}

/**
 * Request parameters for listMyGroupMembers operation in MyGroupApi.
 * @export
 * @interface MyGroupApiListMyGroupMembersRequest
 */
export interface MyGroupApiListMyGroupMembersRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupMembers
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listMyGroupRights operation in MyGroupApi.
 * @export
 * @interface MyGroupApiListMyGroupRightsRequest
 */
export interface MyGroupApiListMyGroupRightsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyGroupApiListMyGroupRights
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for replaceMyGroupLicenseKey operation in MyGroupApi.
 * @export
 * @interface MyGroupApiReplaceMyGroupLicenseKeyRequest
 */
export interface MyGroupApiReplaceMyGroupLicenseKeyRequest {
    /**
     * 
     * @type {ReplaceMyGroupLicenseKeyRequestBody}
     * @memberof MyGroupApiReplaceMyGroupLicenseKey
     */
    readonly replaceMyGroupLicenseKeyRequestBody?: ReplaceMyGroupLicenseKeyRequestBody
}

/**
 * Request parameters for updateMyGroup operation in MyGroupApi.
 * @export
 * @interface MyGroupApiUpdateMyGroupRequest
 */
export interface MyGroupApiUpdateMyGroupRequest {
    /**
     * New property values
     * @type {PbxGroup}
     * @memberof MyGroupApiUpdateMyGroup
     */
    readonly pbxGroup: PbxGroup
}

/**
 * MyGroupApi - object-oriented interface
 * @export
 * @class MyGroupApi
 * @extends {BaseAPI}
 */
export class MyGroupApi extends BaseAPI {
    /**
     * 
     * @summary Get MyGroup
     * @param {MyGroupApiGetMyGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public getMyGroup(requestParameters: MyGroupApiGetMyGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).getMyGroup(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMyGroupPartnerInfo
     * @param {MyGroupApiGetMyGroupPartnerInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public getMyGroupPartnerInfo(requestParameters: MyGroupApiGetMyGroupPartnerInfoRequest, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).getMyGroupPartnerInfo(requestParameters.resellerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRestrictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public getMyGroupRestrictions(options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).getMyGroupRestrictions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action LinkMyGroupPartner
     * @param {MyGroupApiLinkMyGroupPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public linkMyGroupPartner(requestParameters: MyGroupApiLinkMyGroupPartnerRequest = {}, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).linkMyGroupPartner(requestParameters.linkMyGroupPartnerRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Members from MyGroup
     * @param {MyGroupApiListMyGroupMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public listMyGroupMembers(requestParameters: MyGroupApiListMyGroupMembersRequest = {}, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).listMyGroupMembers(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Rights from MyGroup
     * @param {MyGroupApiListMyGroupRightsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public listMyGroupRights(requestParameters: MyGroupApiListMyGroupRightsRequest = {}, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).listMyGroupRights(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ReplaceMyGroupLicenseKey
     * @param {MyGroupApiReplaceMyGroupLicenseKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public replaceMyGroupLicenseKey(requestParameters: MyGroupApiReplaceMyGroupLicenseKeyRequest = {}, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).replaceMyGroupLicenseKey(requestParameters.replaceMyGroupLicenseKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UnlinkMyGroupPartner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public unlinkMyGroupPartner(options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).unlinkMyGroupPartner(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update MyGroup
     * @param {MyGroupApiUpdateMyGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyGroupApi
     */
    public updateMyGroup(requestParameters: MyGroupApiUpdateMyGroupRequest, options?: RawAxiosRequestConfig) {
        return MyGroupApiFp(this.configuration).updateMyGroup(requestParameters.pbxGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyTokensApi - axios parameter creator
 * @export
 */
export const MyTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from MyTokens
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshToken: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {number} id The unique identifier of RefreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokeToken', 'id', id)
            const localVarPath = `/MyTokens({Id})/Pbx.RevokeToken`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyTokensApi - functional programming interface
 * @export
 */
export const MyTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from MyTokens
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefreshToken($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRefreshTokenCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefreshToken($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyTokensApi.listRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {number} id The unique identifier of RefreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyTokensApi.revokeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyTokensApi - factory interface
 * @export
 */
export const MyTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyTokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from MyTokens
         * @param {MyTokensApiListRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefreshToken(requestParameters: MyTokensApiListRefreshTokenRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRefreshTokenCollectionResponse> {
            return localVarFp.listRefreshToken(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {MyTokensApiRevokeTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(requestParameters: MyTokensApiRevokeTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeToken(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRefreshToken operation in MyTokensApi.
 * @export
 * @interface MyTokensApiListRefreshTokenRequest
 */
export interface MyTokensApiListRefreshTokenRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyTokensApiListRefreshToken
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for revokeToken operation in MyTokensApi.
 * @export
 * @interface MyTokensApiRevokeTokenRequest
 */
export interface MyTokensApiRevokeTokenRequest {
    /**
     * The unique identifier of RefreshToken
     * @type {number}
     * @memberof MyTokensApiRevokeToken
     */
    readonly id: number
}

/**
 * MyTokensApi - object-oriented interface
 * @export
 * @class MyTokensApi
 * @extends {BaseAPI}
 */
export class MyTokensApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from MyTokens
     * @param {MyTokensApiListRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyTokensApi
     */
    public listRefreshToken(requestParameters: MyTokensApiListRefreshTokenRequest = {}, options?: RawAxiosRequestConfig) {
        return MyTokensApiFp(this.configuration).listRefreshToken(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RevokeToken
     * @param {MyTokensApiRevokeTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyTokensApi
     */
    public revokeToken(requestParameters: MyTokensApiRevokeTokenRequest, options?: RawAxiosRequestConfig) {
        return MyTokensApiFp(this.configuration).revokeToken(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyUserApi - axios parameter creator
 * @export
 */
export const MyUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get MyUser
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUser: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ForwardingProfiles from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserForwardingProfiles: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyUser/ForwardingProfiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Greetings from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserGreetings: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyUser/Greetings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Groups from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserGroups: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyUser/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGenerateProvLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/MyUser/Pbx.GenerateProvLink()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update MyUser
         * @param {PbxUser} pbxUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUser: async (pbxUser: PbxUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxUser' is not null or undefined
            assertParamExists('updateMyUser', 'pbxUser', pbxUser)
            const localVarPath = `/MyUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyUserApi - functional programming interface
 * @export
 */
export const MyUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get MyUser
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUser($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUser($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.getMyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get ForwardingProfiles from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUserForwardingProfiles($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxForwardingProfileCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUserForwardingProfiles($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.listMyUserForwardingProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Greetings from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUserGreetings($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGreetingCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUserGreetings($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.listMyUserGreetings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Groups from MyUser
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUserGroups($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUserGroups($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.listMyUserGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myUserGenerateProvLink(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myUserGenerateProvLink(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.myUserGenerateProvLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update MyUser
         * @param {PbxUser} pbxUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyUser(pbxUser: PbxUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyUser(pbxUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyUserApi.updateMyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyUserApi - factory interface
 * @export
 */
export const MyUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get MyUser
         * @param {MyUserApiGetMyUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUser(requestParameters: MyUserApiGetMyUserRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxUser> {
            return localVarFp.getMyUser(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ForwardingProfiles from MyUser
         * @param {MyUserApiListMyUserForwardingProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserForwardingProfiles(requestParameters: MyUserApiListMyUserForwardingProfilesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxForwardingProfileCollectionResponse> {
            return localVarFp.listMyUserForwardingProfiles(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Greetings from MyUser
         * @param {MyUserApiListMyUserGreetingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserGreetings(requestParameters: MyUserApiListMyUserGreetingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxGreetingCollectionResponse> {
            return localVarFp.listMyUserGreetings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Groups from MyUser
         * @param {MyUserApiListMyUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserGroups(requestParameters: MyUserApiListMyUserGroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserGroupCollectionResponse> {
            return localVarFp.listMyUserGroups(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGenerateProvLink(options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.myUserGenerateProvLink(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update MyUser
         * @param {MyUserApiUpdateMyUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyUser(requestParameters: MyUserApiUpdateMyUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateMyUser(requestParameters.pbxUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMyUser operation in MyUserApi.
 * @export
 * @interface MyUserApiGetMyUserRequest
 */
export interface MyUserApiGetMyUserRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyUserApiGetMyUser
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyUserApiGetMyUser
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listMyUserForwardingProfiles operation in MyUserApi.
 * @export
 * @interface MyUserApiListMyUserForwardingProfilesRequest
 */
export interface MyUserApiListMyUserForwardingProfilesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserForwardingProfiles
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listMyUserGreetings operation in MyUserApi.
 * @export
 * @interface MyUserApiListMyUserGreetingsRequest
 */
export interface MyUserApiListMyUserGreetingsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGreetings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listMyUserGroups operation in MyUserApi.
 * @export
 * @interface MyUserApiListMyUserGroupsRequest
 */
export interface MyUserApiListMyUserGroupsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof MyUserApiListMyUserGroups
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateMyUser operation in MyUserApi.
 * @export
 * @interface MyUserApiUpdateMyUserRequest
 */
export interface MyUserApiUpdateMyUserRequest {
    /**
     * New property values
     * @type {PbxUser}
     * @memberof MyUserApiUpdateMyUser
     */
    readonly pbxUser: PbxUser
}

/**
 * MyUserApi - object-oriented interface
 * @export
 * @class MyUserApi
 * @extends {BaseAPI}
 */
export class MyUserApi extends BaseAPI {
    /**
     * 
     * @summary Get MyUser
     * @param {MyUserApiGetMyUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public getMyUser(requestParameters: MyUserApiGetMyUserRequest = {}, options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).getMyUser(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ForwardingProfiles from MyUser
     * @param {MyUserApiListMyUserForwardingProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public listMyUserForwardingProfiles(requestParameters: MyUserApiListMyUserForwardingProfilesRequest = {}, options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).listMyUserForwardingProfiles(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Greetings from MyUser
     * @param {MyUserApiListMyUserGreetingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public listMyUserGreetings(requestParameters: MyUserApiListMyUserGreetingsRequest = {}, options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).listMyUserGreetings(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Groups from MyUser
     * @param {MyUserApiListMyUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public listMyUserGroups(requestParameters: MyUserApiListMyUserGroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).listMyUserGroups(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GenerateProvLink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public myUserGenerateProvLink(options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).myUserGenerateProvLink(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update MyUser
     * @param {MyUserApiUpdateMyUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyUserApi
     */
    public updateMyUser(requestParameters: MyUserApiUpdateMyUserRequest, options?: RawAxiosRequestConfig) {
        return MyUserApiFp(this.configuration).updateMyUser(requestParameters.pbxUser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NetworkInterfacesApi - axios parameter creator
 * @export
 */
export const NetworkInterfacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from NetworkInterfaces
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkInterface: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/NetworkInterfaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkInterfacesApi - functional programming interface
 * @export
 */
export const NetworkInterfacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkInterfacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from NetworkInterfaces
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkInterface($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxNetworkInterfaceCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNetworkInterface($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkInterfacesApi.listNetworkInterface']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NetworkInterfacesApi - factory interface
 * @export
 */
export const NetworkInterfacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkInterfacesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from NetworkInterfaces
         * @param {NetworkInterfacesApiListNetworkInterfaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkInterface(requestParameters: NetworkInterfacesApiListNetworkInterfaceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxNetworkInterfaceCollectionResponse> {
            return localVarFp.listNetworkInterface(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listNetworkInterface operation in NetworkInterfacesApi.
 * @export
 * @interface NetworkInterfacesApiListNetworkInterfaceRequest
 */
export interface NetworkInterfacesApiListNetworkInterfaceRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof NetworkInterfacesApiListNetworkInterface
     */
    readonly $expand?: Set<string>
}

/**
 * NetworkInterfacesApi - object-oriented interface
 * @export
 * @class NetworkInterfacesApi
 * @extends {BaseAPI}
 */
export class NetworkInterfacesApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from NetworkInterfaces
     * @param {NetworkInterfacesApiListNetworkInterfaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkInterfacesApi
     */
    public listNetworkInterface(requestParameters: NetworkInterfacesApiListNetworkInterfaceRequest = {}, options?: RawAxiosRequestConfig) {
        return NetworkInterfacesApiFp(this.configuration).listNetworkInterface(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NetworkSettingsApi - axios parameter creator
 * @export
 */
export const NetworkSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function GetIfaces
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIfaces: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/NetworkSettings/Pbx.GetIfaces()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get NetworkSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/NetworkSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update NetworkSettings
         * @param {PbxNetworkSettings} pbxNetworkSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetworkSettings: async (pbxNetworkSettings: PbxNetworkSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxNetworkSettings' is not null or undefined
            assertParamExists('updateNetworkSettings', 'pbxNetworkSettings', pbxNetworkSettings)
            const localVarPath = `/NetworkSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxNetworkSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkSettingsApi - functional programming interface
 * @export
 */
export const NetworkSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetIfaces
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIfaces($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIfaces($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkSettingsApi.getIfaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get NetworkSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxNetworkSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkSettingsApi.getNetworkSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update NetworkSettings
         * @param {PbxNetworkSettings} pbxNetworkSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNetworkSettings(pbxNetworkSettings: PbxNetworkSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNetworkSettings(pbxNetworkSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NetworkSettingsApi.updateNetworkSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NetworkSettingsApi - factory interface
 * @export
 */
export const NetworkSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetIfaces
         * @param {NetworkSettingsApiGetIfacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIfaces(requestParameters: NetworkSettingsApiGetIfacesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAudioFiles200Response> {
            return localVarFp.getIfaces(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get NetworkSettings
         * @param {NetworkSettingsApiGetNetworkSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkSettings(requestParameters: NetworkSettingsApiGetNetworkSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxNetworkSettings> {
            return localVarFp.getNetworkSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update NetworkSettings
         * @param {NetworkSettingsApiUpdateNetworkSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetworkSettings(requestParameters: NetworkSettingsApiUpdateNetworkSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNetworkSettings(requestParameters.pbxNetworkSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIfaces operation in NetworkSettingsApi.
 * @export
 * @interface NetworkSettingsApiGetIfacesRequest
 */
export interface NetworkSettingsApiGetIfacesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof NetworkSettingsApiGetIfaces
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof NetworkSettingsApiGetIfaces
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof NetworkSettingsApiGetIfaces
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof NetworkSettingsApiGetIfaces
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof NetworkSettingsApiGetIfaces
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getNetworkSettings operation in NetworkSettingsApi.
 * @export
 * @interface NetworkSettingsApiGetNetworkSettingsRequest
 */
export interface NetworkSettingsApiGetNetworkSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof NetworkSettingsApiGetNetworkSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof NetworkSettingsApiGetNetworkSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateNetworkSettings operation in NetworkSettingsApi.
 * @export
 * @interface NetworkSettingsApiUpdateNetworkSettingsRequest
 */
export interface NetworkSettingsApiUpdateNetworkSettingsRequest {
    /**
     * New property values
     * @type {PbxNetworkSettings}
     * @memberof NetworkSettingsApiUpdateNetworkSettings
     */
    readonly pbxNetworkSettings: PbxNetworkSettings
}

/**
 * NetworkSettingsApi - object-oriented interface
 * @export
 * @class NetworkSettingsApi
 * @extends {BaseAPI}
 */
export class NetworkSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function GetIfaces
     * @param {NetworkSettingsApiGetIfacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSettingsApi
     */
    public getIfaces(requestParameters: NetworkSettingsApiGetIfacesRequest = {}, options?: RawAxiosRequestConfig) {
        return NetworkSettingsApiFp(this.configuration).getIfaces(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get NetworkSettings
     * @param {NetworkSettingsApiGetNetworkSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSettingsApi
     */
    public getNetworkSettings(requestParameters: NetworkSettingsApiGetNetworkSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return NetworkSettingsApiFp(this.configuration).getNetworkSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update NetworkSettings
     * @param {NetworkSettingsApiUpdateNetworkSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSettingsApi
     */
    public updateNetworkSettings(requestParameters: NetworkSettingsApiUpdateNetworkSettingsRequest, options?: RawAxiosRequestConfig) {
        return NetworkSettingsApiFp(this.configuration).updateNetworkSettings(requestParameters.pbxNetworkSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationSettingsApi - axios parameter creator
 * @export
 */
export const NotificationSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get NotificationSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/NotificationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action TestEmail
         * @param {NotificationSettingsTestEmailRequestBody} notificationSettingsTestEmailRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmail: async (notificationSettingsTestEmailRequestBody: NotificationSettingsTestEmailRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationSettingsTestEmailRequestBody' is not null or undefined
            assertParamExists('testEmail', 'notificationSettingsTestEmailRequestBody', notificationSettingsTestEmailRequestBody)
            const localVarPath = `/NotificationSettings/Pbx.TestEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationSettingsTestEmailRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update NotificationSettings
         * @param {PbxNotificationSettings} pbxNotificationSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSettings: async (pbxNotificationSettings: PbxNotificationSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxNotificationSettings' is not null or undefined
            assertParamExists('updateNotificationSettings', 'pbxNotificationSettings', pbxNotificationSettings)
            const localVarPath = `/NotificationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxNotificationSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationSettingsApi - functional programming interface
 * @export
 */
export const NotificationSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get NotificationSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxNotificationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationSettingsApi.getNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action TestEmail
         * @param {NotificationSettingsTestEmailRequestBody} notificationSettingsTestEmailRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEmail(notificationSettingsTestEmailRequestBody: NotificationSettingsTestEmailRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEmail(notificationSettingsTestEmailRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationSettingsApi.testEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update NotificationSettings
         * @param {PbxNotificationSettings} pbxNotificationSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationSettings(pbxNotificationSettings: PbxNotificationSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationSettings(pbxNotificationSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationSettingsApi.updateNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationSettingsApi - factory interface
 * @export
 */
export const NotificationSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get NotificationSettings
         * @param {NotificationSettingsApiGetNotificationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSettings(requestParameters: NotificationSettingsApiGetNotificationSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxNotificationSettings> {
            return localVarFp.getNotificationSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action TestEmail
         * @param {NotificationSettingsApiTestEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmail(requestParameters: NotificationSettingsApiTestEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTestResult> {
            return localVarFp.testEmail(requestParameters.notificationSettingsTestEmailRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update NotificationSettings
         * @param {NotificationSettingsApiUpdateNotificationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSettings(requestParameters: NotificationSettingsApiUpdateNotificationSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNotificationSettings(requestParameters.pbxNotificationSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNotificationSettings operation in NotificationSettingsApi.
 * @export
 * @interface NotificationSettingsApiGetNotificationSettingsRequest
 */
export interface NotificationSettingsApiGetNotificationSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof NotificationSettingsApiGetNotificationSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof NotificationSettingsApiGetNotificationSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for testEmail operation in NotificationSettingsApi.
 * @export
 * @interface NotificationSettingsApiTestEmailRequest
 */
export interface NotificationSettingsApiTestEmailRequest {
    /**
     * Action parameters
     * @type {NotificationSettingsTestEmailRequestBody}
     * @memberof NotificationSettingsApiTestEmail
     */
    readonly notificationSettingsTestEmailRequestBody: NotificationSettingsTestEmailRequestBody
}

/**
 * Request parameters for updateNotificationSettings operation in NotificationSettingsApi.
 * @export
 * @interface NotificationSettingsApiUpdateNotificationSettingsRequest
 */
export interface NotificationSettingsApiUpdateNotificationSettingsRequest {
    /**
     * New property values
     * @type {PbxNotificationSettings}
     * @memberof NotificationSettingsApiUpdateNotificationSettings
     */
    readonly pbxNotificationSettings: PbxNotificationSettings
}

/**
 * NotificationSettingsApi - object-oriented interface
 * @export
 * @class NotificationSettingsApi
 * @extends {BaseAPI}
 */
export class NotificationSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get NotificationSettings
     * @param {NotificationSettingsApiGetNotificationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSettingsApi
     */
    public getNotificationSettings(requestParameters: NotificationSettingsApiGetNotificationSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return NotificationSettingsApiFp(this.configuration).getNotificationSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action TestEmail
     * @param {NotificationSettingsApiTestEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSettingsApi
     */
    public testEmail(requestParameters: NotificationSettingsApiTestEmailRequest, options?: RawAxiosRequestConfig) {
        return NotificationSettingsApiFp(this.configuration).testEmail(requestParameters.notificationSettingsTestEmailRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update NotificationSettings
     * @param {NotificationSettingsApiUpdateNotificationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSettingsApi
     */
    public updateNotificationSettings(requestParameters: NotificationSettingsApiUpdateNotificationSettingsRequest, options?: RawAxiosRequestConfig) {
        return NotificationSettingsApiFp(this.configuration).updateNotificationSettings(requestParameters.pbxNotificationSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OfficeHoursApi - axios parameter creator
 * @export
 */
export const OfficeHoursApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get OfficeHours
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfficeHours: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/OfficeHours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update OfficeHours
         * @param {PbxOfficeHours} pbxOfficeHours New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOfficeHours: async (pbxOfficeHours: PbxOfficeHours, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxOfficeHours' is not null or undefined
            assertParamExists('updateOfficeHours', 'pbxOfficeHours', pbxOfficeHours)
            const localVarPath = `/OfficeHours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxOfficeHours, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfficeHoursApi - functional programming interface
 * @export
 */
export const OfficeHoursApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfficeHoursApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get OfficeHours
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfficeHours($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOfficeHours>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfficeHours($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfficeHoursApi.getOfficeHours']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update OfficeHours
         * @param {PbxOfficeHours} pbxOfficeHours New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOfficeHours(pbxOfficeHours: PbxOfficeHours, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOfficeHours(pbxOfficeHours, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfficeHoursApi.updateOfficeHours']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OfficeHoursApi - factory interface
 * @export
 */
export const OfficeHoursApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfficeHoursApiFp(configuration)
    return {
        /**
         * 
         * @summary Get OfficeHours
         * @param {OfficeHoursApiGetOfficeHoursRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfficeHours(requestParameters: OfficeHoursApiGetOfficeHoursRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxOfficeHours> {
            return localVarFp.getOfficeHours(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update OfficeHours
         * @param {OfficeHoursApiUpdateOfficeHoursRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOfficeHours(requestParameters: OfficeHoursApiUpdateOfficeHoursRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateOfficeHours(requestParameters.pbxOfficeHours, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getOfficeHours operation in OfficeHoursApi.
 * @export
 * @interface OfficeHoursApiGetOfficeHoursRequest
 */
export interface OfficeHoursApiGetOfficeHoursRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof OfficeHoursApiGetOfficeHours
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof OfficeHoursApiGetOfficeHours
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateOfficeHours operation in OfficeHoursApi.
 * @export
 * @interface OfficeHoursApiUpdateOfficeHoursRequest
 */
export interface OfficeHoursApiUpdateOfficeHoursRequest {
    /**
     * New property values
     * @type {PbxOfficeHours}
     * @memberof OfficeHoursApiUpdateOfficeHours
     */
    readonly pbxOfficeHours: PbxOfficeHours
}

/**
 * OfficeHoursApi - object-oriented interface
 * @export
 * @class OfficeHoursApi
 * @extends {BaseAPI}
 */
export class OfficeHoursApi extends BaseAPI {
    /**
     * 
     * @summary Get OfficeHours
     * @param {OfficeHoursApiGetOfficeHoursRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficeHoursApi
     */
    public getOfficeHours(requestParameters: OfficeHoursApiGetOfficeHoursRequest = {}, options?: RawAxiosRequestConfig) {
        return OfficeHoursApiFp(this.configuration).getOfficeHours(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update OfficeHours
     * @param {OfficeHoursApiUpdateOfficeHoursRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficeHoursApi
     */
    public updateOfficeHours(requestParameters: OfficeHoursApiUpdateOfficeHoursRequest, options?: RawAxiosRequestConfig) {
        return OfficeHoursApiFp(this.configuration).updateOfficeHours(requestParameters.pbxOfficeHours, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutboundRulesApi - axios parameter creator
 * @export
 */
export const OutboundRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to OutboundRules
         * @param {PbxOutboundRule} pbxOutboundRule New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutboundRule: async (pbxOutboundRule: PbxOutboundRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxOutboundRule' is not null or undefined
            assertParamExists('createOutboundRule', 'pbxOutboundRule', pbxOutboundRule)
            const localVarPath = `/OutboundRules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxOutboundRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from OutboundRules
         * @param {number} id The unique identifier of OutboundRule
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutboundRule: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOutboundRule', 'id', id)
            const localVarPath = `/OutboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetEmergencyOutboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmergencyOutboundRules: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/OutboundRules/Pbx.GetEmergencyOutboundRules()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from OutboundRules by key
         * @param {number} id The unique identifier of OutboundRule
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutboundRule: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOutboundRule', 'id', id)
            const localVarPath = `/OutboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from OutboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutboundRule: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/OutboundRules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MoveUpDown
         * @param {OutboundRulesMoveUpDownRequestBody} outboundRulesMoveUpDownRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveUpDown: async (outboundRulesMoveUpDownRequestBody: OutboundRulesMoveUpDownRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outboundRulesMoveUpDownRequestBody' is not null or undefined
            assertParamExists('moveUpDown', 'outboundRulesMoveUpDownRequestBody', outboundRulesMoveUpDownRequestBody)
            const localVarPath = `/OutboundRules/Pbx.MoveUpDown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outboundRulesMoveUpDownRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Purge
         * @param {OutboundRulesPurgeRequestBody} outboundRulesPurgeRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purge: async (outboundRulesPurgeRequestBody: OutboundRulesPurgeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outboundRulesPurgeRequestBody' is not null or undefined
            assertParamExists('purge', 'outboundRulesPurgeRequestBody', outboundRulesPurgeRequestBody)
            const localVarPath = `/OutboundRules/Pbx.Purge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outboundRulesPurgeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in OutboundRules
         * @param {number} id The unique identifier of OutboundRule
         * @param {PbxOutboundRule} pbxOutboundRule New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutboundRule: async (id: number, pbxOutboundRule: PbxOutboundRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOutboundRule', 'id', id)
            // verify required parameter 'pbxOutboundRule' is not null or undefined
            assertParamExists('updateOutboundRule', 'pbxOutboundRule', pbxOutboundRule)
            const localVarPath = `/OutboundRules({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxOutboundRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutboundRulesApi - functional programming interface
 * @export
 */
export const OutboundRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutboundRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to OutboundRules
         * @param {PbxOutboundRule} pbxOutboundRule New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOutboundRule(pbxOutboundRule: PbxOutboundRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOutboundRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOutboundRule(pbxOutboundRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.createOutboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from OutboundRules
         * @param {number} id The unique identifier of OutboundRule
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOutboundRule(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOutboundRule(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.deleteOutboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetEmergencyOutboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmergencyOutboundRules($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfOutboundRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmergencyOutboundRules($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.getEmergencyOutboundRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from OutboundRules by key
         * @param {number} id The unique identifier of OutboundRule
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOutboundRule(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOutboundRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutboundRule(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.getOutboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from OutboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOutboundRule($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxOutboundRuleCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutboundRule($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.listOutboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MoveUpDown
         * @param {OutboundRulesMoveUpDownRequestBody} outboundRulesMoveUpDownRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveUpDown(outboundRulesMoveUpDownRequestBody: OutboundRulesMoveUpDownRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveUpDown(outboundRulesMoveUpDownRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.moveUpDown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Purge
         * @param {OutboundRulesPurgeRequestBody} outboundRulesPurgeRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purge(outboundRulesPurgeRequestBody: OutboundRulesPurgeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purge(outboundRulesPurgeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.purge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in OutboundRules
         * @param {number} id The unique identifier of OutboundRule
         * @param {PbxOutboundRule} pbxOutboundRule New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOutboundRule(id: number, pbxOutboundRule: PbxOutboundRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOutboundRule(id, pbxOutboundRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutboundRulesApi.updateOutboundRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutboundRulesApi - factory interface
 * @export
 */
export const OutboundRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutboundRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to OutboundRules
         * @param {OutboundRulesApiCreateOutboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutboundRule(requestParameters: OutboundRulesApiCreateOutboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxOutboundRule> {
            return localVarFp.createOutboundRule(requestParameters.pbxOutboundRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from OutboundRules
         * @param {OutboundRulesApiDeleteOutboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutboundRule(requestParameters: OutboundRulesApiDeleteOutboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOutboundRule(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetEmergencyOutboundRules
         * @param {OutboundRulesApiGetEmergencyOutboundRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmergencyOutboundRules(requestParameters: OutboundRulesApiGetEmergencyOutboundRulesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfOutboundRule> {
            return localVarFp.getEmergencyOutboundRules(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from OutboundRules by key
         * @param {OutboundRulesApiGetOutboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutboundRule(requestParameters: OutboundRulesApiGetOutboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxOutboundRule> {
            return localVarFp.getOutboundRule(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from OutboundRules
         * @param {OutboundRulesApiListOutboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutboundRule(requestParameters: OutboundRulesApiListOutboundRuleRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxOutboundRuleCollectionResponse> {
            return localVarFp.listOutboundRule(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MoveUpDown
         * @param {OutboundRulesApiMoveUpDownRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveUpDown(requestParameters: OutboundRulesApiMoveUpDownRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moveUpDown(requestParameters.outboundRulesMoveUpDownRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Purge
         * @param {OutboundRulesApiPurgeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purge(requestParameters: OutboundRulesApiPurgeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purge(requestParameters.outboundRulesPurgeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in OutboundRules
         * @param {OutboundRulesApiUpdateOutboundRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutboundRule(requestParameters: OutboundRulesApiUpdateOutboundRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateOutboundRule(requestParameters.id, requestParameters.pbxOutboundRule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOutboundRule operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiCreateOutboundRuleRequest
 */
export interface OutboundRulesApiCreateOutboundRuleRequest {
    /**
     * New entity
     * @type {PbxOutboundRule}
     * @memberof OutboundRulesApiCreateOutboundRule
     */
    readonly pbxOutboundRule: PbxOutboundRule
}

/**
 * Request parameters for deleteOutboundRule operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiDeleteOutboundRuleRequest
 */
export interface OutboundRulesApiDeleteOutboundRuleRequest {
    /**
     * The unique identifier of OutboundRule
     * @type {number}
     * @memberof OutboundRulesApiDeleteOutboundRule
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof OutboundRulesApiDeleteOutboundRule
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getEmergencyOutboundRules operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiGetEmergencyOutboundRulesRequest
 */
export interface OutboundRulesApiGetEmergencyOutboundRulesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof OutboundRulesApiGetEmergencyOutboundRules
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getOutboundRule operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiGetOutboundRuleRequest
 */
export interface OutboundRulesApiGetOutboundRuleRequest {
    /**
     * The unique identifier of OutboundRule
     * @type {number}
     * @memberof OutboundRulesApiGetOutboundRule
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof OutboundRulesApiGetOutboundRule
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof OutboundRulesApiGetOutboundRule
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listOutboundRule operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiListOutboundRuleRequest
 */
export interface OutboundRulesApiListOutboundRuleRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof OutboundRulesApiListOutboundRule
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for moveUpDown operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiMoveUpDownRequest
 */
export interface OutboundRulesApiMoveUpDownRequest {
    /**
     * Action parameters
     * @type {OutboundRulesMoveUpDownRequestBody}
     * @memberof OutboundRulesApiMoveUpDown
     */
    readonly outboundRulesMoveUpDownRequestBody: OutboundRulesMoveUpDownRequestBody
}

/**
 * Request parameters for purge operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiPurgeRequest
 */
export interface OutboundRulesApiPurgeRequest {
    /**
     * Action parameters
     * @type {OutboundRulesPurgeRequestBody}
     * @memberof OutboundRulesApiPurge
     */
    readonly outboundRulesPurgeRequestBody: OutboundRulesPurgeRequestBody
}

/**
 * Request parameters for updateOutboundRule operation in OutboundRulesApi.
 * @export
 * @interface OutboundRulesApiUpdateOutboundRuleRequest
 */
export interface OutboundRulesApiUpdateOutboundRuleRequest {
    /**
     * The unique identifier of OutboundRule
     * @type {number}
     * @memberof OutboundRulesApiUpdateOutboundRule
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxOutboundRule}
     * @memberof OutboundRulesApiUpdateOutboundRule
     */
    readonly pbxOutboundRule: PbxOutboundRule
}

/**
 * OutboundRulesApi - object-oriented interface
 * @export
 * @class OutboundRulesApi
 * @extends {BaseAPI}
 */
export class OutboundRulesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to OutboundRules
     * @param {OutboundRulesApiCreateOutboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public createOutboundRule(requestParameters: OutboundRulesApiCreateOutboundRuleRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).createOutboundRule(requestParameters.pbxOutboundRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from OutboundRules
     * @param {OutboundRulesApiDeleteOutboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public deleteOutboundRule(requestParameters: OutboundRulesApiDeleteOutboundRuleRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).deleteOutboundRule(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetEmergencyOutboundRules
     * @param {OutboundRulesApiGetEmergencyOutboundRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public getEmergencyOutboundRules(requestParameters: OutboundRulesApiGetEmergencyOutboundRulesRequest = {}, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).getEmergencyOutboundRules(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from OutboundRules by key
     * @param {OutboundRulesApiGetOutboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public getOutboundRule(requestParameters: OutboundRulesApiGetOutboundRuleRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).getOutboundRule(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from OutboundRules
     * @param {OutboundRulesApiListOutboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public listOutboundRule(requestParameters: OutboundRulesApiListOutboundRuleRequest = {}, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).listOutboundRule(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MoveUpDown
     * @param {OutboundRulesApiMoveUpDownRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public moveUpDown(requestParameters: OutboundRulesApiMoveUpDownRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).moveUpDown(requestParameters.outboundRulesMoveUpDownRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Purge
     * @param {OutboundRulesApiPurgeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public purge(requestParameters: OutboundRulesApiPurgeRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).purge(requestParameters.outboundRulesPurgeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in OutboundRules
     * @param {OutboundRulesApiUpdateOutboundRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutboundRulesApi
     */
    public updateOutboundRule(requestParameters: OutboundRulesApiUpdateOutboundRuleRequest, options?: RawAxiosRequestConfig) {
        return OutboundRulesApiFp(this.configuration).updateOutboundRule(requestParameters.id, requestParameters.pbxOutboundRule, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParametersApi - axios parameter creator
 * @export
 */
export const ParametersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Parameters
         * @param {PbxParameter} pbxParameter New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameter: async (pbxParameter: PbxParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxParameter' is not null or undefined
            assertParamExists('createParameter', 'pbxParameter', pbxParameter)
            const localVarPath = `/Parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Parameters
         * @param {number} id The unique identifier of Parameter
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParameter: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteParameter', 'id', id)
            const localVarPath = `/Parameters({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Parameters by key
         * @param {number} id The unique identifier of Parameter
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameter: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getParameter', 'id', id)
            const localVarPath = `/Parameters({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetParameterByName
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getParameterByName', 'name', name)
            const localVarPath = `/Parameters/Pbx.GetParameterByName(name={name})`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Parameters
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParameter: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Parameters
         * @param {number} id The unique identifier of Parameter
         * @param {PbxParameter} pbxParameter New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameter: async (id: number, pbxParameter: PbxParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateParameter', 'id', id)
            // verify required parameter 'pbxParameter' is not null or undefined
            assertParamExists('updateParameter', 'pbxParameter', pbxParameter)
            const localVarPath = `/Parameters({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParametersApi - functional programming interface
 * @export
 */
export const ParametersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParametersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Parameters
         * @param {PbxParameter} pbxParameter New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParameter(pbxParameter: PbxParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParameter(pbxParameter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.createParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Parameters
         * @param {number} id The unique identifier of Parameter
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParameter(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParameter(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.deleteParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Parameters by key
         * @param {number} id The unique identifier of Parameter
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParameter(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParameter(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.getParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetParameterByName
         * @param {string} name Usage: name&#x3D;{name}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParameterByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParameterByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.getParameterByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Parameters
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParameter($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParameterCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParameter($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.listParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Parameters
         * @param {number} id The unique identifier of Parameter
         * @param {PbxParameter} pbxParameter New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameter(id: number, pbxParameter: PbxParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameter(id, pbxParameter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParametersApi.updateParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParametersApi - factory interface
 * @export
 */
export const ParametersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParametersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Parameters
         * @param {ParametersApiCreateParameterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameter(requestParameters: ParametersApiCreateParameterRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParameter> {
            return localVarFp.createParameter(requestParameters.pbxParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Parameters
         * @param {ParametersApiDeleteParameterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParameter(requestParameters: ParametersApiDeleteParameterRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteParameter(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Parameters by key
         * @param {ParametersApiGetParameterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameter(requestParameters: ParametersApiGetParameterRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParameter> {
            return localVarFp.getParameter(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetParameterByName
         * @param {ParametersApiGetParameterByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterByName(requestParameters: ParametersApiGetParameterByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParameter> {
            return localVarFp.getParameterByName(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Parameters
         * @param {ParametersApiListParameterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParameter(requestParameters: ParametersApiListParameterRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxParameterCollectionResponse> {
            return localVarFp.listParameter(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Parameters
         * @param {ParametersApiUpdateParameterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameter(requestParameters: ParametersApiUpdateParameterRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateParameter(requestParameters.id, requestParameters.pbxParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createParameter operation in ParametersApi.
 * @export
 * @interface ParametersApiCreateParameterRequest
 */
export interface ParametersApiCreateParameterRequest {
    /**
     * New entity
     * @type {PbxParameter}
     * @memberof ParametersApiCreateParameter
     */
    readonly pbxParameter: PbxParameter
}

/**
 * Request parameters for deleteParameter operation in ParametersApi.
 * @export
 * @interface ParametersApiDeleteParameterRequest
 */
export interface ParametersApiDeleteParameterRequest {
    /**
     * The unique identifier of Parameter
     * @type {number}
     * @memberof ParametersApiDeleteParameter
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ParametersApiDeleteParameter
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getParameter operation in ParametersApi.
 * @export
 * @interface ParametersApiGetParameterRequest
 */
export interface ParametersApiGetParameterRequest {
    /**
     * The unique identifier of Parameter
     * @type {number}
     * @memberof ParametersApiGetParameter
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ParametersApiGetParameter
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ParametersApiGetParameter
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getParameterByName operation in ParametersApi.
 * @export
 * @interface ParametersApiGetParameterByNameRequest
 */
export interface ParametersApiGetParameterByNameRequest {
    /**
     * Usage: name&#x3D;{name}
     * @type {string}
     * @memberof ParametersApiGetParameterByName
     */
    readonly name: string
}

/**
 * Request parameters for listParameter operation in ParametersApi.
 * @export
 * @interface ParametersApiListParameterRequest
 */
export interface ParametersApiListParameterRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ParametersApiListParameter
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ParametersApiListParameter
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ParametersApiListParameter
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ParametersApiListParameter
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ParametersApiListParameter
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ParametersApiListParameter
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ParametersApiListParameter
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ParametersApiListParameter
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateParameter operation in ParametersApi.
 * @export
 * @interface ParametersApiUpdateParameterRequest
 */
export interface ParametersApiUpdateParameterRequest {
    /**
     * The unique identifier of Parameter
     * @type {number}
     * @memberof ParametersApiUpdateParameter
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxParameter}
     * @memberof ParametersApiUpdateParameter
     */
    readonly pbxParameter: PbxParameter
}

/**
 * ParametersApi - object-oriented interface
 * @export
 * @class ParametersApi
 * @extends {BaseAPI}
 */
export class ParametersApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Parameters
     * @param {ParametersApiCreateParameterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public createParameter(requestParameters: ParametersApiCreateParameterRequest, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).createParameter(requestParameters.pbxParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Parameters
     * @param {ParametersApiDeleteParameterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public deleteParameter(requestParameters: ParametersApiDeleteParameterRequest, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).deleteParameter(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Parameters by key
     * @param {ParametersApiGetParameterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public getParameter(requestParameters: ParametersApiGetParameterRequest, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).getParameter(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetParameterByName
     * @param {ParametersApiGetParameterByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public getParameterByName(requestParameters: ParametersApiGetParameterByNameRequest, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).getParameterByName(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Parameters
     * @param {ParametersApiListParameterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public listParameter(requestParameters: ParametersApiListParameterRequest = {}, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).listParameter(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Parameters
     * @param {ParametersApiUpdateParameterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public updateParameter(requestParameters: ParametersApiUpdateParameterRequest, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).updateParameter(requestParameters.id, requestParameters.pbxParameter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParkingsApi - axios parameter creator
 * @export
 */
export const ParkingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Parkings
         * @param {PbxParking} pbxParking New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParking: async (pbxParking: PbxParking, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxParking' is not null or undefined
            assertParamExists('createParking', 'pbxParking', pbxParking)
            const localVarPath = `/Parkings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxParking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Parkings
         * @param {number} id The unique identifier of Parking
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParking: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteParking', 'id', id)
            const localVarPath = `/Parkings({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getByNumber', 'number', number)
            const localVarPath = `/Parkings/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Parkings by key
         * @param {number} id The unique identifier of Parking
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParking: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getParking', 'id', id)
            const localVarPath = `/Parkings({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Parkings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParking: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Parkings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Groups from Parkings
         * @param {number} id The unique identifier of Parking
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParkingGroups: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listParkingGroups', 'id', id)
            const localVarPath = `/Parkings({Id})/Groups`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Parkings
         * @param {number} id The unique identifier of Parking
         * @param {PbxParking} pbxParking New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParking: async (id: number, pbxParking: PbxParking, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateParking', 'id', id)
            // verify required parameter 'pbxParking' is not null or undefined
            assertParamExists('updateParking', 'pbxParking', pbxParking)
            const localVarPath = `/Parkings({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxParking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParkingsApi - functional programming interface
 * @export
 */
export const ParkingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParkingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Parkings
         * @param {PbxParking} pbxParking New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParking(pbxParking: PbxParking, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParking(pbxParking, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.createParking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Parkings
         * @param {number} id The unique identifier of Parking
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParking(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParking(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.deleteParking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.getByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Parkings by key
         * @param {number} id The unique identifier of Parking
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParking(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParking(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.getParking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Parkings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParking($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxParkingCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParking($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.listParking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Groups from Parkings
         * @param {number} id The unique identifier of Parking
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParkingGroups(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParkingGroups(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.listParkingGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Parkings
         * @param {number} id The unique identifier of Parking
         * @param {PbxParking} pbxParking New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParking(id: number, pbxParking: PbxParking, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParking(id, pbxParking, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParkingsApi.updateParking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParkingsApi - factory interface
 * @export
 */
export const ParkingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParkingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Parkings
         * @param {ParkingsApiCreateParkingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParking(requestParameters: ParkingsApiCreateParkingRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParking> {
            return localVarFp.createParking(requestParameters.pbxParking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Parkings
         * @param {ParkingsApiDeleteParkingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParking(requestParameters: ParkingsApiDeleteParkingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteParking(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {ParkingsApiGetByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByNumber(requestParameters: ParkingsApiGetByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParking> {
            return localVarFp.getByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Parkings by key
         * @param {ParkingsApiGetParkingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParking(requestParameters: ParkingsApiGetParkingRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxParking> {
            return localVarFp.getParking(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Parkings
         * @param {ParkingsApiListParkingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParking(requestParameters: ParkingsApiListParkingRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxParkingCollectionResponse> {
            return localVarFp.listParking(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Groups from Parkings
         * @param {ParkingsApiListParkingGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParkingGroups(requestParameters: ParkingsApiListParkingGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserGroupCollectionResponse> {
            return localVarFp.listParkingGroups(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Parkings
         * @param {ParkingsApiUpdateParkingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParking(requestParameters: ParkingsApiUpdateParkingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateParking(requestParameters.id, requestParameters.pbxParking, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createParking operation in ParkingsApi.
 * @export
 * @interface ParkingsApiCreateParkingRequest
 */
export interface ParkingsApiCreateParkingRequest {
    /**
     * New entity
     * @type {PbxParking}
     * @memberof ParkingsApiCreateParking
     */
    readonly pbxParking: PbxParking
}

/**
 * Request parameters for deleteParking operation in ParkingsApi.
 * @export
 * @interface ParkingsApiDeleteParkingRequest
 */
export interface ParkingsApiDeleteParkingRequest {
    /**
     * The unique identifier of Parking
     * @type {number}
     * @memberof ParkingsApiDeleteParking
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ParkingsApiDeleteParking
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getByNumber operation in ParkingsApi.
 * @export
 * @interface ParkingsApiGetByNumberRequest
 */
export interface ParkingsApiGetByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof ParkingsApiGetByNumber
     */
    readonly number: string
}

/**
 * Request parameters for getParking operation in ParkingsApi.
 * @export
 * @interface ParkingsApiGetParkingRequest
 */
export interface ParkingsApiGetParkingRequest {
    /**
     * The unique identifier of Parking
     * @type {number}
     * @memberof ParkingsApiGetParking
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ParkingsApiGetParking
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ParkingsApiGetParking
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listParking operation in ParkingsApi.
 * @export
 * @interface ParkingsApiListParkingRequest
 */
export interface ParkingsApiListParkingRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ParkingsApiListParking
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ParkingsApiListParking
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ParkingsApiListParking
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ParkingsApiListParking
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ParkingsApiListParking
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ParkingsApiListParking
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ParkingsApiListParking
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ParkingsApiListParking
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listParkingGroups operation in ParkingsApi.
 * @export
 * @interface ParkingsApiListParkingGroupsRequest
 */
export interface ParkingsApiListParkingGroupsRequest {
    /**
     * The unique identifier of Parking
     * @type {number}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ParkingsApiListParkingGroups
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateParking operation in ParkingsApi.
 * @export
 * @interface ParkingsApiUpdateParkingRequest
 */
export interface ParkingsApiUpdateParkingRequest {
    /**
     * The unique identifier of Parking
     * @type {number}
     * @memberof ParkingsApiUpdateParking
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxParking}
     * @memberof ParkingsApiUpdateParking
     */
    readonly pbxParking: PbxParking
}

/**
 * ParkingsApi - object-oriented interface
 * @export
 * @class ParkingsApi
 * @extends {BaseAPI}
 */
export class ParkingsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Parkings
     * @param {ParkingsApiCreateParkingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public createParking(requestParameters: ParkingsApiCreateParkingRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).createParking(requestParameters.pbxParking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Parkings
     * @param {ParkingsApiDeleteParkingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public deleteParking(requestParameters: ParkingsApiDeleteParkingRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).deleteParking(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {ParkingsApiGetByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public getByNumber(requestParameters: ParkingsApiGetByNumberRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).getByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Parkings by key
     * @param {ParkingsApiGetParkingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public getParking(requestParameters: ParkingsApiGetParkingRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).getParking(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Parkings
     * @param {ParkingsApiListParkingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public listParking(requestParameters: ParkingsApiListParkingRequest = {}, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).listParking(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Groups from Parkings
     * @param {ParkingsApiListParkingGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public listParkingGroups(requestParameters: ParkingsApiListParkingGroupsRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).listParkingGroups(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Parkings
     * @param {ParkingsApiUpdateParkingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParkingsApi
     */
    public updateParking(requestParameters: ParkingsApiUpdateParkingRequest, options?: RawAxiosRequestConfig) {
        return ParkingsApiFp(this.configuration).updateParking(requestParameters.id, requestParameters.pbxParking, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeersApi - axios parameter creator
 * @export
 */
export const PeersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function GetPeerByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getPeerByNumber', 'number', number)
            const localVarPath = `/Peers/Pbx.GetPeerByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetReportPeers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportPeers: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Peers/Pbx.GetReportPeers()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Peers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeer: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Peers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeersApi - functional programming interface
 * @export
 */
export const PeersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetPeerByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeerByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPeer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeerByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeersApi.getPeerByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetReportPeers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportPeers($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfPeer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportPeers($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeersApi.getReportPeers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Peers
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPeer($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPeerCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPeer($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeersApi.listPeer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeersApi - factory interface
 * @export
 */
export const PeersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeersApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function GetPeerByNumber
         * @param {PeersApiGetPeerByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerByNumber(requestParameters: PeersApiGetPeerByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPeer> {
            return localVarFp.getPeerByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetReportPeers
         * @param {PeersApiGetReportPeersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportPeers(requestParameters: PeersApiGetReportPeersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfPeer> {
            return localVarFp.getReportPeers(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Peers
         * @param {PeersApiListPeerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPeer(requestParameters: PeersApiListPeerRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPeerCollectionResponse> {
            return localVarFp.listPeer(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPeerByNumber operation in PeersApi.
 * @export
 * @interface PeersApiGetPeerByNumberRequest
 */
export interface PeersApiGetPeerByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof PeersApiGetPeerByNumber
     */
    readonly number: string
}

/**
 * Request parameters for getReportPeers operation in PeersApi.
 * @export
 * @interface PeersApiGetReportPeersRequest
 */
export interface PeersApiGetReportPeersRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PeersApiGetReportPeers
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PeersApiGetReportPeers
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PeersApiGetReportPeers
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PeersApiGetReportPeers
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PeersApiGetReportPeers
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PeersApiGetReportPeers
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PeersApiGetReportPeers
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PeersApiGetReportPeers
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listPeer operation in PeersApi.
 * @export
 * @interface PeersApiListPeerRequest
 */
export interface PeersApiListPeerRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PeersApiListPeer
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PeersApiListPeer
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PeersApiListPeer
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PeersApiListPeer
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PeersApiListPeer
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PeersApiListPeer
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PeersApiListPeer
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PeersApiListPeer
     */
    readonly $expand?: Set<string>
}

/**
 * PeersApi - object-oriented interface
 * @export
 * @class PeersApi
 * @extends {BaseAPI}
 */
export class PeersApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function GetPeerByNumber
     * @param {PeersApiGetPeerByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public getPeerByNumber(requestParameters: PeersApiGetPeerByNumberRequest, options?: RawAxiosRequestConfig) {
        return PeersApiFp(this.configuration).getPeerByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetReportPeers
     * @param {PeersApiGetReportPeersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public getReportPeers(requestParameters: PeersApiGetReportPeersRequest = {}, options?: RawAxiosRequestConfig) {
        return PeersApiFp(this.configuration).getReportPeers(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Peers
     * @param {PeersApiListPeerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public listPeer(requestParameters: PeersApiListPeerRequest = {}, options?: RawAxiosRequestConfig) {
        return PeersApiFp(this.configuration).listPeer(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhoneBookSettingsApi - axios parameter creator
 * @export
 */
export const PhoneBookSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get PhoneBookSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneBookSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PhoneBookSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update PhoneBookSettings
         * @param {PbxPhoneBookSettings} pbxPhoneBookSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneBookSettings: async (pbxPhoneBookSettings: PbxPhoneBookSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxPhoneBookSettings' is not null or undefined
            assertParamExists('updatePhoneBookSettings', 'pbxPhoneBookSettings', pbxPhoneBookSettings)
            const localVarPath = `/PhoneBookSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPhoneBookSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneBookSettingsApi - functional programming interface
 * @export
 */
export const PhoneBookSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhoneBookSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get PhoneBookSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoneBookSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneBookSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoneBookSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneBookSettingsApi.getPhoneBookSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update PhoneBookSettings
         * @param {PbxPhoneBookSettings} pbxPhoneBookSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneBookSettings(pbxPhoneBookSettings: PbxPhoneBookSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneBookSettings(pbxPhoneBookSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneBookSettingsApi.updatePhoneBookSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhoneBookSettingsApi - factory interface
 * @export
 */
export const PhoneBookSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhoneBookSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get PhoneBookSettings
         * @param {PhoneBookSettingsApiGetPhoneBookSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneBookSettings(requestParameters: PhoneBookSettingsApiGetPhoneBookSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneBookSettings> {
            return localVarFp.getPhoneBookSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update PhoneBookSettings
         * @param {PhoneBookSettingsApiUpdatePhoneBookSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneBookSettings(requestParameters: PhoneBookSettingsApiUpdatePhoneBookSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePhoneBookSettings(requestParameters.pbxPhoneBookSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPhoneBookSettings operation in PhoneBookSettingsApi.
 * @export
 * @interface PhoneBookSettingsApiGetPhoneBookSettingsRequest
 */
export interface PhoneBookSettingsApiGetPhoneBookSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PhoneBookSettingsApiGetPhoneBookSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PhoneBookSettingsApiGetPhoneBookSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updatePhoneBookSettings operation in PhoneBookSettingsApi.
 * @export
 * @interface PhoneBookSettingsApiUpdatePhoneBookSettingsRequest
 */
export interface PhoneBookSettingsApiUpdatePhoneBookSettingsRequest {
    /**
     * New property values
     * @type {PbxPhoneBookSettings}
     * @memberof PhoneBookSettingsApiUpdatePhoneBookSettings
     */
    readonly pbxPhoneBookSettings: PbxPhoneBookSettings
}

/**
 * PhoneBookSettingsApi - object-oriented interface
 * @export
 * @class PhoneBookSettingsApi
 * @extends {BaseAPI}
 */
export class PhoneBookSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get PhoneBookSettings
     * @param {PhoneBookSettingsApiGetPhoneBookSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneBookSettingsApi
     */
    public getPhoneBookSettings(requestParameters: PhoneBookSettingsApiGetPhoneBookSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return PhoneBookSettingsApiFp(this.configuration).getPhoneBookSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update PhoneBookSettings
     * @param {PhoneBookSettingsApiUpdatePhoneBookSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneBookSettingsApi
     */
    public updatePhoneBookSettings(requestParameters: PhoneBookSettingsApiUpdatePhoneBookSettingsRequest, options?: RawAxiosRequestConfig) {
        return PhoneBookSettingsApiFp(this.configuration).updatePhoneBookSettings(requestParameters.pbxPhoneBookSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhoneLogosApi - axios parameter creator
 * @export
 */
export const PhoneLogosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete entity from PhoneLogos
         * @param {string} filename The unique identifier of PhoneLogo
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoneLogo: async (filename: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('deletePhoneLogo', 'filename', filename)
            const localVarPath = `/PhoneLogos({Filename})`
                .replace(`{${"Filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from PhoneLogos
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneLogo: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PhoneLogos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneLogosApi - functional programming interface
 * @export
 */
export const PhoneLogosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhoneLogosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete entity from PhoneLogos
         * @param {string} filename The unique identifier of PhoneLogo
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoneLogo(filename: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhoneLogo(filename, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneLogosApi.deletePhoneLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from PhoneLogos
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPhoneLogo($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneLogoCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPhoneLogo($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneLogosApi.listPhoneLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhoneLogosApi - factory interface
 * @export
 */
export const PhoneLogosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhoneLogosApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete entity from PhoneLogos
         * @param {PhoneLogosApiDeletePhoneLogoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoneLogo(requestParameters: PhoneLogosApiDeletePhoneLogoRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePhoneLogo(requestParameters.filename, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from PhoneLogos
         * @param {PhoneLogosApiListPhoneLogoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneLogo(requestParameters: PhoneLogosApiListPhoneLogoRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneLogoCollectionResponse> {
            return localVarFp.listPhoneLogo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deletePhoneLogo operation in PhoneLogosApi.
 * @export
 * @interface PhoneLogosApiDeletePhoneLogoRequest
 */
export interface PhoneLogosApiDeletePhoneLogoRequest {
    /**
     * The unique identifier of PhoneLogo
     * @type {string}
     * @memberof PhoneLogosApiDeletePhoneLogo
     */
    readonly filename: string

    /**
     * ETag
     * @type {string}
     * @memberof PhoneLogosApiDeletePhoneLogo
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for listPhoneLogo operation in PhoneLogosApi.
 * @export
 * @interface PhoneLogosApiListPhoneLogoRequest
 */
export interface PhoneLogosApiListPhoneLogoRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PhoneLogosApiListPhoneLogo
     */
    readonly $expand?: Set<string>
}

/**
 * PhoneLogosApi - object-oriented interface
 * @export
 * @class PhoneLogosApi
 * @extends {BaseAPI}
 */
export class PhoneLogosApi extends BaseAPI {
    /**
     * 
     * @summary Delete entity from PhoneLogos
     * @param {PhoneLogosApiDeletePhoneLogoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneLogosApi
     */
    public deletePhoneLogo(requestParameters: PhoneLogosApiDeletePhoneLogoRequest, options?: RawAxiosRequestConfig) {
        return PhoneLogosApiFp(this.configuration).deletePhoneLogo(requestParameters.filename, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from PhoneLogos
     * @param {PhoneLogosApiListPhoneLogoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneLogosApi
     */
    public listPhoneLogo(requestParameters: PhoneLogosApiListPhoneLogoRequest = {}, options?: RawAxiosRequestConfig) {
        return PhoneLogosApiFp(this.configuration).listPhoneLogo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhoneTemplatesApi - axios parameter creator
 * @export
 */
export const PhoneTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to PhoneTemplates
         * @param {PbxPhoneTemplate} pbxPhoneTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhoneTemplate: async (pbxPhoneTemplate: PbxPhoneTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxPhoneTemplate' is not null or undefined
            assertParamExists('createPhoneTemplate', 'pbxPhoneTemplate', pbxPhoneTemplate)
            const localVarPath = `/PhoneTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPhoneTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from PhoneTemplates
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoneTemplate: async (id: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePhoneTemplate', 'id', id)
            const localVarPath = `/PhoneTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from PhoneTemplates by key
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneTemplate: async (id: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhoneTemplate', 'id', id)
            const localVarPath = `/PhoneTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from PhoneTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneTemplate: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PhoneTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in PhoneTemplates
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {PbxPhoneTemplate} pbxPhoneTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneTemplate: async (id: string, pbxPhoneTemplate: PbxPhoneTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePhoneTemplate', 'id', id)
            // verify required parameter 'pbxPhoneTemplate' is not null or undefined
            assertParamExists('updatePhoneTemplate', 'pbxPhoneTemplate', pbxPhoneTemplate)
            const localVarPath = `/PhoneTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPhoneTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneTemplatesApi - functional programming interface
 * @export
 */
export const PhoneTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhoneTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to PhoneTemplates
         * @param {PbxPhoneTemplate} pbxPhoneTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhoneTemplate(pbxPhoneTemplate: PbxPhoneTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhoneTemplate(pbxPhoneTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneTemplatesApi.createPhoneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from PhoneTemplates
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoneTemplate(id: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhoneTemplate(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneTemplatesApi.deletePhoneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from PhoneTemplates by key
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoneTemplate(id: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoneTemplate(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneTemplatesApi.getPhoneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from PhoneTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPhoneTemplate($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneTemplateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPhoneTemplate($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneTemplatesApi.listPhoneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in PhoneTemplates
         * @param {string} id The unique identifier of PhoneTemplate
         * @param {PbxPhoneTemplate} pbxPhoneTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoneTemplate(id: string, pbxPhoneTemplate: PbxPhoneTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoneTemplate(id, pbxPhoneTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhoneTemplatesApi.updatePhoneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhoneTemplatesApi - factory interface
 * @export
 */
export const PhoneTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhoneTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to PhoneTemplates
         * @param {PhoneTemplatesApiCreatePhoneTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhoneTemplate(requestParameters: PhoneTemplatesApiCreatePhoneTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneTemplate> {
            return localVarFp.createPhoneTemplate(requestParameters.pbxPhoneTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from PhoneTemplates
         * @param {PhoneTemplatesApiDeletePhoneTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoneTemplate(requestParameters: PhoneTemplatesApiDeletePhoneTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePhoneTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from PhoneTemplates by key
         * @param {PhoneTemplatesApiGetPhoneTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneTemplate(requestParameters: PhoneTemplatesApiGetPhoneTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneTemplate> {
            return localVarFp.getPhoneTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from PhoneTemplates
         * @param {PhoneTemplatesApiListPhoneTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhoneTemplate(requestParameters: PhoneTemplatesApiListPhoneTemplateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneTemplateCollectionResponse> {
            return localVarFp.listPhoneTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in PhoneTemplates
         * @param {PhoneTemplatesApiUpdatePhoneTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoneTemplate(requestParameters: PhoneTemplatesApiUpdatePhoneTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePhoneTemplate(requestParameters.id, requestParameters.pbxPhoneTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPhoneTemplate operation in PhoneTemplatesApi.
 * @export
 * @interface PhoneTemplatesApiCreatePhoneTemplateRequest
 */
export interface PhoneTemplatesApiCreatePhoneTemplateRequest {
    /**
     * New entity
     * @type {PbxPhoneTemplate}
     * @memberof PhoneTemplatesApiCreatePhoneTemplate
     */
    readonly pbxPhoneTemplate: PbxPhoneTemplate
}

/**
 * Request parameters for deletePhoneTemplate operation in PhoneTemplatesApi.
 * @export
 * @interface PhoneTemplatesApiDeletePhoneTemplateRequest
 */
export interface PhoneTemplatesApiDeletePhoneTemplateRequest {
    /**
     * The unique identifier of PhoneTemplate
     * @type {string}
     * @memberof PhoneTemplatesApiDeletePhoneTemplate
     */
    readonly id: string

    /**
     * ETag
     * @type {string}
     * @memberof PhoneTemplatesApiDeletePhoneTemplate
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getPhoneTemplate operation in PhoneTemplatesApi.
 * @export
 * @interface PhoneTemplatesApiGetPhoneTemplateRequest
 */
export interface PhoneTemplatesApiGetPhoneTemplateRequest {
    /**
     * The unique identifier of PhoneTemplate
     * @type {string}
     * @memberof PhoneTemplatesApiGetPhoneTemplate
     */
    readonly id: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PhoneTemplatesApiGetPhoneTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PhoneTemplatesApiGetPhoneTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listPhoneTemplate operation in PhoneTemplatesApi.
 * @export
 * @interface PhoneTemplatesApiListPhoneTemplateRequest
 */
export interface PhoneTemplatesApiListPhoneTemplateRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PhoneTemplatesApiListPhoneTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updatePhoneTemplate operation in PhoneTemplatesApi.
 * @export
 * @interface PhoneTemplatesApiUpdatePhoneTemplateRequest
 */
export interface PhoneTemplatesApiUpdatePhoneTemplateRequest {
    /**
     * The unique identifier of PhoneTemplate
     * @type {string}
     * @memberof PhoneTemplatesApiUpdatePhoneTemplate
     */
    readonly id: string

    /**
     * New property values
     * @type {PbxPhoneTemplate}
     * @memberof PhoneTemplatesApiUpdatePhoneTemplate
     */
    readonly pbxPhoneTemplate: PbxPhoneTemplate
}

/**
 * PhoneTemplatesApi - object-oriented interface
 * @export
 * @class PhoneTemplatesApi
 * @extends {BaseAPI}
 */
export class PhoneTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to PhoneTemplates
     * @param {PhoneTemplatesApiCreatePhoneTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneTemplatesApi
     */
    public createPhoneTemplate(requestParameters: PhoneTemplatesApiCreatePhoneTemplateRequest, options?: RawAxiosRequestConfig) {
        return PhoneTemplatesApiFp(this.configuration).createPhoneTemplate(requestParameters.pbxPhoneTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from PhoneTemplates
     * @param {PhoneTemplatesApiDeletePhoneTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneTemplatesApi
     */
    public deletePhoneTemplate(requestParameters: PhoneTemplatesApiDeletePhoneTemplateRequest, options?: RawAxiosRequestConfig) {
        return PhoneTemplatesApiFp(this.configuration).deletePhoneTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from PhoneTemplates by key
     * @param {PhoneTemplatesApiGetPhoneTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneTemplatesApi
     */
    public getPhoneTemplate(requestParameters: PhoneTemplatesApiGetPhoneTemplateRequest, options?: RawAxiosRequestConfig) {
        return PhoneTemplatesApiFp(this.configuration).getPhoneTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from PhoneTemplates
     * @param {PhoneTemplatesApiListPhoneTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneTemplatesApi
     */
    public listPhoneTemplate(requestParameters: PhoneTemplatesApiListPhoneTemplateRequest = {}, options?: RawAxiosRequestConfig) {
        return PhoneTemplatesApiFp(this.configuration).listPhoneTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in PhoneTemplates
     * @param {PhoneTemplatesApiUpdatePhoneTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneTemplatesApi
     */
    public updatePhoneTemplate(requestParameters: PhoneTemplatesApiUpdatePhoneTemplateRequest, options?: RawAxiosRequestConfig) {
        return PhoneTemplatesApiFp(this.configuration).updatePhoneTemplate(requestParameters.id, requestParameters.pbxPhoneTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhonesSettingsApi - axios parameter creator
 * @export
 */
export const PhonesSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get PhonesSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhonesSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PhonesSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update PhonesSettings
         * @param {PbxPhonesSettings} pbxPhonesSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhonesSettings: async (pbxPhonesSettings: PbxPhonesSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxPhonesSettings' is not null or undefined
            assertParamExists('updatePhonesSettings', 'pbxPhonesSettings', pbxPhonesSettings)
            const localVarPath = `/PhonesSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPhonesSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhonesSettingsApi - functional programming interface
 * @export
 */
export const PhonesSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhonesSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get PhonesSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhonesSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhonesSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhonesSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhonesSettingsApi.getPhonesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update PhonesSettings
         * @param {PbxPhonesSettings} pbxPhonesSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhonesSettings(pbxPhonesSettings: PbxPhonesSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhonesSettings(pbxPhonesSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhonesSettingsApi.updatePhonesSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhonesSettingsApi - factory interface
 * @export
 */
export const PhonesSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhonesSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get PhonesSettings
         * @param {PhonesSettingsApiGetPhonesSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhonesSettings(requestParameters: PhonesSettingsApiGetPhonesSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhonesSettings> {
            return localVarFp.getPhonesSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update PhonesSettings
         * @param {PhonesSettingsApiUpdatePhonesSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhonesSettings(requestParameters: PhonesSettingsApiUpdatePhonesSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePhonesSettings(requestParameters.pbxPhonesSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPhonesSettings operation in PhonesSettingsApi.
 * @export
 * @interface PhonesSettingsApiGetPhonesSettingsRequest
 */
export interface PhonesSettingsApiGetPhonesSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PhonesSettingsApiGetPhonesSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PhonesSettingsApiGetPhonesSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updatePhonesSettings operation in PhonesSettingsApi.
 * @export
 * @interface PhonesSettingsApiUpdatePhonesSettingsRequest
 */
export interface PhonesSettingsApiUpdatePhonesSettingsRequest {
    /**
     * New property values
     * @type {PbxPhonesSettings}
     * @memberof PhonesSettingsApiUpdatePhonesSettings
     */
    readonly pbxPhonesSettings: PbxPhonesSettings
}

/**
 * PhonesSettingsApi - object-oriented interface
 * @export
 * @class PhonesSettingsApi
 * @extends {BaseAPI}
 */
export class PhonesSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get PhonesSettings
     * @param {PhonesSettingsApiGetPhonesSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonesSettingsApi
     */
    public getPhonesSettings(requestParameters: PhonesSettingsApiGetPhonesSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return PhonesSettingsApiFp(this.configuration).getPhonesSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update PhonesSettings
     * @param {PhonesSettingsApiUpdatePhonesSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonesSettingsApi
     */
    public updatePhonesSettings(requestParameters: PhonesSettingsApiUpdatePhonesSettingsRequest, options?: RawAxiosRequestConfig) {
        return PhonesSettingsApiFp(this.configuration).updatePhonesSettings(requestParameters.pbxPhonesSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Playlists
         * @param {PbxPlaylist} pbxPlaylist New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (pbxPlaylist: PbxPlaylist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxPlaylist' is not null or undefined
            assertParamExists('createPlaylist', 'pbxPlaylist', pbxPlaylist)
            const localVarPath = `/Playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPlaylist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Playlists
         * @param {string} name The unique identifier of Playlist
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (name: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deletePlaylist', 'name', name)
            const localVarPath = `/Playlists({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action DeletePlaylistFile
         * @param {PlaylistsDeletePlaylistFileRequestBody} playlistsDeletePlaylistFileRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylistFile: async (playlistsDeletePlaylistFileRequestBody: PlaylistsDeletePlaylistFileRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistsDeletePlaylistFileRequestBody' is not null or undefined
            assertParamExists('deletePlaylistFile', 'playlistsDeletePlaylistFileRequestBody', playlistsDeletePlaylistFileRequestBody)
            const localVarPath = `/Playlists/Pbx.DeletePlaylistFile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistsDeletePlaylistFileRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function DownloadPlaylistFile
         * @param {string} playlistKey Usage: playlistKey&#x3D;{playlistKey}
         * @param {string} fileName Usage: fileName&#x3D;{fileName}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPlaylistFile: async (playlistKey: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistKey' is not null or undefined
            assertParamExists('downloadPlaylistFile', 'playlistKey', playlistKey)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadPlaylistFile', 'fileName', fileName)
            const localVarPath = `/Playlists/Pbx.DownloadPlaylistFile(playlistKey={playlistKey},fileName={fileName})`
                .replace(`{${"playlistKey"}}`, encodeURIComponent(String(playlistKey)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Playlists by key
         * @param {string} name The unique identifier of Playlist
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: async (name: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPlaylist', 'name', name)
            const localVarPath = `/Playlists({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Playlists
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaylist: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Playlists
         * @param {string} name The unique identifier of Playlist
         * @param {PbxPlaylist} pbxPlaylist New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: async (name: string, pbxPlaylist: PbxPlaylist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updatePlaylist', 'name', name)
            // verify required parameter 'pbxPlaylist' is not null or undefined
            assertParamExists('updatePlaylist', 'pbxPlaylist', pbxPlaylist)
            const localVarPath = `/Playlists({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPlaylist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Playlists
         * @param {PbxPlaylist} pbxPlaylist New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(pbxPlaylist: PbxPlaylist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(pbxPlaylist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.createPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Playlists
         * @param {string} name The unique identifier of Playlist
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(name: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(name, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.deletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action DeletePlaylistFile
         * @param {PlaylistsDeletePlaylistFileRequestBody} playlistsDeletePlaylistFileRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylistFile(playlistsDeletePlaylistFileRequestBody: PlaylistsDeletePlaylistFileRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylistFile(playlistsDeletePlaylistFileRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.deletePlaylistFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function DownloadPlaylistFile
         * @param {string} playlistKey Usage: playlistKey&#x3D;{playlistKey}
         * @param {string} fileName Usage: fileName&#x3D;{fileName}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadPlaylistFile(playlistKey: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadPlaylistFile(playlistKey, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.downloadPlaylistFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Playlists by key
         * @param {string} name The unique identifier of Playlist
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist(name: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist(name, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.getPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Playlists
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaylist($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPlaylistCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaylist($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.listPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Playlists
         * @param {string} name The unique identifier of Playlist
         * @param {PbxPlaylist} pbxPlaylist New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaylist(name: string, pbxPlaylist: PbxPlaylist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaylist(name, pbxPlaylist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.updatePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Playlists
         * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(requestParameters: PlaylistsApiCreatePlaylistRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPlaylist> {
            return localVarFp.createPlaylist(requestParameters.pbxPlaylist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Playlists
         * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePlaylist(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action DeletePlaylistFile
         * @param {PlaylistsApiDeletePlaylistFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylistFile(requestParameters: PlaylistsApiDeletePlaylistFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deletePlaylistFile(requestParameters.playlistsDeletePlaylistFileRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function DownloadPlaylistFile
         * @param {PlaylistsApiDownloadPlaylistFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPlaylistFile(requestParameters: PlaylistsApiDownloadPlaylistFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.downloadPlaylistFile(requestParameters.playlistKey, requestParameters.fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Playlists by key
         * @param {PlaylistsApiGetPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist(requestParameters: PlaylistsApiGetPlaylistRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPlaylist> {
            return localVarFp.getPlaylist(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Playlists
         * @param {PlaylistsApiListPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaylist(requestParameters: PlaylistsApiListPlaylistRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPlaylistCollectionResponse> {
            return localVarFp.listPlaylist(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Playlists
         * @param {PlaylistsApiUpdatePlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist(requestParameters: PlaylistsApiUpdatePlaylistRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePlaylist(requestParameters.name, requestParameters.pbxPlaylist, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiCreatePlaylistRequest
 */
export interface PlaylistsApiCreatePlaylistRequest {
    /**
     * New entity
     * @type {PbxPlaylist}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly pbxPlaylist: PbxPlaylist
}

/**
 * Request parameters for deletePlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiDeletePlaylistRequest
 */
export interface PlaylistsApiDeletePlaylistRequest {
    /**
     * The unique identifier of Playlist
     * @type {string}
     * @memberof PlaylistsApiDeletePlaylist
     */
    readonly name: string

    /**
     * ETag
     * @type {string}
     * @memberof PlaylistsApiDeletePlaylist
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for deletePlaylistFile operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiDeletePlaylistFileRequest
 */
export interface PlaylistsApiDeletePlaylistFileRequest {
    /**
     * Action parameters
     * @type {PlaylistsDeletePlaylistFileRequestBody}
     * @memberof PlaylistsApiDeletePlaylistFile
     */
    readonly playlistsDeletePlaylistFileRequestBody: PlaylistsDeletePlaylistFileRequestBody
}

/**
 * Request parameters for downloadPlaylistFile operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiDownloadPlaylistFileRequest
 */
export interface PlaylistsApiDownloadPlaylistFileRequest {
    /**
     * Usage: playlistKey&#x3D;{playlistKey}
     * @type {string}
     * @memberof PlaylistsApiDownloadPlaylistFile
     */
    readonly playlistKey: string

    /**
     * Usage: fileName&#x3D;{fileName}
     * @type {string}
     * @memberof PlaylistsApiDownloadPlaylistFile
     */
    readonly fileName: string
}

/**
 * Request parameters for getPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistRequest
 */
export interface PlaylistsApiGetPlaylistRequest {
    /**
     * The unique identifier of Playlist
     * @type {string}
     * @memberof PlaylistsApiGetPlaylist
     */
    readonly name: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PlaylistsApiGetPlaylist
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PlaylistsApiGetPlaylist
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiListPlaylistRequest
 */
export interface PlaylistsApiListPlaylistRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PlaylistsApiListPlaylist
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updatePlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiUpdatePlaylistRequest
 */
export interface PlaylistsApiUpdatePlaylistRequest {
    /**
     * The unique identifier of Playlist
     * @type {string}
     * @memberof PlaylistsApiUpdatePlaylist
     */
    readonly name: string

    /**
     * New property values
     * @type {PbxPlaylist}
     * @memberof PlaylistsApiUpdatePlaylist
     */
    readonly pbxPlaylist: PbxPlaylist
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Playlists
     * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(requestParameters: PlaylistsApiCreatePlaylistRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).createPlaylist(requestParameters.pbxPlaylist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Playlists
     * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).deletePlaylist(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action DeletePlaylistFile
     * @param {PlaylistsApiDeletePlaylistFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public deletePlaylistFile(requestParameters: PlaylistsApiDeletePlaylistFileRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).deletePlaylistFile(requestParameters.playlistsDeletePlaylistFileRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function DownloadPlaylistFile
     * @param {PlaylistsApiDownloadPlaylistFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public downloadPlaylistFile(requestParameters: PlaylistsApiDownloadPlaylistFileRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).downloadPlaylistFile(requestParameters.playlistKey, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Playlists by key
     * @param {PlaylistsApiGetPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylist(requestParameters: PlaylistsApiGetPlaylistRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylist(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Playlists
     * @param {PlaylistsApiListPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public listPlaylist(requestParameters: PlaylistsApiListPlaylistRequest = {}, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).listPlaylist(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Playlists
     * @param {PlaylistsApiUpdatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public updatePlaylist(requestParameters: PlaylistsApiUpdatePlaylistRequest, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).updatePlaylist(requestParameters.name, requestParameters.pbxPlaylist, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptSetsApi - axios parameter creator
 * @export
 */
export const PromptSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action Copy
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetCopyRequestBody} promptSetsPromptSetCopyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy: async (id: number, promptSetsPromptSetCopyRequestBody: PromptSetsPromptSetCopyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('copy', 'id', id)
            // verify required parameter 'promptSetsPromptSetCopyRequestBody' is not null or undefined
            assertParamExists('copy', 'promptSetsPromptSetCopyRequestBody', promptSetsPromptSetCopyRequestBody)
            const localVarPath = `/PromptSets({Id})/Pbx.Copy`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSetsPromptSetCopyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptSet: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePromptSet', 'id', id)
            const localVarPath = `/PromptSets({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetActive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PromptSets/Pbx.GetActive()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from PromptSets by key
         * @param {number} id The unique identifier of PromptSet
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptSet: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPromptSet', 'id', id)
            const localVarPath = `/PromptSets({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from PromptSets
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptSet: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PromptSets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Prompts from PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrompts: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listPrompts', 'id', id)
            const localVarPath = `/PromptSets({Id})/Prompts`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PlayPrompt
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetPlayPromptRequestBody} promptSetsPromptSetPlayPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playPrompt: async (id: number, promptSetsPromptSetPlayPromptRequestBody: PromptSetsPromptSetPlayPromptRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playPrompt', 'id', id)
            // verify required parameter 'promptSetsPromptSetPlayPromptRequestBody' is not null or undefined
            assertParamExists('playPrompt', 'promptSetsPromptSetPlayPromptRequestBody', promptSetsPromptSetPlayPromptRequestBody)
            const localVarPath = `/PromptSets({Id})/Pbx.PlayPrompt`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSetsPromptSetPlayPromptRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RecordPrompt
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetRecordPromptRequestBody} promptSetsPromptSetRecordPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordPrompt: async (id: number, promptSetsPromptSetRecordPromptRequestBody: PromptSetsPromptSetRecordPromptRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recordPrompt', 'id', id)
            // verify required parameter 'promptSetsPromptSetRecordPromptRequestBody' is not null or undefined
            assertParamExists('recordPrompt', 'promptSetsPromptSetRecordPromptRequestBody', promptSetsPromptSetRecordPromptRequestBody)
            const localVarPath = `/PromptSets({Id})/Pbx.RecordPrompt`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSetsPromptSetRecordPromptRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetActive
         * @param {number} id The unique identifier of PromptSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActive: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setActive', 'id', id)
            const localVarPath = `/PromptSets({Id})/Pbx.SetActive`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetAlternatePronunciation
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetSetAlternatePronunciationRequestBody} promptSetsPromptSetSetAlternatePronunciationRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAlternatePronunciation: async (id: number, promptSetsPromptSetSetAlternatePronunciationRequestBody: PromptSetsPromptSetSetAlternatePronunciationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setAlternatePronunciation', 'id', id)
            // verify required parameter 'promptSetsPromptSetSetAlternatePronunciationRequestBody' is not null or undefined
            assertParamExists('setAlternatePronunciation', 'promptSetsPromptSetSetAlternatePronunciationRequestBody', promptSetsPromptSetSetAlternatePronunciationRequestBody)
            const localVarPath = `/PromptSets({Id})/Pbx.SetAlternatePronunciation`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSetsPromptSetSetAlternatePronunciationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {PbxPromptSet} pbxPromptSet New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptSet: async (id: number, pbxPromptSet: PbxPromptSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePromptSet', 'id', id)
            // verify required parameter 'pbxPromptSet' is not null or undefined
            assertParamExists('updatePromptSet', 'pbxPromptSet', pbxPromptSet)
            const localVarPath = `/PromptSets({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxPromptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptSetsApi - functional programming interface
 * @export
 */
export const PromptSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action Copy
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetCopyRequestBody} promptSetsPromptSetCopyRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copy(id: number, promptSetsPromptSetCopyRequestBody: PromptSetsPromptSetCopyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPromptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copy(id, promptSetsPromptSetCopyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.copy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePromptSet(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePromptSet(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.deletePromptSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetActive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.getActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from PromptSets by key
         * @param {number} id The unique identifier of PromptSet
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptSet(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPromptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptSet(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.getPromptSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from PromptSets
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptSet($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPromptSetCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPromptSet($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.listPromptSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Prompts from PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrompts(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPromptCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrompts(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.listPrompts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PlayPrompt
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetPlayPromptRequestBody} promptSetsPromptSetPlayPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playPrompt(id: number, promptSetsPromptSetPlayPromptRequestBody: PromptSetsPromptSetPlayPromptRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playPrompt(id, promptSetsPromptSetPlayPromptRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.playPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RecordPrompt
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetRecordPromptRequestBody} promptSetsPromptSetRecordPromptRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordPrompt(id: number, promptSetsPromptSetRecordPromptRequestBody: PromptSetsPromptSetRecordPromptRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordPrompt(id, promptSetsPromptSetRecordPromptRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.recordPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetActive
         * @param {number} id The unique identifier of PromptSet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setActive(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setActive(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.setActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetAlternatePronunciation
         * @param {number} id The unique identifier of PromptSet
         * @param {PromptSetsPromptSetSetAlternatePronunciationRequestBody} promptSetsPromptSetSetAlternatePronunciationRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAlternatePronunciation(id: number, promptSetsPromptSetSetAlternatePronunciationRequestBody: PromptSetsPromptSetSetAlternatePronunciationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAlternatePronunciation(id, promptSetsPromptSetSetAlternatePronunciationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.setAlternatePronunciation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in PromptSets
         * @param {number} id The unique identifier of PromptSet
         * @param {PbxPromptSet} pbxPromptSet New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromptSet(id: number, pbxPromptSet: PbxPromptSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromptSet(id, pbxPromptSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptSetsApi.updatePromptSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptSetsApi - factory interface
 * @export
 */
export const PromptSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptSetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action Copy
         * @param {PromptSetsApiCopyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copy(requestParameters: PromptSetsApiCopyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPromptSet> {
            return localVarFp.copy(requestParameters.id, requestParameters.promptSetsPromptSetCopyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from PromptSets
         * @param {PromptSetsApiDeletePromptSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptSet(requestParameters: PromptSetsApiDeletePromptSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePromptSet(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetActive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(options?: RawAxiosRequestConfig): AxiosPromise<GetActive200Response> {
            return localVarFp.getActive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from PromptSets by key
         * @param {PromptSetsApiGetPromptSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptSet(requestParameters: PromptSetsApiGetPromptSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPromptSet> {
            return localVarFp.getPromptSet(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from PromptSets
         * @param {PromptSetsApiListPromptSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptSet(requestParameters: PromptSetsApiListPromptSetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPromptSetCollectionResponse> {
            return localVarFp.listPromptSet(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Prompts from PromptSets
         * @param {PromptSetsApiListPromptsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrompts(requestParameters: PromptSetsApiListPromptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPromptCollectionResponse> {
            return localVarFp.listPrompts(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PlayPrompt
         * @param {PromptSetsApiPlayPromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playPrompt(requestParameters: PromptSetsApiPlayPromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.playPrompt(requestParameters.id, requestParameters.promptSetsPromptSetPlayPromptRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RecordPrompt
         * @param {PromptSetsApiRecordPromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordPrompt(requestParameters: PromptSetsApiRecordPromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.recordPrompt(requestParameters.id, requestParameters.promptSetsPromptSetRecordPromptRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetActive
         * @param {PromptSetsApiSetActiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActive(requestParameters: PromptSetsApiSetActiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setActive(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetAlternatePronunciation
         * @param {PromptSetsApiSetAlternatePronunciationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAlternatePronunciation(requestParameters: PromptSetsApiSetAlternatePronunciationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setAlternatePronunciation(requestParameters.id, requestParameters.promptSetsPromptSetSetAlternatePronunciationRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in PromptSets
         * @param {PromptSetsApiUpdatePromptSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptSet(requestParameters: PromptSetsApiUpdatePromptSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePromptSet(requestParameters.id, requestParameters.pbxPromptSet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for copy operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiCopyRequest
 */
export interface PromptSetsApiCopyRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiCopy
     */
    readonly id: number

    /**
     * Action parameters
     * @type {PromptSetsPromptSetCopyRequestBody}
     * @memberof PromptSetsApiCopy
     */
    readonly promptSetsPromptSetCopyRequestBody: PromptSetsPromptSetCopyRequestBody
}

/**
 * Request parameters for deletePromptSet operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiDeletePromptSetRequest
 */
export interface PromptSetsApiDeletePromptSetRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiDeletePromptSet
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof PromptSetsApiDeletePromptSet
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getPromptSet operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiGetPromptSetRequest
 */
export interface PromptSetsApiGetPromptSetRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiGetPromptSet
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PromptSetsApiGetPromptSet
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PromptSetsApiGetPromptSet
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listPromptSet operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiListPromptSetRequest
 */
export interface PromptSetsApiListPromptSetRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PromptSetsApiListPromptSet
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listPrompts operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiListPromptsRequest
 */
export interface PromptSetsApiListPromptsRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiListPrompts
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof PromptSetsApiListPrompts
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for playPrompt operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiPlayPromptRequest
 */
export interface PromptSetsApiPlayPromptRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiPlayPrompt
     */
    readonly id: number

    /**
     * Action parameters
     * @type {PromptSetsPromptSetPlayPromptRequestBody}
     * @memberof PromptSetsApiPlayPrompt
     */
    readonly promptSetsPromptSetPlayPromptRequestBody: PromptSetsPromptSetPlayPromptRequestBody
}

/**
 * Request parameters for recordPrompt operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiRecordPromptRequest
 */
export interface PromptSetsApiRecordPromptRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiRecordPrompt
     */
    readonly id: number

    /**
     * Action parameters
     * @type {PromptSetsPromptSetRecordPromptRequestBody}
     * @memberof PromptSetsApiRecordPrompt
     */
    readonly promptSetsPromptSetRecordPromptRequestBody: PromptSetsPromptSetRecordPromptRequestBody
}

/**
 * Request parameters for setActive operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiSetActiveRequest
 */
export interface PromptSetsApiSetActiveRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiSetActive
     */
    readonly id: number
}

/**
 * Request parameters for setAlternatePronunciation operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiSetAlternatePronunciationRequest
 */
export interface PromptSetsApiSetAlternatePronunciationRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiSetAlternatePronunciation
     */
    readonly id: number

    /**
     * Action parameters
     * @type {PromptSetsPromptSetSetAlternatePronunciationRequestBody}
     * @memberof PromptSetsApiSetAlternatePronunciation
     */
    readonly promptSetsPromptSetSetAlternatePronunciationRequestBody: PromptSetsPromptSetSetAlternatePronunciationRequestBody
}

/**
 * Request parameters for updatePromptSet operation in PromptSetsApi.
 * @export
 * @interface PromptSetsApiUpdatePromptSetRequest
 */
export interface PromptSetsApiUpdatePromptSetRequest {
    /**
     * The unique identifier of PromptSet
     * @type {number}
     * @memberof PromptSetsApiUpdatePromptSet
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxPromptSet}
     * @memberof PromptSetsApiUpdatePromptSet
     */
    readonly pbxPromptSet: PbxPromptSet
}

/**
 * PromptSetsApi - object-oriented interface
 * @export
 * @class PromptSetsApi
 * @extends {BaseAPI}
 */
export class PromptSetsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action Copy
     * @param {PromptSetsApiCopyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public copy(requestParameters: PromptSetsApiCopyRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).copy(requestParameters.id, requestParameters.promptSetsPromptSetCopyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from PromptSets
     * @param {PromptSetsApiDeletePromptSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public deletePromptSet(requestParameters: PromptSetsApiDeletePromptSetRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).deletePromptSet(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetActive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public getActive(options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).getActive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from PromptSets by key
     * @param {PromptSetsApiGetPromptSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public getPromptSet(requestParameters: PromptSetsApiGetPromptSetRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).getPromptSet(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from PromptSets
     * @param {PromptSetsApiListPromptSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public listPromptSet(requestParameters: PromptSetsApiListPromptSetRequest = {}, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).listPromptSet(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Prompts from PromptSets
     * @param {PromptSetsApiListPromptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public listPrompts(requestParameters: PromptSetsApiListPromptsRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).listPrompts(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PlayPrompt
     * @param {PromptSetsApiPlayPromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public playPrompt(requestParameters: PromptSetsApiPlayPromptRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).playPrompt(requestParameters.id, requestParameters.promptSetsPromptSetPlayPromptRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RecordPrompt
     * @param {PromptSetsApiRecordPromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public recordPrompt(requestParameters: PromptSetsApiRecordPromptRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).recordPrompt(requestParameters.id, requestParameters.promptSetsPromptSetRecordPromptRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetActive
     * @param {PromptSetsApiSetActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public setActive(requestParameters: PromptSetsApiSetActiveRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).setActive(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetAlternatePronunciation
     * @param {PromptSetsApiSetAlternatePronunciationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public setAlternatePronunciation(requestParameters: PromptSetsApiSetAlternatePronunciationRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).setAlternatePronunciation(requestParameters.id, requestParameters.promptSetsPromptSetSetAlternatePronunciationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in PromptSets
     * @param {PromptSetsApiUpdatePromptSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptSetsApi
     */
    public updatePromptSet(requestParameters: PromptSetsApiUpdatePromptSetRequest, options?: RawAxiosRequestConfig) {
        return PromptSetsApiFp(this.configuration).updatePromptSet(requestParameters.id, requestParameters.pbxPromptSet, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PurgeSettingsApi - axios parameter creator
 * @export
 */
export const PurgeSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke actionImport PurgeAllLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllLogs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/PurgeAllLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke actionImport PurgeCalls
         * @param {ActionImportPurgeCallsRequestBody} actionImportPurgeCallsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeCalls: async (actionImportPurgeCallsRequestBody: ActionImportPurgeCallsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionImportPurgeCallsRequestBody' is not null or undefined
            assertParamExists('purgeCalls', 'actionImportPurgeCallsRequestBody', actionImportPurgeCallsRequestBody)
            const localVarPath = `/PurgeCalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionImportPurgeCallsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke actionImport PurgeChats
         * @param {ActionImportPurgeChatsRequestBody} actionImportPurgeChatsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeChats: async (actionImportPurgeChatsRequestBody: ActionImportPurgeChatsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionImportPurgeChatsRequestBody' is not null or undefined
            assertParamExists('purgeChats', 'actionImportPurgeChatsRequestBody', actionImportPurgeChatsRequestBody)
            const localVarPath = `/PurgeChats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionImportPurgeChatsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurgeSettingsApi - functional programming interface
 * @export
 */
export const PurgeSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurgeSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke actionImport PurgeAllLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAllLogs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAllLogs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PurgeSettingsApi.purgeAllLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke actionImport PurgeCalls
         * @param {ActionImportPurgeCallsRequestBody} actionImportPurgeCallsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeCalls(actionImportPurgeCallsRequestBody: ActionImportPurgeCallsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeCalls(actionImportPurgeCallsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PurgeSettingsApi.purgeCalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke actionImport PurgeChats
         * @param {ActionImportPurgeChatsRequestBody} actionImportPurgeChatsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeChats(actionImportPurgeChatsRequestBody: ActionImportPurgeChatsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeChats(actionImportPurgeChatsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PurgeSettingsApi.purgeChats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PurgeSettingsApi - factory interface
 * @export
 */
export const PurgeSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurgeSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke actionImport PurgeAllLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAllLogs(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeAllLogs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke actionImport PurgeCalls
         * @param {PurgeSettingsApiPurgeCallsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeCalls(requestParameters: PurgeSettingsApiPurgeCallsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeCalls(requestParameters.actionImportPurgeCallsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke actionImport PurgeChats
         * @param {PurgeSettingsApiPurgeChatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeChats(requestParameters: PurgeSettingsApiPurgeChatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeChats(requestParameters.actionImportPurgeChatsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for purgeCalls operation in PurgeSettingsApi.
 * @export
 * @interface PurgeSettingsApiPurgeCallsRequest
 */
export interface PurgeSettingsApiPurgeCallsRequest {
    /**
     * Action parameters
     * @type {ActionImportPurgeCallsRequestBody}
     * @memberof PurgeSettingsApiPurgeCalls
     */
    readonly actionImportPurgeCallsRequestBody: ActionImportPurgeCallsRequestBody
}

/**
 * Request parameters for purgeChats operation in PurgeSettingsApi.
 * @export
 * @interface PurgeSettingsApiPurgeChatsRequest
 */
export interface PurgeSettingsApiPurgeChatsRequest {
    /**
     * Action parameters
     * @type {ActionImportPurgeChatsRequestBody}
     * @memberof PurgeSettingsApiPurgeChats
     */
    readonly actionImportPurgeChatsRequestBody: ActionImportPurgeChatsRequestBody
}

/**
 * PurgeSettingsApi - object-oriented interface
 * @export
 * @class PurgeSettingsApi
 * @extends {BaseAPI}
 */
export class PurgeSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke actionImport PurgeAllLogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurgeSettingsApi
     */
    public purgeAllLogs(options?: RawAxiosRequestConfig) {
        return PurgeSettingsApiFp(this.configuration).purgeAllLogs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke actionImport PurgeCalls
     * @param {PurgeSettingsApiPurgeCallsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurgeSettingsApi
     */
    public purgeCalls(requestParameters: PurgeSettingsApiPurgeCallsRequest, options?: RawAxiosRequestConfig) {
        return PurgeSettingsApiFp(this.configuration).purgeCalls(requestParameters.actionImportPurgeCallsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke actionImport PurgeChats
     * @param {PurgeSettingsApiPurgeChatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurgeSettingsApi
     */
    public purgeChats(requestParameters: PurgeSettingsApiPurgeChatsRequest, options?: RawAxiosRequestConfig) {
        return PurgeSettingsApiFp(this.configuration).purgeChats(requestParameters.actionImportPurgeChatsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueuesApi - axios parameter creator
 * @export
 */
export const QueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Queues
         * @param {PbxQueue} pbxQueue New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue: async (pbxQueue: PbxQueue, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxQueue' is not null or undefined
            assertParamExists('createQueue', 'pbxQueue', pbxQueue)
            const localVarPath = `/Queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxQueue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Queues
         * @param {number} id The unique identifier of Queue
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQueue', 'id', id)
            const localVarPath = `/Queues({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableQueueNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableQueueNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Queues/Pbx.GetFirstAvailableQueueNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Queues by key
         * @param {number} id The unique identifier of Queue
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getQueue', 'id', id)
            const localVarPath = `/Queues({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getQueueByNumber', 'number', number)
            const localVarPath = `/Queues/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Agents from Queues
         * @param {number} id The unique identifier of Queue
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAgents', 'id', id)
            const localVarPath = `/Queues({Id})/Agents`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Managers from Queues
         * @param {number} id The unique identifier of Queue
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagers: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listManagers', 'id', id)
            const localVarPath = `/Queues({Id})/Managers`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Queues
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueue: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ResetQueueStatistics
         * @param {number} id The unique identifier of Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetQueueStatistics: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetQueueStatistics', 'id', id)
            const localVarPath = `/Queues({Id})/Pbx.ResetQueueStatistics`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Queues
         * @param {number} id The unique identifier of Queue
         * @param {PbxQueue} pbxQueue New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue: async (id: number, pbxQueue: PbxQueue, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateQueue', 'id', id)
            // verify required parameter 'pbxQueue' is not null or undefined
            assertParamExists('updateQueue', 'pbxQueue', pbxQueue)
            const localVarPath = `/Queues({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxQueue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesApi - functional programming interface
 * @export
 */
export const QueuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Queues
         * @param {PbxQueue} pbxQueue New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQueue(pbxQueue: PbxQueue, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQueue(pbxQueue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.createQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Queues
         * @param {number} id The unique identifier of Queue
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQueue(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQueue(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.deleteQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableQueueNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableQueueNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableQueueNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.getFirstAvailableQueueNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Queues by key
         * @param {number} id The unique identifier of Queue
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueue(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueue(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.getQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.getQueueByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Agents from Queues
         * @param {number} id The unique identifier of Queue
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgents(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueueAgentCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgents(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.listAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Managers from Queues
         * @param {number} id The unique identifier of Queue
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManagers(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueueManagerCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManagers(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.listManagers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Queues
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQueue($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxQueueCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQueue($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.listQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ResetQueueStatistics
         * @param {number} id The unique identifier of Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetQueueStatistics(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetQueueStatistics(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.resetQueueStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Queues
         * @param {number} id The unique identifier of Queue
         * @param {PbxQueue} pbxQueue New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQueue(id: number, pbxQueue: PbxQueue, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQueue(id, pbxQueue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueuesApi.updateQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueuesApi - factory interface
 * @export
 */
export const QueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueuesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Queues
         * @param {QueuesApiCreateQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(requestParameters: QueuesApiCreateQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueue> {
            return localVarFp.createQueue(requestParameters.pbxQueue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Queues
         * @param {QueuesApiDeleteQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(requestParameters: QueuesApiDeleteQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQueue(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableQueueNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableQueueNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableQueueNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Queues by key
         * @param {QueuesApiGetQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(requestParameters: QueuesApiGetQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueue> {
            return localVarFp.getQueue(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {QueuesApiGetQueueByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueByNumber(requestParameters: QueuesApiGetQueueByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueue> {
            return localVarFp.getQueueByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Agents from Queues
         * @param {QueuesApiListAgentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(requestParameters: QueuesApiListAgentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueueAgentCollectionResponse> {
            return localVarFp.listAgents(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Managers from Queues
         * @param {QueuesApiListManagersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagers(requestParameters: QueuesApiListManagersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueueManagerCollectionResponse> {
            return localVarFp.listManagers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Queues
         * @param {QueuesApiListQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueue(requestParameters: QueuesApiListQueueRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxQueueCollectionResponse> {
            return localVarFp.listQueue(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ResetQueueStatistics
         * @param {QueuesApiResetQueueStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetQueueStatistics(requestParameters: QueuesApiResetQueueStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetQueueStatistics(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Queues
         * @param {QueuesApiUpdateQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(requestParameters: QueuesApiUpdateQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateQueue(requestParameters.id, requestParameters.pbxQueue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createQueue operation in QueuesApi.
 * @export
 * @interface QueuesApiCreateQueueRequest
 */
export interface QueuesApiCreateQueueRequest {
    /**
     * New entity
     * @type {PbxQueue}
     * @memberof QueuesApiCreateQueue
     */
    readonly pbxQueue: PbxQueue
}

/**
 * Request parameters for deleteQueue operation in QueuesApi.
 * @export
 * @interface QueuesApiDeleteQueueRequest
 */
export interface QueuesApiDeleteQueueRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiDeleteQueue
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof QueuesApiDeleteQueue
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getQueue operation in QueuesApi.
 * @export
 * @interface QueuesApiGetQueueRequest
 */
export interface QueuesApiGetQueueRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiGetQueue
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof QueuesApiGetQueue
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof QueuesApiGetQueue
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueByNumber operation in QueuesApi.
 * @export
 * @interface QueuesApiGetQueueByNumberRequest
 */
export interface QueuesApiGetQueueByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof QueuesApiGetQueueByNumber
     */
    readonly number: string
}

/**
 * Request parameters for listAgents operation in QueuesApi.
 * @export
 * @interface QueuesApiListAgentsRequest
 */
export interface QueuesApiListAgentsRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiListAgents
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof QueuesApiListAgents
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof QueuesApiListAgents
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof QueuesApiListAgents
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof QueuesApiListAgents
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof QueuesApiListAgents
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof QueuesApiListAgents
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof QueuesApiListAgents
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof QueuesApiListAgents
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listManagers operation in QueuesApi.
 * @export
 * @interface QueuesApiListManagersRequest
 */
export interface QueuesApiListManagersRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiListManagers
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof QueuesApiListManagers
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof QueuesApiListManagers
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof QueuesApiListManagers
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof QueuesApiListManagers
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof QueuesApiListManagers
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof QueuesApiListManagers
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof QueuesApiListManagers
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof QueuesApiListManagers
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listQueue operation in QueuesApi.
 * @export
 * @interface QueuesApiListQueueRequest
 */
export interface QueuesApiListQueueRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof QueuesApiListQueue
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof QueuesApiListQueue
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof QueuesApiListQueue
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof QueuesApiListQueue
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof QueuesApiListQueue
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof QueuesApiListQueue
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof QueuesApiListQueue
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof QueuesApiListQueue
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for resetQueueStatistics operation in QueuesApi.
 * @export
 * @interface QueuesApiResetQueueStatisticsRequest
 */
export interface QueuesApiResetQueueStatisticsRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiResetQueueStatistics
     */
    readonly id: number
}

/**
 * Request parameters for updateQueue operation in QueuesApi.
 * @export
 * @interface QueuesApiUpdateQueueRequest
 */
export interface QueuesApiUpdateQueueRequest {
    /**
     * The unique identifier of Queue
     * @type {number}
     * @memberof QueuesApiUpdateQueue
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxQueue}
     * @memberof QueuesApiUpdateQueue
     */
    readonly pbxQueue: PbxQueue
}

/**
 * QueuesApi - object-oriented interface
 * @export
 * @class QueuesApi
 * @extends {BaseAPI}
 */
export class QueuesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Queues
     * @param {QueuesApiCreateQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public createQueue(requestParameters: QueuesApiCreateQueueRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).createQueue(requestParameters.pbxQueue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Queues
     * @param {QueuesApiDeleteQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public deleteQueue(requestParameters: QueuesApiDeleteQueueRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).deleteQueue(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableQueueNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public getFirstAvailableQueueNumber(options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).getFirstAvailableQueueNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Queues by key
     * @param {QueuesApiGetQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public getQueue(requestParameters: QueuesApiGetQueueRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).getQueue(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {QueuesApiGetQueueByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public getQueueByNumber(requestParameters: QueuesApiGetQueueByNumberRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).getQueueByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Agents from Queues
     * @param {QueuesApiListAgentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public listAgents(requestParameters: QueuesApiListAgentsRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).listAgents(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Managers from Queues
     * @param {QueuesApiListManagersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public listManagers(requestParameters: QueuesApiListManagersRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).listManagers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Queues
     * @param {QueuesApiListQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public listQueue(requestParameters: QueuesApiListQueueRequest = {}, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).listQueue(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ResetQueueStatistics
     * @param {QueuesApiResetQueueStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public resetQueueStatistics(requestParameters: QueuesApiResetQueueStatisticsRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).resetQueueStatistics(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Queues
     * @param {QueuesApiUpdateQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesApi
     */
    public updateQueue(requestParameters: QueuesApiUpdateQueueRequest, options?: RawAxiosRequestConfig) {
        return QueuesApiFp(this.configuration).updateQueue(requestParameters.id, requestParameters.pbxQueue, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReceptionistsApi - axios parameter creator
 * @export
 */
export const ReceptionistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Receptionists
         * @param {PbxReceptionist} pbxReceptionist New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceptionist: async (pbxReceptionist: PbxReceptionist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxReceptionist' is not null or undefined
            assertParamExists('createReceptionist', 'pbxReceptionist', pbxReceptionist)
            const localVarPath = `/Receptionists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxReceptionist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceptionist: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReceptionist', 'id', id)
            const localVarPath = `/Receptionists({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableReceptionistNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableReceptionistNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Receptionists/Pbx.GetFirstAvailableReceptionistNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Receptionists by key
         * @param {number} id The unique identifier of Receptionist
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceptionist: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getReceptionist', 'id', id)
            const localVarPath = `/Receptionists({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceptionistByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getReceptionistByNumber', 'number', number)
            const localVarPath = `/Receptionists/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Forwards from Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForwards: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listForwards', 'id', id)
            const localVarPath = `/Receptionists({Id})/Forwards`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Receptionists
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceptionist: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Receptionists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {PbxReceptionist} pbxReceptionist New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceptionist: async (id: number, pbxReceptionist: PbxReceptionist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateReceptionist', 'id', id)
            // verify required parameter 'pbxReceptionist' is not null or undefined
            assertParamExists('updateReceptionist', 'pbxReceptionist', pbxReceptionist)
            const localVarPath = `/Receptionists({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxReceptionist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceptionistsApi - functional programming interface
 * @export
 */
export const ReceptionistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceptionistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Receptionists
         * @param {PbxReceptionist} pbxReceptionist New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReceptionist(pbxReceptionist: PbxReceptionist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReceptionist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReceptionist(pbxReceptionist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.createReceptionist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReceptionist(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReceptionist(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.deleteReceptionist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableReceptionistNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableReceptionistNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableReceptionistNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.getFirstAvailableReceptionistNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Receptionists by key
         * @param {number} id The unique identifier of Receptionist
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceptionist(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReceptionist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceptionist(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.getReceptionist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceptionistByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReceptionist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceptionistByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.getReceptionistByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Forwards from Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForwards(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReceptionistForwardCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForwards(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.listForwards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Receptionists
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceptionist($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReceptionistCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceptionist($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.listReceptionist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Receptionists
         * @param {number} id The unique identifier of Receptionist
         * @param {PbxReceptionist} pbxReceptionist New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReceptionist(id: number, pbxReceptionist: PbxReceptionist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReceptionist(id, pbxReceptionist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReceptionistsApi.updateReceptionist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReceptionistsApi - factory interface
 * @export
 */
export const ReceptionistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceptionistsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Receptionists
         * @param {ReceptionistsApiCreateReceptionistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceptionist(requestParameters: ReceptionistsApiCreateReceptionistRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxReceptionist> {
            return localVarFp.createReceptionist(requestParameters.pbxReceptionist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Receptionists
         * @param {ReceptionistsApiDeleteReceptionistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceptionist(requestParameters: ReceptionistsApiDeleteReceptionistRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReceptionist(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableReceptionistNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableReceptionistNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableReceptionistNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Receptionists by key
         * @param {ReceptionistsApiGetReceptionistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceptionist(requestParameters: ReceptionistsApiGetReceptionistRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxReceptionist> {
            return localVarFp.getReceptionist(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {ReceptionistsApiGetReceptionistByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceptionistByNumber(requestParameters: ReceptionistsApiGetReceptionistByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxReceptionist> {
            return localVarFp.getReceptionistByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Forwards from Receptionists
         * @param {ReceptionistsApiListForwardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForwards(requestParameters: ReceptionistsApiListForwardsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxReceptionistForwardCollectionResponse> {
            return localVarFp.listForwards(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Receptionists
         * @param {ReceptionistsApiListReceptionistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceptionist(requestParameters: ReceptionistsApiListReceptionistRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxReceptionistCollectionResponse> {
            return localVarFp.listReceptionist(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Receptionists
         * @param {ReceptionistsApiUpdateReceptionistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceptionist(requestParameters: ReceptionistsApiUpdateReceptionistRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateReceptionist(requestParameters.id, requestParameters.pbxReceptionist, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReceptionist operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiCreateReceptionistRequest
 */
export interface ReceptionistsApiCreateReceptionistRequest {
    /**
     * New entity
     * @type {PbxReceptionist}
     * @memberof ReceptionistsApiCreateReceptionist
     */
    readonly pbxReceptionist: PbxReceptionist
}

/**
 * Request parameters for deleteReceptionist operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiDeleteReceptionistRequest
 */
export interface ReceptionistsApiDeleteReceptionistRequest {
    /**
     * The unique identifier of Receptionist
     * @type {number}
     * @memberof ReceptionistsApiDeleteReceptionist
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ReceptionistsApiDeleteReceptionist
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getReceptionist operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiGetReceptionistRequest
 */
export interface ReceptionistsApiGetReceptionistRequest {
    /**
     * The unique identifier of Receptionist
     * @type {number}
     * @memberof ReceptionistsApiGetReceptionist
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReceptionistsApiGetReceptionist
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReceptionistsApiGetReceptionist
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getReceptionistByNumber operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiGetReceptionistByNumberRequest
 */
export interface ReceptionistsApiGetReceptionistByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof ReceptionistsApiGetReceptionistByNumber
     */
    readonly number: string
}

/**
 * Request parameters for listForwards operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiListForwardsRequest
 */
export interface ReceptionistsApiListForwardsRequest {
    /**
     * The unique identifier of Receptionist
     * @type {number}
     * @memberof ReceptionistsApiListForwards
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReceptionistsApiListForwards
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listReceptionist operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiListReceptionistRequest
 */
export interface ReceptionistsApiListReceptionistRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReceptionistsApiListReceptionist
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateReceptionist operation in ReceptionistsApi.
 * @export
 * @interface ReceptionistsApiUpdateReceptionistRequest
 */
export interface ReceptionistsApiUpdateReceptionistRequest {
    /**
     * The unique identifier of Receptionist
     * @type {number}
     * @memberof ReceptionistsApiUpdateReceptionist
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxReceptionist}
     * @memberof ReceptionistsApiUpdateReceptionist
     */
    readonly pbxReceptionist: PbxReceptionist
}

/**
 * ReceptionistsApi - object-oriented interface
 * @export
 * @class ReceptionistsApi
 * @extends {BaseAPI}
 */
export class ReceptionistsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Receptionists
     * @param {ReceptionistsApiCreateReceptionistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public createReceptionist(requestParameters: ReceptionistsApiCreateReceptionistRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).createReceptionist(requestParameters.pbxReceptionist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Receptionists
     * @param {ReceptionistsApiDeleteReceptionistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public deleteReceptionist(requestParameters: ReceptionistsApiDeleteReceptionistRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).deleteReceptionist(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableReceptionistNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public getFirstAvailableReceptionistNumber(options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).getFirstAvailableReceptionistNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Receptionists by key
     * @param {ReceptionistsApiGetReceptionistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public getReceptionist(requestParameters: ReceptionistsApiGetReceptionistRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).getReceptionist(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {ReceptionistsApiGetReceptionistByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public getReceptionistByNumber(requestParameters: ReceptionistsApiGetReceptionistByNumberRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).getReceptionistByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Forwards from Receptionists
     * @param {ReceptionistsApiListForwardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public listForwards(requestParameters: ReceptionistsApiListForwardsRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).listForwards(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Receptionists
     * @param {ReceptionistsApiListReceptionistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public listReceptionist(requestParameters: ReceptionistsApiListReceptionistRequest = {}, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).listReceptionist(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Receptionists
     * @param {ReceptionistsApiUpdateReceptionistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionistsApi
     */
    public updateReceptionist(requestParameters: ReceptionistsApiUpdateReceptionistRequest, options?: RawAxiosRequestConfig) {
        return ReceptionistsApiFp(this.configuration).updateReceptionist(requestParameters.id, requestParameters.pbxReceptionist, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecordingsApi - axios parameter creator
 * @export
 */
export const RecordingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Recordings/Pbx.Archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsArchive
         * @param {RecordingsBulkRecordingsArchiveRequestBody} recordingsBulkRecordingsArchiveRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRecordingsArchive: async (recordingsBulkRecordingsArchiveRequestBody: RecordingsBulkRecordingsArchiveRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingsBulkRecordingsArchiveRequestBody' is not null or undefined
            assertParamExists('bulkRecordingsArchive', 'recordingsBulkRecordingsArchiveRequestBody', recordingsBulkRecordingsArchiveRequestBody)
            const localVarPath = `/Recordings/Pbx.BulkRecordingsArchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingsBulkRecordingsArchiveRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsDelete
         * @param {RecordingsBulkRecordingsDeleteRequestBody} recordingsBulkRecordingsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRecordingsDelete: async (recordingsBulkRecordingsDeleteRequestBody: RecordingsBulkRecordingsDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingsBulkRecordingsDeleteRequestBody' is not null or undefined
            assertParamExists('bulkRecordingsDelete', 'recordingsBulkRecordingsDeleteRequestBody', recordingsBulkRecordingsDeleteRequestBody)
            const localVarPath = `/Recordings/Pbx.BulkRecordingsDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingsBulkRecordingsDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function DownloadRecording
         * @param {number} recId Usage: recId&#x3D;{recId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRecording: async (recId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recId' is not null or undefined
            assertParamExists('downloadRecording', 'recId', recId)
            const localVarPath = `/Recordings/Pbx.DownloadRecording(recId={recId})`
                .replace(`{${"recId"}}`, encodeURIComponent(String(recId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRecordingRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRepositorySettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Recordings/Pbx.GetRecordingRepositorySettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Recordings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecording: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PurgeArchive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeArchive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Recordings/Pbx.PurgeArchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PurgeLocal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeLocal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Recordings/Pbx.PurgeLocal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetRecordingRepositorySettings
         * @param {RecordingsSetRecordingRepositorySettingsRequestBody} recordingsSetRecordingRepositorySettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecordingRepositorySettings: async (recordingsSetRecordingRepositorySettingsRequestBody: RecordingsSetRecordingRepositorySettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingsSetRecordingRepositorySettingsRequestBody' is not null or undefined
            assertParamExists('setRecordingRepositorySettings', 'recordingsSetRecordingRepositorySettingsRequestBody', recordingsSetRecordingRepositorySettingsRequestBody)
            const localVarPath = `/Recordings/Pbx.SetRecordingRepositorySettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingsSetRecordingRepositorySettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordingsApi - functional programming interface
 * @export
 */
export const RecordingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.archive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsArchive
         * @param {RecordingsBulkRecordingsArchiveRequestBody} recordingsBulkRecordingsArchiveRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRecordingsArchive(recordingsBulkRecordingsArchiveRequestBody: RecordingsBulkRecordingsArchiveRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkRecordingsArchive(recordingsBulkRecordingsArchiveRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.bulkRecordingsArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsDelete
         * @param {RecordingsBulkRecordingsDeleteRequestBody} recordingsBulkRecordingsDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRecordingsDelete(recordingsBulkRecordingsDeleteRequestBody: RecordingsBulkRecordingsDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkRecordingsDelete(recordingsBulkRecordingsDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.bulkRecordingsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function DownloadRecording
         * @param {number} recId Usage: recId&#x3D;{recId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRecording(recId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRecording(recId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.downloadRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRecordingRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingRepositorySettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRecordingRepositorySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingRepositorySettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.getRecordingRepositorySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Recordings
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecording($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRecordingCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecording($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.listRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PurgeArchive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeArchive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeArchive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.purgeArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PurgeLocal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeLocal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeLocal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.purgeLocal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetRecordingRepositorySettings
         * @param {RecordingsSetRecordingRepositorySettingsRequestBody} recordingsSetRecordingRepositorySettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRecordingRepositorySettings(recordingsSetRecordingRepositorySettingsRequestBody: RecordingsSetRecordingRepositorySettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRecordingRepositorySettings(recordingsSetRecordingRepositorySettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingsApi.setRecordingRepositorySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordingsApi - factory interface
 * @export
 */
export const RecordingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action Archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsArchive
         * @param {RecordingsApiBulkRecordingsArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRecordingsArchive(requestParameters: RecordingsApiBulkRecordingsArchiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkRecordingsArchive(requestParameters.recordingsBulkRecordingsArchiveRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action BulkRecordingsDelete
         * @param {RecordingsApiBulkRecordingsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRecordingsDelete(requestParameters: RecordingsApiBulkRecordingsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkRecordingsDelete(requestParameters.recordingsBulkRecordingsDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function DownloadRecording
         * @param {RecordingsApiDownloadRecordingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRecording(requestParameters: RecordingsApiDownloadRecordingRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.downloadRecording(requestParameters.recId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRecordingRepositorySettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRepositorySettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxRecordingRepositorySettings> {
            return localVarFp.getRecordingRepositorySettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Recordings
         * @param {RecordingsApiListRecordingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecording(requestParameters: RecordingsApiListRecordingRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRecordingCollectionResponse> {
            return localVarFp.listRecording(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PurgeArchive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeArchive(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeArchive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PurgeLocal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeLocal(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purgeLocal(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetRecordingRepositorySettings
         * @param {RecordingsApiSetRecordingRepositorySettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRecordingRepositorySettings(requestParameters: RecordingsApiSetRecordingRepositorySettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setRecordingRepositorySettings(requestParameters.recordingsSetRecordingRepositorySettingsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkRecordingsArchive operation in RecordingsApi.
 * @export
 * @interface RecordingsApiBulkRecordingsArchiveRequest
 */
export interface RecordingsApiBulkRecordingsArchiveRequest {
    /**
     * Action parameters
     * @type {RecordingsBulkRecordingsArchiveRequestBody}
     * @memberof RecordingsApiBulkRecordingsArchive
     */
    readonly recordingsBulkRecordingsArchiveRequestBody: RecordingsBulkRecordingsArchiveRequestBody
}

/**
 * Request parameters for bulkRecordingsDelete operation in RecordingsApi.
 * @export
 * @interface RecordingsApiBulkRecordingsDeleteRequest
 */
export interface RecordingsApiBulkRecordingsDeleteRequest {
    /**
     * Action parameters
     * @type {RecordingsBulkRecordingsDeleteRequestBody}
     * @memberof RecordingsApiBulkRecordingsDelete
     */
    readonly recordingsBulkRecordingsDeleteRequestBody: RecordingsBulkRecordingsDeleteRequestBody
}

/**
 * Request parameters for downloadRecording operation in RecordingsApi.
 * @export
 * @interface RecordingsApiDownloadRecordingRequest
 */
export interface RecordingsApiDownloadRecordingRequest {
    /**
     * Usage: recId&#x3D;{recId}
     * @type {number}
     * @memberof RecordingsApiDownloadRecording
     */
    readonly recId: number
}

/**
 * Request parameters for listRecording operation in RecordingsApi.
 * @export
 * @interface RecordingsApiListRecordingRequest
 */
export interface RecordingsApiListRecordingRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof RecordingsApiListRecording
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof RecordingsApiListRecording
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof RecordingsApiListRecording
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof RecordingsApiListRecording
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof RecordingsApiListRecording
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof RecordingsApiListRecording
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof RecordingsApiListRecording
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof RecordingsApiListRecording
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for setRecordingRepositorySettings operation in RecordingsApi.
 * @export
 * @interface RecordingsApiSetRecordingRepositorySettingsRequest
 */
export interface RecordingsApiSetRecordingRepositorySettingsRequest {
    /**
     * Action parameters
     * @type {RecordingsSetRecordingRepositorySettingsRequestBody}
     * @memberof RecordingsApiSetRecordingRepositorySettings
     */
    readonly recordingsSetRecordingRepositorySettingsRequestBody: RecordingsSetRecordingRepositorySettingsRequestBody
}

/**
 * RecordingsApi - object-oriented interface
 * @export
 * @class RecordingsApi
 * @extends {BaseAPI}
 */
export class RecordingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action Archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public archive(options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).archive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action BulkRecordingsArchive
     * @param {RecordingsApiBulkRecordingsArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public bulkRecordingsArchive(requestParameters: RecordingsApiBulkRecordingsArchiveRequest, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).bulkRecordingsArchive(requestParameters.recordingsBulkRecordingsArchiveRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action BulkRecordingsDelete
     * @param {RecordingsApiBulkRecordingsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public bulkRecordingsDelete(requestParameters: RecordingsApiBulkRecordingsDeleteRequest, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).bulkRecordingsDelete(requestParameters.recordingsBulkRecordingsDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function DownloadRecording
     * @param {RecordingsApiDownloadRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public downloadRecording(requestParameters: RecordingsApiDownloadRecordingRequest, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).downloadRecording(requestParameters.recId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRecordingRepositorySettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public getRecordingRepositorySettings(options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).getRecordingRepositorySettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Recordings
     * @param {RecordingsApiListRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public listRecording(requestParameters: RecordingsApiListRecordingRequest = {}, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).listRecording(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PurgeArchive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public purgeArchive(options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).purgeArchive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PurgeLocal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public purgeLocal(options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).purgeLocal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetRecordingRepositorySettings
     * @param {RecordingsApiSetRecordingRepositorySettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingsApi
     */
    public setRecordingRepositorySettings(requestParameters: RecordingsApiSetRecordingRepositorySettingsRequest, options?: RawAxiosRequestConfig) {
        return RecordingsApiFp(this.configuration).setRecordingRepositorySettings(requestParameters.recordingsSetRecordingRepositorySettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemoteArchivingSettingsApi - axios parameter creator
 * @export
 */
export const RemoteArchivingSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action ArchiveChats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RemoteArchivingSettings/Pbx.ArchiveChats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ArchiveFaxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveFaxes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RemoteArchivingSettings/Pbx.ArchiveFaxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ArchiveRecordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRecordings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RemoteArchivingSettings/Pbx.ArchiveRecordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ArchiveVoicemail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveVoicemail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RemoteArchivingSettings/Pbx.ArchiveVoicemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get RemoteArchivingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteArchivingSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RemoteArchivingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update RemoteArchivingSettings
         * @param {PbxRemoteArchivingSettings} pbxRemoteArchivingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteArchivingSettings: async (pbxRemoteArchivingSettings: PbxRemoteArchivingSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxRemoteArchivingSettings' is not null or undefined
            assertParamExists('updateRemoteArchivingSettings', 'pbxRemoteArchivingSettings', pbxRemoteArchivingSettings)
            const localVarPath = `/RemoteArchivingSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxRemoteArchivingSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteArchivingSettingsApi - functional programming interface
 * @export
 */
export const RemoteArchivingSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteArchivingSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action ArchiveChats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveChats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveChats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.archiveChats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ArchiveFaxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveFaxes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveFaxes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.archiveFaxes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ArchiveRecordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveRecordings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveRecordings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.archiveRecordings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ArchiveVoicemail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveVoicemail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveVoicemail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.archiveVoicemail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get RemoteArchivingSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteArchivingSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRemoteArchivingSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemoteArchivingSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.getRemoteArchivingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update RemoteArchivingSettings
         * @param {PbxRemoteArchivingSettings} pbxRemoteArchivingSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRemoteArchivingSettings(pbxRemoteArchivingSettings: PbxRemoteArchivingSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRemoteArchivingSettings(pbxRemoteArchivingSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteArchivingSettingsApi.updateRemoteArchivingSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RemoteArchivingSettingsApi - factory interface
 * @export
 */
export const RemoteArchivingSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteArchivingSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action ArchiveChats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChats(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveChats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ArchiveFaxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveFaxes(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveFaxes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ArchiveRecordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRecordings(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveRecordings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ArchiveVoicemail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveVoicemail(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveVoicemail(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get RemoteArchivingSettings
         * @param {RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteArchivingSettings(requestParameters: RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRemoteArchivingSettings> {
            return localVarFp.getRemoteArchivingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update RemoteArchivingSettings
         * @param {RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteArchivingSettings(requestParameters: RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRemoteArchivingSettings(requestParameters.pbxRemoteArchivingSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRemoteArchivingSettings operation in RemoteArchivingSettingsApi.
 * @export
 * @interface RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest
 */
export interface RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof RemoteArchivingSettingsApiGetRemoteArchivingSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof RemoteArchivingSettingsApiGetRemoteArchivingSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateRemoteArchivingSettings operation in RemoteArchivingSettingsApi.
 * @export
 * @interface RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest
 */
export interface RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest {
    /**
     * New property values
     * @type {PbxRemoteArchivingSettings}
     * @memberof RemoteArchivingSettingsApiUpdateRemoteArchivingSettings
     */
    readonly pbxRemoteArchivingSettings: PbxRemoteArchivingSettings
}

/**
 * RemoteArchivingSettingsApi - object-oriented interface
 * @export
 * @class RemoteArchivingSettingsApi
 * @extends {BaseAPI}
 */
export class RemoteArchivingSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action ArchiveChats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public archiveChats(options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).archiveChats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ArchiveFaxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public archiveFaxes(options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).archiveFaxes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ArchiveRecordings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public archiveRecordings(options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).archiveRecordings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ArchiveVoicemail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public archiveVoicemail(options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).archiveVoicemail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get RemoteArchivingSettings
     * @param {RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public getRemoteArchivingSettings(requestParameters: RemoteArchivingSettingsApiGetRemoteArchivingSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).getRemoteArchivingSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update RemoteArchivingSettings
     * @param {RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteArchivingSettingsApi
     */
    public updateRemoteArchivingSettings(requestParameters: RemoteArchivingSettingsApiUpdateRemoteArchivingSettingsRequest, options?: RawAxiosRequestConfig) {
        return RemoteArchivingSettingsApiFp(this.configuration).updateRemoteArchivingSettings(requestParameters.pbxRemoteArchivingSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAbandonedChatsStatisticsApi - axios parameter creator
 * @export
 */
export const ReportAbandonedChatsStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedChatsStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAbandonedChatsStatistics: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadAbandonedChatsStatistics', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadAbandonedChatsStatistics', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadAbandonedChatsStatistics', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('downloadAbandonedChatsStatistics', 'participantType', participantType)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadAbandonedChatsStatistics', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportAbandonedChatsStatistics/Pbx.DownloadAbandonedChatsStatistics(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType},clientTimeZone={clientTimeZone})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAbandonedChatsStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbandonedChatsStatisticsData: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getAbandonedChatsStatisticsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getAbandonedChatsStatisticsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getAbandonedChatsStatisticsData', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('getAbandonedChatsStatisticsData', 'participantType', participantType)
            const localVarPath = `/ReportAbandonedChatsStatistics/Pbx.GetAbandonedChatsStatisticsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAbandonedChatsStatisticsApi - functional programming interface
 * @export
 */
export const ReportAbandonedChatsStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAbandonedChatsStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedChatsStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAbandonedChatsStatistics(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAbandonedChatsStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAbandonedChatsStatistics(queueDnStr, startDt, endDt, participantType, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAbandonedChatsStatisticsApi.downloadAbandonedChatsStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAbandonedChatsStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbandonedChatsStatisticsData(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAbandonedChatsStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbandonedChatsStatisticsData(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAbandonedChatsStatisticsApi.getAbandonedChatsStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAbandonedChatsStatisticsApi - factory interface
 * @export
 */
export const ReportAbandonedChatsStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAbandonedChatsStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedChatsStatistics
         * @param {ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAbandonedChatsStatistics(requestParameters: ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAbandonedChatsStatistics> {
            return localVarFp.downloadAbandonedChatsStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAbandonedChatsStatisticsData
         * @param {ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbandonedChatsStatisticsData(requestParameters: ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAbandonedChatsStatistics> {
            return localVarFp.getAbandonedChatsStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAbandonedChatsStatistics operation in ReportAbandonedChatsStatisticsApi.
 * @export
 * @interface ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest
 */
export interface ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly participantType: number

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAbandonedChatsStatisticsData operation in ReportAbandonedChatsStatisticsApi.
 * @export
 * @interface ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest
 */
export interface ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAbandonedChatsStatisticsApi - object-oriented interface
 * @export
 * @class ReportAbandonedChatsStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportAbandonedChatsStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAbandonedChatsStatistics
     * @param {ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAbandonedChatsStatisticsApi
     */
    public downloadAbandonedChatsStatistics(requestParameters: ReportAbandonedChatsStatisticsApiDownloadAbandonedChatsStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportAbandonedChatsStatisticsApiFp(this.configuration).downloadAbandonedChatsStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAbandonedChatsStatisticsData
     * @param {ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAbandonedChatsStatisticsApi
     */
    public getAbandonedChatsStatisticsData(requestParameters: ReportAbandonedChatsStatisticsApiGetAbandonedChatsStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportAbandonedChatsStatisticsApiFp(this.configuration).getAbandonedChatsStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAbandonedQueueCallsApi - axios parameter creator
 * @export
 */
export const ReportAbandonedQueueCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedQueueCalls
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAbandonedQueueCalls: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadAbandonedQueueCalls', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadAbandonedQueueCalls', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('downloadAbandonedQueueCalls', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadAbandonedQueueCalls', 'waitInterval', waitInterval)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadAbandonedQueueCalls', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportAbandonedQueueCalls/Pbx.DownloadAbandonedQueueCalls(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval},clientTimeZone={clientTimeZone})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAbandonedQueueCallsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbandonedQueueCallsData: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getAbandonedQueueCallsData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getAbandonedQueueCallsData', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('getAbandonedQueueCallsData', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getAbandonedQueueCallsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportAbandonedQueueCalls/Pbx.GetAbandonedQueueCallsData(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAbandonedQueueCallsApi - functional programming interface
 * @export
 */
export const ReportAbandonedQueueCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAbandonedQueueCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedQueueCalls
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAbandonedQueueCalls(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAbandonedQueueCalls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAbandonedQueueCalls(periodFrom, periodTo, queueDns, waitInterval, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAbandonedQueueCallsApi.downloadAbandonedQueueCalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAbandonedQueueCallsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbandonedQueueCallsData(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAbandonedQueueCalls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbandonedQueueCallsData(periodFrom, periodTo, queueDns, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAbandonedQueueCallsApi.getAbandonedQueueCallsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAbandonedQueueCallsApi - factory interface
 * @export
 */
export const ReportAbandonedQueueCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAbandonedQueueCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAbandonedQueueCalls
         * @param {ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAbandonedQueueCalls(requestParameters: ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAbandonedQueueCalls> {
            return localVarFp.downloadAbandonedQueueCalls(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAbandonedQueueCallsData
         * @param {ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbandonedQueueCallsData(requestParameters: ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAbandonedQueueCalls> {
            return localVarFp.getAbandonedQueueCallsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAbandonedQueueCalls operation in ReportAbandonedQueueCallsApi.
 * @export
 * @interface ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest
 */
export interface ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly waitInterval: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiDownloadAbandonedQueueCalls
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAbandonedQueueCallsData operation in ReportAbandonedQueueCallsApi.
 * @export
 * @interface ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest
 */
export interface ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAbandonedQueueCallsApiGetAbandonedQueueCallsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAbandonedQueueCallsApi - object-oriented interface
 * @export
 * @class ReportAbandonedQueueCallsApi
 * @extends {BaseAPI}
 */
export class ReportAbandonedQueueCallsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAbandonedQueueCalls
     * @param {ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAbandonedQueueCallsApi
     */
    public downloadAbandonedQueueCalls(requestParameters: ReportAbandonedQueueCallsApiDownloadAbandonedQueueCallsRequest, options?: RawAxiosRequestConfig) {
        return ReportAbandonedQueueCallsApiFp(this.configuration).downloadAbandonedQueueCalls(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAbandonedQueueCallsData
     * @param {ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAbandonedQueueCallsApi
     */
    public getAbandonedQueueCallsData(requestParameters: ReportAbandonedQueueCallsApiGetAbandonedQueueCallsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportAbandonedQueueCallsApiFp(this.configuration).getAbandonedQueueCallsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAgentLoginHistoryApi - axios parameter creator
 * @export
 */
export const ReportAgentLoginHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentLoginHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} agentDnStr Usage: agentDnStr&#x3D;{agentDnStr}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAgentLoginHistory: async (clientTimeZone: string | null, startDt: string, endDt: string, queueDnStr: string | null, agentDnStr: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadAgentLoginHistory', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadAgentLoginHistory', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadAgentLoginHistory', 'endDt', endDt)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadAgentLoginHistory', 'queueDnStr', queueDnStr)
            // verify required parameter 'agentDnStr' is not null or undefined
            assertParamExists('downloadAgentLoginHistory', 'agentDnStr', agentDnStr)
            const localVarPath = `/ReportAgentLoginHistory/Pbx.DownloadAgentLoginHistory(clientTimeZone={clientTimeZone},startDt={startDt},endDt={endDt},queueDnStr={queueDnStr},agentDnStr={agentDnStr})`
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"agentDnStr"}}`, encodeURIComponent(String(agentDnStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAgentLoginHistoryData
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} agentDnStr Usage: agentDnStr&#x3D;{agentDnStr}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentLoginHistoryData: async (clientTimeZone: string | null, startDt: string, endDt: string, queueDnStr: string | null, agentDnStr: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('getAgentLoginHistoryData', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getAgentLoginHistoryData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getAgentLoginHistoryData', 'endDt', endDt)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getAgentLoginHistoryData', 'queueDnStr', queueDnStr)
            // verify required parameter 'agentDnStr' is not null or undefined
            assertParamExists('getAgentLoginHistoryData', 'agentDnStr', agentDnStr)
            const localVarPath = `/ReportAgentLoginHistory/Pbx.GetAgentLoginHistoryData(clientTimeZone={clientTimeZone},startDt={startDt},endDt={endDt},queueDnStr={queueDnStr},agentDnStr={agentDnStr})`
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"agentDnStr"}}`, encodeURIComponent(String(agentDnStr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAgentLoginHistoryApi - functional programming interface
 * @export
 */
export const ReportAgentLoginHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAgentLoginHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentLoginHistory
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} agentDnStr Usage: agentDnStr&#x3D;{agentDnStr}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAgentLoginHistory(clientTimeZone: string | null, startDt: string, endDt: string, queueDnStr: string | null, agentDnStr: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAgentLoginHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAgentLoginHistory(clientTimeZone, startDt, endDt, queueDnStr, agentDnStr, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAgentLoginHistoryApi.downloadAgentLoginHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAgentLoginHistoryData
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} agentDnStr Usage: agentDnStr&#x3D;{agentDnStr}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentLoginHistoryData(clientTimeZone: string | null, startDt: string, endDt: string, queueDnStr: string | null, agentDnStr: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAgentLoginHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentLoginHistoryData(clientTimeZone, startDt, endDt, queueDnStr, agentDnStr, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAgentLoginHistoryApi.getAgentLoginHistoryData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAgentLoginHistoryApi - factory interface
 * @export
 */
export const ReportAgentLoginHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAgentLoginHistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentLoginHistory
         * @param {ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAgentLoginHistory(requestParameters: ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAgentLoginHistory> {
            return localVarFp.downloadAgentLoginHistory(requestParameters.clientTimeZone, requestParameters.startDt, requestParameters.endDt, requestParameters.queueDnStr, requestParameters.agentDnStr, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAgentLoginHistoryData
         * @param {ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentLoginHistoryData(requestParameters: ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAgentLoginHistory> {
            return localVarFp.getAgentLoginHistoryData(requestParameters.clientTimeZone, requestParameters.startDt, requestParameters.endDt, requestParameters.queueDnStr, requestParameters.agentDnStr, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAgentLoginHistory operation in ReportAgentLoginHistoryApi.
 * @export
 * @interface ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest
 */
export interface ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest {
    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly endDt: string

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly queueDnStr: string | null

    /**
     * Usage: agentDnStr&#x3D;{agentDnStr}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly agentDnStr: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiDownloadAgentLoginHistory
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAgentLoginHistoryData operation in ReportAgentLoginHistoryApi.
 * @export
 * @interface ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest
 */
export interface ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest {
    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly endDt: string

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: agentDnStr&#x3D;{agentDnStr}
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly agentDnStr: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAgentLoginHistoryApiGetAgentLoginHistoryData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAgentLoginHistoryApi - object-oriented interface
 * @export
 * @class ReportAgentLoginHistoryApi
 * @extends {BaseAPI}
 */
export class ReportAgentLoginHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAgentLoginHistory
     * @param {ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAgentLoginHistoryApi
     */
    public downloadAgentLoginHistory(requestParameters: ReportAgentLoginHistoryApiDownloadAgentLoginHistoryRequest, options?: RawAxiosRequestConfig) {
        return ReportAgentLoginHistoryApiFp(this.configuration).downloadAgentLoginHistory(requestParameters.clientTimeZone, requestParameters.startDt, requestParameters.endDt, requestParameters.queueDnStr, requestParameters.agentDnStr, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAgentLoginHistoryData
     * @param {ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAgentLoginHistoryApi
     */
    public getAgentLoginHistoryData(requestParameters: ReportAgentLoginHistoryApiGetAgentLoginHistoryDataRequest, options?: RawAxiosRequestConfig) {
        return ReportAgentLoginHistoryApiFp(this.configuration).getAgentLoginHistoryData(requestParameters.clientTimeZone, requestParameters.startDt, requestParameters.endDt, requestParameters.queueDnStr, requestParameters.agentDnStr, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAgentsInQueueStatisticsApi - axios parameter creator
 * @export
 */
export const ReportAgentsInQueueStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentsInQueueStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAgentsInQueueStatistics: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadAgentsInQueueStatistics', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadAgentsInQueueStatistics', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadAgentsInQueueStatistics', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadAgentsInQueueStatistics', 'waitInterval', waitInterval)
            const localVarPath = `/ReportAgentsInQueueStatistics/Pbx.DownloadAgentsInQueueStatistics(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAgentsInQueueStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentsInQueueStatisticsData: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getAgentsInQueueStatisticsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getAgentsInQueueStatisticsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getAgentsInQueueStatisticsData', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getAgentsInQueueStatisticsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportAgentsInQueueStatistics/Pbx.GetAgentsInQueueStatisticsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAgentsInQueueStatisticsApi - functional programming interface
 * @export
 */
export const ReportAgentsInQueueStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAgentsInQueueStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentsInQueueStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAgentsInQueueStatistics(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAgentsInQueueStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAgentsInQueueStatistics(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAgentsInQueueStatisticsApi.downloadAgentsInQueueStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAgentsInQueueStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentsInQueueStatisticsData(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAgentsInQueueStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentsInQueueStatisticsData(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAgentsInQueueStatisticsApi.getAgentsInQueueStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAgentsInQueueStatisticsApi - factory interface
 * @export
 */
export const ReportAgentsInQueueStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAgentsInQueueStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAgentsInQueueStatistics
         * @param {ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAgentsInQueueStatistics(requestParameters: ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAgentsInQueueStatistics> {
            return localVarFp.downloadAgentsInQueueStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAgentsInQueueStatisticsData
         * @param {ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentsInQueueStatisticsData(requestParameters: ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAgentsInQueueStatistics> {
            return localVarFp.getAgentsInQueueStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAgentsInQueueStatistics operation in ReportAgentsInQueueStatisticsApi.
 * @export
 * @interface ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest
 */
export interface ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAgentsInQueueStatisticsData operation in ReportAgentsInQueueStatisticsApi.
 * @export
 * @interface ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest
 */
export interface ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAgentsInQueueStatisticsApi - object-oriented interface
 * @export
 * @class ReportAgentsInQueueStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportAgentsInQueueStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAgentsInQueueStatistics
     * @param {ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAgentsInQueueStatisticsApi
     */
    public downloadAgentsInQueueStatistics(requestParameters: ReportAgentsInQueueStatisticsApiDownloadAgentsInQueueStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportAgentsInQueueStatisticsApiFp(this.configuration).downloadAgentsInQueueStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAgentsInQueueStatisticsData
     * @param {ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAgentsInQueueStatisticsApi
     */
    public getAgentsInQueueStatisticsData(requestParameters: ReportAgentsInQueueStatisticsApiGetAgentsInQueueStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportAgentsInQueueStatisticsApiFp(this.configuration).getAgentsInQueueStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAuditLogApi - axios parameter creator
 * @export
 */
export const ReportAuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAuditLog
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAuditLog: async (clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadAuditLog', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportAuditLog/Pbx.DownloadAuditLog(clientTimeZone={clientTimeZone})`
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAuditLogData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogData: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ReportAuditLog/Pbx.GetAuditLogData()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAuditLogApi - functional programming interface
 * @export
 */
export const ReportAuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAuditLog
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAuditLog(clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAuditLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAuditLog(clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAuditLogApi.downloadAuditLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAuditLogData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogData($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfAuditLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogData($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAuditLogApi.getAuditLogData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAuditLogApi - factory interface
 * @export
 */
export const ReportAuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAuditLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAuditLog
         * @param {ReportAuditLogApiDownloadAuditLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAuditLog(requestParameters: ReportAuditLogApiDownloadAuditLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAuditLog> {
            return localVarFp.downloadAuditLog(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAuditLogData
         * @param {ReportAuditLogApiGetAuditLogDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogData(requestParameters: ReportAuditLogApiGetAuditLogDataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfAuditLog> {
            return localVarFp.getAuditLogData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAuditLog operation in ReportAuditLogApi.
 * @export
 * @interface ReportAuditLogApiDownloadAuditLogRequest
 */
export interface ReportAuditLogApiDownloadAuditLogRequest {
    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAuditLogApiDownloadAuditLog
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAuditLogData operation in ReportAuditLogApi.
 * @export
 * @interface ReportAuditLogApiGetAuditLogDataRequest
 */
export interface ReportAuditLogApiGetAuditLogDataRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAuditLogApiGetAuditLogData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAuditLogApi - object-oriented interface
 * @export
 * @class ReportAuditLogApi
 * @extends {BaseAPI}
 */
export class ReportAuditLogApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAuditLog
     * @param {ReportAuditLogApiDownloadAuditLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAuditLogApi
     */
    public downloadAuditLog(requestParameters: ReportAuditLogApiDownloadAuditLogRequest, options?: RawAxiosRequestConfig) {
        return ReportAuditLogApiFp(this.configuration).downloadAuditLog(requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAuditLogData
     * @param {ReportAuditLogApiGetAuditLogDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAuditLogApi
     */
    public getAuditLogData(requestParameters: ReportAuditLogApiGetAuditLogDataRequest = {}, options?: RawAxiosRequestConfig) {
        return ReportAuditLogApiFp(this.configuration).getAuditLogData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportAverageQueueWaitingTimeApi - axios parameter creator
 * @export
 */
export const ReportAverageQueueWaitingTimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadAverageQueueWaitingTimeReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAverageQueueWaitingTimeReport: async (chartDate: string, chartBy: string | null, queueDnStr: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('downloadAverageQueueWaitingTimeReport', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('downloadAverageQueueWaitingTimeReport', 'chartBy', chartBy)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadAverageQueueWaitingTimeReport', 'queueDnStr', queueDnStr)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadAverageQueueWaitingTimeReport', 'waitInterval', waitInterval)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadAverageQueueWaitingTimeReport', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportAverageQueueWaitingTime/Pbx.DownloadAverageQueueWaitingTimeReport(chartDate={chartDate},chartBy={chartBy},queueDnStr={queueDnStr},waitInterval={waitInterval},clientTimeZone={clientTimeZone})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetAverageQueueWaitingTimeData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageQueueWaitingTimeData: async (chartDate: string, chartBy: string | null, queueDnStr: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('getAverageQueueWaitingTimeData', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('getAverageQueueWaitingTimeData', 'chartBy', chartBy)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getAverageQueueWaitingTimeData', 'queueDnStr', queueDnStr)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getAverageQueueWaitingTimeData', 'waitInterval', waitInterval)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('getAverageQueueWaitingTimeData', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportAverageQueueWaitingTime/Pbx.GetAverageQueueWaitingTimeData(chartDate={chartDate},chartBy={chartBy},queueDnStr={queueDnStr},waitInterval={waitInterval},clientTimeZone={clientTimeZone})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportAverageQueueWaitingTimeApi - functional programming interface
 * @export
 */
export const ReportAverageQueueWaitingTimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportAverageQueueWaitingTimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAverageQueueWaitingTimeReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAverageQueueWaitingTimeReport(chartDate: string, chartBy: string | null, queueDnStr: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAverageQueueWaitingTimeReport(chartDate, chartBy, queueDnStr, waitInterval, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAverageQueueWaitingTimeApi.downloadAverageQueueWaitingTimeReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetAverageQueueWaitingTimeData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAverageQueueWaitingTimeData(chartDate: string, chartBy: string | null, queueDnStr: string | null, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAverageQueueWaitingTimeData(chartDate, chartBy, queueDnStr, waitInterval, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportAverageQueueWaitingTimeApi.getAverageQueueWaitingTimeData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportAverageQueueWaitingTimeApi - factory interface
 * @export
 */
export const ReportAverageQueueWaitingTimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportAverageQueueWaitingTimeApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadAverageQueueWaitingTimeReport
         * @param {ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAverageQueueWaitingTimeReport(requestParameters: ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.downloadAverageQueueWaitingTimeReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetAverageQueueWaitingTimeData
         * @param {ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageQueueWaitingTimeData(requestParameters: ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.getAverageQueueWaitingTimeData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadAverageQueueWaitingTimeReport operation in ReportAverageQueueWaitingTimeApi.
 * @export
 * @interface ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest
 */
export interface ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly chartBy: string | null

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly queueDnStr: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly waitInterval: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getAverageQueueWaitingTimeData operation in ReportAverageQueueWaitingTimeApi.
 * @export
 * @interface ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest
 */
export interface ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly chartBy: string | null

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly waitInterval: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportAverageQueueWaitingTimeApi - object-oriented interface
 * @export
 * @class ReportAverageQueueWaitingTimeApi
 * @extends {BaseAPI}
 */
export class ReportAverageQueueWaitingTimeApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadAverageQueueWaitingTimeReport
     * @param {ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAverageQueueWaitingTimeApi
     */
    public downloadAverageQueueWaitingTimeReport(requestParameters: ReportAverageQueueWaitingTimeApiDownloadAverageQueueWaitingTimeReportRequest, options?: RawAxiosRequestConfig) {
        return ReportAverageQueueWaitingTimeApiFp(this.configuration).downloadAverageQueueWaitingTimeReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetAverageQueueWaitingTimeData
     * @param {ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportAverageQueueWaitingTimeApi
     */
    public getAverageQueueWaitingTimeData(requestParameters: ReportAverageQueueWaitingTimeApiGetAverageQueueWaitingTimeDataRequest, options?: RawAxiosRequestConfig) {
        return ReportAverageQueueWaitingTimeApiFp(this.configuration).getAverageQueueWaitingTimeData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportBreachesSlaApi - axios parameter creator
 * @export
 */
export const ReportBreachesSlaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadBreachesSla
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBreachesSla: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadBreachesSla', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadBreachesSla', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadBreachesSla', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadBreachesSla', 'waitInterval', waitInterval)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadBreachesSla', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportBreachesSla/Pbx.DownloadBreachesSla(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval},clientTimeZone={clientTimeZone})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetBreachesSlaData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBreachesSlaData: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getBreachesSlaData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getBreachesSlaData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getBreachesSlaData', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getBreachesSlaData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportBreachesSla/Pbx.GetBreachesSlaData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportBreachesSlaApi - functional programming interface
 * @export
 */
export const ReportBreachesSlaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportBreachesSlaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadBreachesSla
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBreachesSla(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfBreachesSla>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBreachesSla(queueDnStr, startDt, endDt, waitInterval, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportBreachesSlaApi.downloadBreachesSla']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetBreachesSlaData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBreachesSlaData(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfBreachesSla>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBreachesSlaData(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportBreachesSlaApi.getBreachesSlaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportBreachesSlaApi - factory interface
 * @export
 */
export const ReportBreachesSlaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportBreachesSlaApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadBreachesSla
         * @param {ReportBreachesSlaApiDownloadBreachesSlaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBreachesSla(requestParameters: ReportBreachesSlaApiDownloadBreachesSlaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfBreachesSla> {
            return localVarFp.downloadBreachesSla(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetBreachesSlaData
         * @param {ReportBreachesSlaApiGetBreachesSlaDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBreachesSlaData(requestParameters: ReportBreachesSlaApiGetBreachesSlaDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfBreachesSla> {
            return localVarFp.getBreachesSlaData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadBreachesSla operation in ReportBreachesSlaApi.
 * @export
 * @interface ReportBreachesSlaApiDownloadBreachesSlaRequest
 */
export interface ReportBreachesSlaApiDownloadBreachesSlaRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly waitInterval: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiDownloadBreachesSla
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getBreachesSlaData operation in ReportBreachesSlaApi.
 * @export
 * @interface ReportBreachesSlaApiGetBreachesSlaDataRequest
 */
export interface ReportBreachesSlaApiGetBreachesSlaDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportBreachesSlaApiGetBreachesSlaData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportBreachesSlaApi - object-oriented interface
 * @export
 * @class ReportBreachesSlaApi
 * @extends {BaseAPI}
 */
export class ReportBreachesSlaApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadBreachesSla
     * @param {ReportBreachesSlaApiDownloadBreachesSlaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportBreachesSlaApi
     */
    public downloadBreachesSla(requestParameters: ReportBreachesSlaApiDownloadBreachesSlaRequest, options?: RawAxiosRequestConfig) {
        return ReportBreachesSlaApiFp(this.configuration).downloadBreachesSla(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetBreachesSlaData
     * @param {ReportBreachesSlaApiGetBreachesSlaDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportBreachesSlaApi
     */
    public getBreachesSlaData(requestParameters: ReportBreachesSlaApiGetBreachesSlaDataRequest, options?: RawAxiosRequestConfig) {
        return ReportBreachesSlaApiFp(this.configuration).getBreachesSlaData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportCallCostByExtensionGroupApi - axios parameter creator
 * @export
 */
export const ReportCallCostByExtensionGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadCallCostByExtensionGroup
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} groupFilter Usage: groupFilter&#x3D;{groupFilter}
         * @param {number} callClass Usage: callClass&#x3D;{callClass}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallCostByExtensionGroup: async (periodFrom: string, periodTo: string, groupFilter: string | null, callClass: number, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadCallCostByExtensionGroup', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadCallCostByExtensionGroup', 'periodTo', periodTo)
            // verify required parameter 'groupFilter' is not null or undefined
            assertParamExists('downloadCallCostByExtensionGroup', 'groupFilter', groupFilter)
            // verify required parameter 'callClass' is not null or undefined
            assertParamExists('downloadCallCostByExtensionGroup', 'callClass', callClass)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadCallCostByExtensionGroup', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportCallCostByExtensionGroup/Pbx.DownloadCallCostByExtensionGroup(periodFrom={periodFrom},periodTo={periodTo},groupFilter={groupFilter},callClass={callClass},clientTimeZone={clientTimeZone})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"groupFilter"}}`, encodeURIComponent(String(groupFilter)))
                .replace(`{${"callClass"}}`, encodeURIComponent(String(callClass)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCallCostByExtensionGroupData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} groupFilter Usage: groupFilter&#x3D;{groupFilter}
         * @param {number} callClass Usage: callClass&#x3D;{callClass}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallCostByExtensionGroupData: async (periodFrom: string, periodTo: string, groupFilter: string | null, callClass: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getCallCostByExtensionGroupData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getCallCostByExtensionGroupData', 'periodTo', periodTo)
            // verify required parameter 'groupFilter' is not null or undefined
            assertParamExists('getCallCostByExtensionGroupData', 'groupFilter', groupFilter)
            // verify required parameter 'callClass' is not null or undefined
            assertParamExists('getCallCostByExtensionGroupData', 'callClass', callClass)
            const localVarPath = `/ReportCallCostByExtensionGroup/Pbx.GetCallCostByExtensionGroupData(periodFrom={periodFrom},periodTo={periodTo},groupFilter={groupFilter},callClass={callClass})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"groupFilter"}}`, encodeURIComponent(String(groupFilter)))
                .replace(`{${"callClass"}}`, encodeURIComponent(String(callClass)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportCallCostByExtensionGroupApi - functional programming interface
 * @export
 */
export const ReportCallCostByExtensionGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportCallCostByExtensionGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallCostByExtensionGroup
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} groupFilter Usage: groupFilter&#x3D;{groupFilter}
         * @param {number} callClass Usage: callClass&#x3D;{callClass}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCallCostByExtensionGroup(periodFrom: string, periodTo: string, groupFilter: string | null, callClass: number, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCallCostByExtensionGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCallCostByExtensionGroup(periodFrom, periodTo, groupFilter, callClass, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallCostByExtensionGroupApi.downloadCallCostByExtensionGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCallCostByExtensionGroupData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} groupFilter Usage: groupFilter&#x3D;{groupFilter}
         * @param {number} callClass Usage: callClass&#x3D;{callClass}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallCostByExtensionGroupData(periodFrom: string, periodTo: string, groupFilter: string | null, callClass: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCallCostByExtensionGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallCostByExtensionGroupData(periodFrom, periodTo, groupFilter, callClass, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallCostByExtensionGroupApi.getCallCostByExtensionGroupData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportCallCostByExtensionGroupApi - factory interface
 * @export
 */
export const ReportCallCostByExtensionGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportCallCostByExtensionGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallCostByExtensionGroup
         * @param {ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallCostByExtensionGroup(requestParameters: ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCallCostByExtensionGroup> {
            return localVarFp.downloadCallCostByExtensionGroup(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.groupFilter, requestParameters.callClass, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCallCostByExtensionGroupData
         * @param {ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallCostByExtensionGroupData(requestParameters: ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCallCostByExtensionGroup> {
            return localVarFp.getCallCostByExtensionGroupData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.groupFilter, requestParameters.callClass, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadCallCostByExtensionGroup operation in ReportCallCostByExtensionGroupApi.
 * @export
 * @interface ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest
 */
export interface ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly periodTo: string

    /**
     * Usage: groupFilter&#x3D;{groupFilter}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly groupFilter: string | null

    /**
     * Usage: callClass&#x3D;{callClass}
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly callClass: number

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCallCostByExtensionGroupData operation in ReportCallCostByExtensionGroupApi.
 * @export
 * @interface ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest
 */
export interface ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly periodTo: string

    /**
     * Usage: groupFilter&#x3D;{groupFilter}
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly groupFilter: string | null

    /**
     * Usage: callClass&#x3D;{callClass}
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly callClass: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportCallCostByExtensionGroupApi - object-oriented interface
 * @export
 * @class ReportCallCostByExtensionGroupApi
 * @extends {BaseAPI}
 */
export class ReportCallCostByExtensionGroupApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadCallCostByExtensionGroup
     * @param {ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallCostByExtensionGroupApi
     */
    public downloadCallCostByExtensionGroup(requestParameters: ReportCallCostByExtensionGroupApiDownloadCallCostByExtensionGroupRequest, options?: RawAxiosRequestConfig) {
        return ReportCallCostByExtensionGroupApiFp(this.configuration).downloadCallCostByExtensionGroup(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.groupFilter, requestParameters.callClass, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCallCostByExtensionGroupData
     * @param {ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallCostByExtensionGroupApi
     */
    public getCallCostByExtensionGroupData(requestParameters: ReportCallCostByExtensionGroupApiGetCallCostByExtensionGroupDataRequest, options?: RawAxiosRequestConfig) {
        return ReportCallCostByExtensionGroupApiFp(this.configuration).getCallCostByExtensionGroupData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.groupFilter, requestParameters.callClass, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportCallDistributionApi - axios parameter creator
 * @export
 */
export const ReportCallDistributionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadCallDistributionReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} groupStr Usage: groupStr&#x3D;{groupStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallDistributionReport: async (chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, groupStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'chartBy', chartBy)
            // verify required parameter 'includeInternalCalls' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'includeInternalCalls', includeInternalCalls)
            // verify required parameter 'includeQueueCalls' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'includeQueueCalls', includeQueueCalls)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'queueDnStr', queueDnStr)
            // verify required parameter 'groupStr' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'groupStr', groupStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadCallDistributionReport', 'waitInterval', waitInterval)
            const localVarPath = `/ReportCallDistribution/Pbx.DownloadCallDistributionReport(chartDate={chartDate},chartBy={chartBy},includeInternalCalls={includeInternalCalls},includeQueueCalls={includeQueueCalls},queueDnStr={queueDnStr},groupStr={groupStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"includeInternalCalls"}}`, encodeURIComponent(String(includeInternalCalls)))
                .replace(`{${"includeQueueCalls"}}`, encodeURIComponent(String(includeQueueCalls)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"groupStr"}}`, encodeURIComponent(String(groupStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCallDistributionData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} groupStr Usage: groupStr&#x3D;{groupStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallDistributionData: async (chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, groupStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('getCallDistributionData', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('getCallDistributionData', 'chartBy', chartBy)
            // verify required parameter 'includeInternalCalls' is not null or undefined
            assertParamExists('getCallDistributionData', 'includeInternalCalls', includeInternalCalls)
            // verify required parameter 'includeQueueCalls' is not null or undefined
            assertParamExists('getCallDistributionData', 'includeQueueCalls', includeQueueCalls)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getCallDistributionData', 'queueDnStr', queueDnStr)
            // verify required parameter 'groupStr' is not null or undefined
            assertParamExists('getCallDistributionData', 'groupStr', groupStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('getCallDistributionData', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getCallDistributionData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportCallDistribution/Pbx.GetCallDistributionData(chartDate={chartDate},chartBy={chartBy},includeInternalCalls={includeInternalCalls},includeQueueCalls={includeQueueCalls},queueDnStr={queueDnStr},groupStr={groupStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"includeInternalCalls"}}`, encodeURIComponent(String(includeInternalCalls)))
                .replace(`{${"includeQueueCalls"}}`, encodeURIComponent(String(includeQueueCalls)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"groupStr"}}`, encodeURIComponent(String(groupStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportCallDistributionApi - functional programming interface
 * @export
 */
export const ReportCallDistributionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportCallDistributionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallDistributionReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} groupStr Usage: groupStr&#x3D;{groupStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCallDistributionReport(chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, groupStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCallDistributionReport(chartDate, chartBy, includeInternalCalls, includeQueueCalls, queueDnStr, groupStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallDistributionApi.downloadCallDistributionReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCallDistributionData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} groupStr Usage: groupStr&#x3D;{groupStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallDistributionData(chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, groupStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallDistributionData(chartDate, chartBy, includeInternalCalls, includeQueueCalls, queueDnStr, groupStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallDistributionApi.getCallDistributionData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportCallDistributionApi - factory interface
 * @export
 */
export const ReportCallDistributionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportCallDistributionApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallDistributionReport
         * @param {ReportCallDistributionApiDownloadCallDistributionReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallDistributionReport(requestParameters: ReportCallDistributionApiDownloadCallDistributionReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.downloadCallDistributionReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.groupStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCallDistributionData
         * @param {ReportCallDistributionApiGetCallDistributionDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallDistributionData(requestParameters: ReportCallDistributionApiGetCallDistributionDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.getCallDistributionData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.groupStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadCallDistributionReport operation in ReportCallDistributionApi.
 * @export
 * @interface ReportCallDistributionApiDownloadCallDistributionReportRequest
 */
export interface ReportCallDistributionApiDownloadCallDistributionReportRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly chartBy: string | null

    /**
     * Usage: includeInternalCalls&#x3D;{includeInternalCalls}
     * @type {boolean}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly includeInternalCalls: boolean

    /**
     * Usage: includeQueueCalls&#x3D;{includeQueueCalls}
     * @type {boolean}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly includeQueueCalls: boolean

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly queueDnStr: string | null

    /**
     * Usage: groupStr&#x3D;{groupStr}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly groupStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiDownloadCallDistributionReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCallDistributionData operation in ReportCallDistributionApi.
 * @export
 * @interface ReportCallDistributionApiGetCallDistributionDataRequest
 */
export interface ReportCallDistributionApiGetCallDistributionDataRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly chartBy: string | null

    /**
     * Usage: includeInternalCalls&#x3D;{includeInternalCalls}
     * @type {boolean}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly includeInternalCalls: boolean

    /**
     * Usage: includeQueueCalls&#x3D;{includeQueueCalls}
     * @type {boolean}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly includeQueueCalls: boolean

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: groupStr&#x3D;{groupStr}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly groupStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallDistributionApiGetCallDistributionData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportCallDistributionApi - object-oriented interface
 * @export
 * @class ReportCallDistributionApi
 * @extends {BaseAPI}
 */
export class ReportCallDistributionApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadCallDistributionReport
     * @param {ReportCallDistributionApiDownloadCallDistributionReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallDistributionApi
     */
    public downloadCallDistributionReport(requestParameters: ReportCallDistributionApiDownloadCallDistributionReportRequest, options?: RawAxiosRequestConfig) {
        return ReportCallDistributionApiFp(this.configuration).downloadCallDistributionReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.groupStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCallDistributionData
     * @param {ReportCallDistributionApiGetCallDistributionDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallDistributionApi
     */
    public getCallDistributionData(requestParameters: ReportCallDistributionApiGetCallDistributionDataRequest, options?: RawAxiosRequestConfig) {
        return ReportCallDistributionApiFp(this.configuration).getCallDistributionData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.groupStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportCallLogDataApi - axios parameter creator
 * @export
 */
export const ReportCallLogDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadCallLog
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} sourceType Usage: sourceType&#x3D;{sourceType}
         * @param {string | null} sourceFilter Usage: sourceFilter&#x3D;{sourceFilter}
         * @param {number} destinationType Usage: destinationType&#x3D;{destinationType}
         * @param {string | null} destinationFilter Usage: destinationFilter&#x3D;{destinationFilter}
         * @param {number} callsType Usage: callsType&#x3D;{callsType}
         * @param {number} callTimeFilterType Usage: callTimeFilterType&#x3D;{callTimeFilterType}
         * @param {string | null} callTimeFilterFrom Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
         * @param {string | null} callTimeFilterTo Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
         * @param {boolean} hidePcalls Usage: hidePcalls&#x3D;{hidePcalls}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallLog: async (periodFrom: string, periodTo: string, sourceType: number, sourceFilter: string | null, destinationType: number, destinationFilter: string | null, callsType: number, callTimeFilterType: number, callTimeFilterFrom: string | null, callTimeFilterTo: string | null, hidePcalls: boolean, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadCallLog', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadCallLog', 'periodTo', periodTo)
            // verify required parameter 'sourceType' is not null or undefined
            assertParamExists('downloadCallLog', 'sourceType', sourceType)
            // verify required parameter 'sourceFilter' is not null or undefined
            assertParamExists('downloadCallLog', 'sourceFilter', sourceFilter)
            // verify required parameter 'destinationType' is not null or undefined
            assertParamExists('downloadCallLog', 'destinationType', destinationType)
            // verify required parameter 'destinationFilter' is not null or undefined
            assertParamExists('downloadCallLog', 'destinationFilter', destinationFilter)
            // verify required parameter 'callsType' is not null or undefined
            assertParamExists('downloadCallLog', 'callsType', callsType)
            // verify required parameter 'callTimeFilterType' is not null or undefined
            assertParamExists('downloadCallLog', 'callTimeFilterType', callTimeFilterType)
            // verify required parameter 'callTimeFilterFrom' is not null or undefined
            assertParamExists('downloadCallLog', 'callTimeFilterFrom', callTimeFilterFrom)
            // verify required parameter 'callTimeFilterTo' is not null or undefined
            assertParamExists('downloadCallLog', 'callTimeFilterTo', callTimeFilterTo)
            // verify required parameter 'hidePcalls' is not null or undefined
            assertParamExists('downloadCallLog', 'hidePcalls', hidePcalls)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadCallLog', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportCallLogData/Pbx.DownloadCallLog(periodFrom={periodFrom},periodTo={periodTo},sourceType={sourceType},sourceFilter={sourceFilter},destinationType={destinationType},destinationFilter={destinationFilter},callsType={callsType},callTimeFilterType={callTimeFilterType},callTimeFilterFrom={callTimeFilterFrom},callTimeFilterTo={callTimeFilterTo},hidePcalls={hidePcalls},clientTimeZone={clientTimeZone})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"sourceType"}}`, encodeURIComponent(String(sourceType)))
                .replace(`{${"sourceFilter"}}`, encodeURIComponent(String(sourceFilter)))
                .replace(`{${"destinationType"}}`, encodeURIComponent(String(destinationType)))
                .replace(`{${"destinationFilter"}}`, encodeURIComponent(String(destinationFilter)))
                .replace(`{${"callsType"}}`, encodeURIComponent(String(callsType)))
                .replace(`{${"callTimeFilterType"}}`, encodeURIComponent(String(callTimeFilterType)))
                .replace(`{${"callTimeFilterFrom"}}`, encodeURIComponent(String(callTimeFilterFrom)))
                .replace(`{${"callTimeFilterTo"}}`, encodeURIComponent(String(callTimeFilterTo)))
                .replace(`{${"hidePcalls"}}`, encodeURIComponent(String(hidePcalls)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCallLogData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} sourceType Usage: sourceType&#x3D;{sourceType}
         * @param {string | null} sourceFilter Usage: sourceFilter&#x3D;{sourceFilter}
         * @param {number} destinationType Usage: destinationType&#x3D;{destinationType}
         * @param {string | null} destinationFilter Usage: destinationFilter&#x3D;{destinationFilter}
         * @param {number} callsType Usage: callsType&#x3D;{callsType}
         * @param {number} callTimeFilterType Usage: callTimeFilterType&#x3D;{callTimeFilterType}
         * @param {string | null} callTimeFilterFrom Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
         * @param {string | null} callTimeFilterTo Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
         * @param {boolean} hidePcalls Usage: hidePcalls&#x3D;{hidePcalls}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallLogData: async (periodFrom: string, periodTo: string, sourceType: number, sourceFilter: string | null, destinationType: number, destinationFilter: string | null, callsType: number, callTimeFilterType: number, callTimeFilterFrom: string | null, callTimeFilterTo: string | null, hidePcalls: boolean, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getCallLogData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getCallLogData', 'periodTo', periodTo)
            // verify required parameter 'sourceType' is not null or undefined
            assertParamExists('getCallLogData', 'sourceType', sourceType)
            // verify required parameter 'sourceFilter' is not null or undefined
            assertParamExists('getCallLogData', 'sourceFilter', sourceFilter)
            // verify required parameter 'destinationType' is not null or undefined
            assertParamExists('getCallLogData', 'destinationType', destinationType)
            // verify required parameter 'destinationFilter' is not null or undefined
            assertParamExists('getCallLogData', 'destinationFilter', destinationFilter)
            // verify required parameter 'callsType' is not null or undefined
            assertParamExists('getCallLogData', 'callsType', callsType)
            // verify required parameter 'callTimeFilterType' is not null or undefined
            assertParamExists('getCallLogData', 'callTimeFilterType', callTimeFilterType)
            // verify required parameter 'callTimeFilterFrom' is not null or undefined
            assertParamExists('getCallLogData', 'callTimeFilterFrom', callTimeFilterFrom)
            // verify required parameter 'callTimeFilterTo' is not null or undefined
            assertParamExists('getCallLogData', 'callTimeFilterTo', callTimeFilterTo)
            // verify required parameter 'hidePcalls' is not null or undefined
            assertParamExists('getCallLogData', 'hidePcalls', hidePcalls)
            const localVarPath = `/ReportCallLogData/Pbx.GetCallLogData(periodFrom={periodFrom},periodTo={periodTo},sourceType={sourceType},sourceFilter={sourceFilter},destinationType={destinationType},destinationFilter={destinationFilter},callsType={callsType},callTimeFilterType={callTimeFilterType},callTimeFilterFrom={callTimeFilterFrom},callTimeFilterTo={callTimeFilterTo},hidePcalls={hidePcalls})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"sourceType"}}`, encodeURIComponent(String(sourceType)))
                .replace(`{${"sourceFilter"}}`, encodeURIComponent(String(sourceFilter)))
                .replace(`{${"destinationType"}}`, encodeURIComponent(String(destinationType)))
                .replace(`{${"destinationFilter"}}`, encodeURIComponent(String(destinationFilter)))
                .replace(`{${"callsType"}}`, encodeURIComponent(String(callsType)))
                .replace(`{${"callTimeFilterType"}}`, encodeURIComponent(String(callTimeFilterType)))
                .replace(`{${"callTimeFilterFrom"}}`, encodeURIComponent(String(callTimeFilterFrom)))
                .replace(`{${"callTimeFilterTo"}}`, encodeURIComponent(String(callTimeFilterTo)))
                .replace(`{${"hidePcalls"}}`, encodeURIComponent(String(hidePcalls)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetCallQualityReport
         * @param {number} callId Usage: call_id&#x3D;{call_id}
         * @param {string} srcNumber Usage: srcNumber&#x3D;{srcNumber}
         * @param {string} dstNumber Usage: dstNumber&#x3D;{dstNumber}
         * @param {string | null} srcCallerId Usage: srcCallerId&#x3D;{srcCallerId}
         * @param {string | null} dstCallerId Usage: dstCallerId&#x3D;{dstCallerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallQualityReport: async (callId: number, srcNumber: string, dstNumber: string, srcCallerId: string | null, dstCallerId: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callId' is not null or undefined
            assertParamExists('getCallQualityReport', 'callId', callId)
            // verify required parameter 'srcNumber' is not null or undefined
            assertParamExists('getCallQualityReport', 'srcNumber', srcNumber)
            // verify required parameter 'dstNumber' is not null or undefined
            assertParamExists('getCallQualityReport', 'dstNumber', dstNumber)
            // verify required parameter 'srcCallerId' is not null or undefined
            assertParamExists('getCallQualityReport', 'srcCallerId', srcCallerId)
            // verify required parameter 'dstCallerId' is not null or undefined
            assertParamExists('getCallQualityReport', 'dstCallerId', dstCallerId)
            const localVarPath = `/ReportCallLogData/Pbx.GetCallQualityReport(call_id={call_id},srcNumber={srcNumber},dstNumber={dstNumber},srcCallerId={srcCallerId},dstCallerId={dstCallerId})`
                .replace(`{${"call_id"}}`, encodeURIComponent(String(callId)))
                .replace(`{${"srcNumber"}}`, encodeURIComponent(String(srcNumber)))
                .replace(`{${"dstNumber"}}`, encodeURIComponent(String(dstNumber)))
                .replace(`{${"srcCallerId"}}`, encodeURIComponent(String(srcCallerId)))
                .replace(`{${"dstCallerId"}}`, encodeURIComponent(String(dstCallerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportCallLogDataApi - functional programming interface
 * @export
 */
export const ReportCallLogDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportCallLogDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallLog
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} sourceType Usage: sourceType&#x3D;{sourceType}
         * @param {string | null} sourceFilter Usage: sourceFilter&#x3D;{sourceFilter}
         * @param {number} destinationType Usage: destinationType&#x3D;{destinationType}
         * @param {string | null} destinationFilter Usage: destinationFilter&#x3D;{destinationFilter}
         * @param {number} callsType Usage: callsType&#x3D;{callsType}
         * @param {number} callTimeFilterType Usage: callTimeFilterType&#x3D;{callTimeFilterType}
         * @param {string | null} callTimeFilterFrom Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
         * @param {string | null} callTimeFilterTo Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
         * @param {boolean} hidePcalls Usage: hidePcalls&#x3D;{hidePcalls}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCallLog(periodFrom: string, periodTo: string, sourceType: number, sourceFilter: string | null, destinationType: number, destinationFilter: string | null, callsType: number, callTimeFilterType: number, callTimeFilterFrom: string | null, callTimeFilterTo: string | null, hidePcalls: boolean, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCallLogData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCallLog(periodFrom, periodTo, sourceType, sourceFilter, destinationType, destinationFilter, callsType, callTimeFilterType, callTimeFilterFrom, callTimeFilterTo, hidePcalls, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallLogDataApi.downloadCallLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCallLogData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} sourceType Usage: sourceType&#x3D;{sourceType}
         * @param {string | null} sourceFilter Usage: sourceFilter&#x3D;{sourceFilter}
         * @param {number} destinationType Usage: destinationType&#x3D;{destinationType}
         * @param {string | null} destinationFilter Usage: destinationFilter&#x3D;{destinationFilter}
         * @param {number} callsType Usage: callsType&#x3D;{callsType}
         * @param {number} callTimeFilterType Usage: callTimeFilterType&#x3D;{callTimeFilterType}
         * @param {string | null} callTimeFilterFrom Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
         * @param {string | null} callTimeFilterTo Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
         * @param {boolean} hidePcalls Usage: hidePcalls&#x3D;{hidePcalls}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallLogData(periodFrom: string, periodTo: string, sourceType: number, sourceFilter: string | null, destinationType: number, destinationFilter: string | null, callsType: number, callTimeFilterType: number, callTimeFilterFrom: string | null, callTimeFilterTo: string | null, hidePcalls: boolean, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfCallLogData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallLogData(periodFrom, periodTo, sourceType, sourceFilter, destinationType, destinationFilter, callsType, callTimeFilterType, callTimeFilterFrom, callTimeFilterTo, hidePcalls, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallLogDataApi.getCallLogData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetCallQualityReport
         * @param {number} callId Usage: call_id&#x3D;{call_id}
         * @param {string} srcNumber Usage: srcNumber&#x3D;{srcNumber}
         * @param {string} dstNumber Usage: dstNumber&#x3D;{dstNumber}
         * @param {string | null} srcCallerId Usage: srcCallerId&#x3D;{srcCallerId}
         * @param {string | null} dstCallerId Usage: dstCallerId&#x3D;{dstCallerId}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallQualityReport(callId: number, srcNumber: string, dstNumber: string, srcCallerId: string | null, dstCallerId: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCallQualityReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCallQualityReport(callId, srcNumber, dstNumber, srcCallerId, dstCallerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportCallLogDataApi.getCallQualityReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportCallLogDataApi - factory interface
 * @export
 */
export const ReportCallLogDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportCallLogDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadCallLog
         * @param {ReportCallLogDataApiDownloadCallLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCallLog(requestParameters: ReportCallLogDataApiDownloadCallLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCallLogData> {
            return localVarFp.downloadCallLog(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.sourceType, requestParameters.sourceFilter, requestParameters.destinationType, requestParameters.destinationFilter, requestParameters.callsType, requestParameters.callTimeFilterType, requestParameters.callTimeFilterFrom, requestParameters.callTimeFilterTo, requestParameters.hidePcalls, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCallLogData
         * @param {ReportCallLogDataApiGetCallLogDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallLogData(requestParameters: ReportCallLogDataApiGetCallLogDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfCallLogData> {
            return localVarFp.getCallLogData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.sourceType, requestParameters.sourceFilter, requestParameters.destinationType, requestParameters.destinationFilter, requestParameters.callsType, requestParameters.callTimeFilterType, requestParameters.callTimeFilterFrom, requestParameters.callTimeFilterTo, requestParameters.hidePcalls, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetCallQualityReport
         * @param {ReportCallLogDataApiGetCallQualityReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallQualityReport(requestParameters: ReportCallLogDataApiGetCallQualityReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCallQualityReport200Response> {
            return localVarFp.getCallQualityReport(requestParameters.callId, requestParameters.srcNumber, requestParameters.dstNumber, requestParameters.srcCallerId, requestParameters.dstCallerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadCallLog operation in ReportCallLogDataApi.
 * @export
 * @interface ReportCallLogDataApiDownloadCallLogRequest
 */
export interface ReportCallLogDataApiDownloadCallLogRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly periodTo: string

    /**
     * Usage: sourceType&#x3D;{sourceType}
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly sourceType: number

    /**
     * Usage: sourceFilter&#x3D;{sourceFilter}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly sourceFilter: string | null

    /**
     * Usage: destinationType&#x3D;{destinationType}
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly destinationType: number

    /**
     * Usage: destinationFilter&#x3D;{destinationFilter}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly destinationFilter: string | null

    /**
     * Usage: callsType&#x3D;{callsType}
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly callsType: number

    /**
     * Usage: callTimeFilterType&#x3D;{callTimeFilterType}
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly callTimeFilterType: number

    /**
     * Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly callTimeFilterFrom: string | null

    /**
     * Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly callTimeFilterTo: string | null

    /**
     * Usage: hidePcalls&#x3D;{hidePcalls}
     * @type {boolean}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly hidePcalls: boolean

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiDownloadCallLog
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCallLogData operation in ReportCallLogDataApi.
 * @export
 * @interface ReportCallLogDataApiGetCallLogDataRequest
 */
export interface ReportCallLogDataApiGetCallLogDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly periodTo: string

    /**
     * Usage: sourceType&#x3D;{sourceType}
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly sourceType: number

    /**
     * Usage: sourceFilter&#x3D;{sourceFilter}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly sourceFilter: string | null

    /**
     * Usage: destinationType&#x3D;{destinationType}
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly destinationType: number

    /**
     * Usage: destinationFilter&#x3D;{destinationFilter}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly destinationFilter: string | null

    /**
     * Usage: callsType&#x3D;{callsType}
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly callsType: number

    /**
     * Usage: callTimeFilterType&#x3D;{callTimeFilterType}
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly callTimeFilterType: number

    /**
     * Usage: callTimeFilterFrom&#x3D;{callTimeFilterFrom}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly callTimeFilterFrom: string | null

    /**
     * Usage: callTimeFilterTo&#x3D;{callTimeFilterTo}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly callTimeFilterTo: string | null

    /**
     * Usage: hidePcalls&#x3D;{hidePcalls}
     * @type {boolean}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly hidePcalls: boolean

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportCallLogDataApiGetCallLogData
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getCallQualityReport operation in ReportCallLogDataApi.
 * @export
 * @interface ReportCallLogDataApiGetCallQualityReportRequest
 */
export interface ReportCallLogDataApiGetCallQualityReportRequest {
    /**
     * Usage: call_id&#x3D;{call_id}
     * @type {number}
     * @memberof ReportCallLogDataApiGetCallQualityReport
     */
    readonly callId: number

    /**
     * Usage: srcNumber&#x3D;{srcNumber}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallQualityReport
     */
    readonly srcNumber: string

    /**
     * Usage: dstNumber&#x3D;{dstNumber}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallQualityReport
     */
    readonly dstNumber: string

    /**
     * Usage: srcCallerId&#x3D;{srcCallerId}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallQualityReport
     */
    readonly srcCallerId: string | null

    /**
     * Usage: dstCallerId&#x3D;{dstCallerId}
     * @type {string}
     * @memberof ReportCallLogDataApiGetCallQualityReport
     */
    readonly dstCallerId: string | null
}

/**
 * ReportCallLogDataApi - object-oriented interface
 * @export
 * @class ReportCallLogDataApi
 * @extends {BaseAPI}
 */
export class ReportCallLogDataApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadCallLog
     * @param {ReportCallLogDataApiDownloadCallLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallLogDataApi
     */
    public downloadCallLog(requestParameters: ReportCallLogDataApiDownloadCallLogRequest, options?: RawAxiosRequestConfig) {
        return ReportCallLogDataApiFp(this.configuration).downloadCallLog(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.sourceType, requestParameters.sourceFilter, requestParameters.destinationType, requestParameters.destinationFilter, requestParameters.callsType, requestParameters.callTimeFilterType, requestParameters.callTimeFilterFrom, requestParameters.callTimeFilterTo, requestParameters.hidePcalls, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCallLogData
     * @param {ReportCallLogDataApiGetCallLogDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallLogDataApi
     */
    public getCallLogData(requestParameters: ReportCallLogDataApiGetCallLogDataRequest, options?: RawAxiosRequestConfig) {
        return ReportCallLogDataApiFp(this.configuration).getCallLogData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.sourceType, requestParameters.sourceFilter, requestParameters.destinationType, requestParameters.destinationFilter, requestParameters.callsType, requestParameters.callTimeFilterType, requestParameters.callTimeFilterFrom, requestParameters.callTimeFilterTo, requestParameters.hidePcalls, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetCallQualityReport
     * @param {ReportCallLogDataApiGetCallQualityReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportCallLogDataApi
     */
    public getCallQualityReport(requestParameters: ReportCallLogDataApiGetCallQualityReportRequest, options?: RawAxiosRequestConfig) {
        return ReportCallLogDataApiFp(this.configuration).getCallQualityReport(requestParameters.callId, requestParameters.srcNumber, requestParameters.dstNumber, requestParameters.srcCallerId, requestParameters.dstCallerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportDetailedQueueStatisticsApi - axios parameter creator
 * @export
 */
export const ReportDetailedQueueStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadDetailedQueueStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDetailedQueueStatistics: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadDetailedQueueStatistics', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadDetailedQueueStatistics', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadDetailedQueueStatistics', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadDetailedQueueStatistics', 'waitInterval', waitInterval)
            const localVarPath = `/ReportDetailedQueueStatistics/Pbx.DownloadDetailedQueueStatistics(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetDetailedQueueStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedQueueStatisticsData: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getDetailedQueueStatisticsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getDetailedQueueStatisticsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getDetailedQueueStatisticsData', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getDetailedQueueStatisticsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportDetailedQueueStatistics/Pbx.GetDetailedQueueStatisticsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportDetailedQueueStatisticsApi - functional programming interface
 * @export
 */
export const ReportDetailedQueueStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportDetailedQueueStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadDetailedQueueStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDetailedQueueStatistics(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDetailedQueueStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDetailedQueueStatistics(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportDetailedQueueStatisticsApi.downloadDetailedQueueStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetDetailedQueueStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailedQueueStatisticsData(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfDetailedQueueStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailedQueueStatisticsData(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportDetailedQueueStatisticsApi.getDetailedQueueStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportDetailedQueueStatisticsApi - factory interface
 * @export
 */
export const ReportDetailedQueueStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportDetailedQueueStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadDetailedQueueStatistics
         * @param {ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDetailedQueueStatistics(requestParameters: ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDetailedQueueStatistics> {
            return localVarFp.downloadDetailedQueueStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetDetailedQueueStatisticsData
         * @param {ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedQueueStatisticsData(requestParameters: ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfDetailedQueueStatistics> {
            return localVarFp.getDetailedQueueStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadDetailedQueueStatistics operation in ReportDetailedQueueStatisticsApi.
 * @export
 * @interface ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest
 */
export interface ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getDetailedQueueStatisticsData operation in ReportDetailedQueueStatisticsApi.
 * @export
 * @interface ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest
 */
export interface ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportDetailedQueueStatisticsApi - object-oriented interface
 * @export
 * @class ReportDetailedQueueStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportDetailedQueueStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadDetailedQueueStatistics
     * @param {ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportDetailedQueueStatisticsApi
     */
    public downloadDetailedQueueStatistics(requestParameters: ReportDetailedQueueStatisticsApiDownloadDetailedQueueStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportDetailedQueueStatisticsApiFp(this.configuration).downloadDetailedQueueStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetDetailedQueueStatisticsData
     * @param {ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportDetailedQueueStatisticsApi
     */
    public getDetailedQueueStatisticsData(requestParameters: ReportDetailedQueueStatisticsApiGetDetailedQueueStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportDetailedQueueStatisticsApiFp(this.configuration).getDetailedQueueStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportExtensionStatisticsApi - axios parameter creator
 * @export
 */
export const ReportExtensionStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatistics
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} extensionFilter Usage: extensionFilter&#x3D;{extensionFilter}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionStatistics: async (periodFrom: string, periodTo: string, extensionFilter: string | null, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadExtensionStatistics', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadExtensionStatistics', 'periodTo', periodTo)
            // verify required parameter 'extensionFilter' is not null or undefined
            assertParamExists('downloadExtensionStatistics', 'extensionFilter', extensionFilter)
            // verify required parameter 'callArea' is not null or undefined
            assertParamExists('downloadExtensionStatistics', 'callArea', callArea)
            const localVarPath = `/ReportExtensionStatistics/Pbx.DownloadExtensionStatistics(periodFrom={periodFrom},periodTo={periodTo},extensionFilter={extensionFilter},callArea={callArea})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"extensionFilter"}}`, encodeURIComponent(String(extensionFilter)))
                .replace(`{${"callArea"}}`, encodeURIComponent(String(callArea)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} extensionFilter Usage: extensionFilter&#x3D;{extensionFilter}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionStatisticsData: async (periodFrom: string, periodTo: string, extensionFilter: string | null, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getExtensionStatisticsData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getExtensionStatisticsData', 'periodTo', periodTo)
            // verify required parameter 'extensionFilter' is not null or undefined
            assertParamExists('getExtensionStatisticsData', 'extensionFilter', extensionFilter)
            // verify required parameter 'callArea' is not null or undefined
            assertParamExists('getExtensionStatisticsData', 'callArea', callArea)
            const localVarPath = `/ReportExtensionStatistics/Pbx.GetExtensionStatisticsData(periodFrom={periodFrom},periodTo={periodTo},extensionFilter={extensionFilter},callArea={callArea})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"extensionFilter"}}`, encodeURIComponent(String(extensionFilter)))
                .replace(`{${"callArea"}}`, encodeURIComponent(String(callArea)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportExtensionStatisticsApi - functional programming interface
 * @export
 */
export const ReportExtensionStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportExtensionStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatistics
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} extensionFilter Usage: extensionFilter&#x3D;{extensionFilter}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExtensionStatistics(periodFrom: string, periodTo: string, extensionFilter: string | null, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfExtensionStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExtensionStatistics(periodFrom, periodTo, extensionFilter, callArea, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionStatisticsApi.downloadExtensionStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} extensionFilter Usage: extensionFilter&#x3D;{extensionFilter}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionStatisticsData(periodFrom: string, periodTo: string, extensionFilter: string | null, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfExtensionStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionStatisticsData(periodFrom, periodTo, extensionFilter, callArea, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionStatisticsApi.getExtensionStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportExtensionStatisticsApi - factory interface
 * @export
 */
export const ReportExtensionStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportExtensionStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatistics
         * @param {ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionStatistics(requestParameters: ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfExtensionStatistics> {
            return localVarFp.downloadExtensionStatistics(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.extensionFilter, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsData
         * @param {ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionStatisticsData(requestParameters: ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfExtensionStatistics> {
            return localVarFp.getExtensionStatisticsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.extensionFilter, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadExtensionStatistics operation in ReportExtensionStatisticsApi.
 * @export
 * @interface ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest
 */
export interface ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly periodTo: string

    /**
     * Usage: extensionFilter&#x3D;{extensionFilter}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly extensionFilter: string | null

    /**
     * Usage: callArea&#x3D;{callArea}
     * @type {number}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly callArea: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiDownloadExtensionStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getExtensionStatisticsData operation in ReportExtensionStatisticsApi.
 * @export
 * @interface ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest
 */
export interface ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly periodTo: string

    /**
     * Usage: extensionFilter&#x3D;{extensionFilter}
     * @type {string}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly extensionFilter: string | null

    /**
     * Usage: callArea&#x3D;{callArea}
     * @type {number}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly callArea: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsApiGetExtensionStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportExtensionStatisticsApi - object-oriented interface
 * @export
 * @class ReportExtensionStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportExtensionStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadExtensionStatistics
     * @param {ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionStatisticsApi
     */
    public downloadExtensionStatistics(requestParameters: ReportExtensionStatisticsApiDownloadExtensionStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionStatisticsApiFp(this.configuration).downloadExtensionStatistics(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.extensionFilter, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetExtensionStatisticsData
     * @param {ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionStatisticsApi
     */
    public getExtensionStatisticsData(requestParameters: ReportExtensionStatisticsApiGetExtensionStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionStatisticsApiFp(this.configuration).getExtensionStatisticsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.extensionFilter, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportExtensionStatisticsByGroupApi - axios parameter creator
 * @export
 */
export const ReportExtensionStatisticsByGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatisticsByGroup
         * @param {string | null} groupNumber Usage: groupNumber&#x3D;{groupNumber}
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionStatisticsByGroup: async (groupNumber: string | null, periodFrom: string, periodTo: string, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNumber' is not null or undefined
            assertParamExists('downloadExtensionStatisticsByGroup', 'groupNumber', groupNumber)
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadExtensionStatisticsByGroup', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadExtensionStatisticsByGroup', 'periodTo', periodTo)
            // verify required parameter 'callArea' is not null or undefined
            assertParamExists('downloadExtensionStatisticsByGroup', 'callArea', callArea)
            const localVarPath = `/ReportExtensionStatisticsByGroup/Pbx.DownloadExtensionStatisticsByGroup(groupNumber={groupNumber},periodFrom={periodFrom},periodTo={periodTo},callArea={callArea})`
                .replace(`{${"groupNumber"}}`, encodeURIComponent(String(groupNumber)))
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"callArea"}}`, encodeURIComponent(String(callArea)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsByGroupData
         * @param {string | null} groupNumber Usage: groupNumber&#x3D;{groupNumber}
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionStatisticsByGroupData: async (groupNumber: string | null, periodFrom: string, periodTo: string, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNumber' is not null or undefined
            assertParamExists('getExtensionStatisticsByGroupData', 'groupNumber', groupNumber)
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getExtensionStatisticsByGroupData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getExtensionStatisticsByGroupData', 'periodTo', periodTo)
            // verify required parameter 'callArea' is not null or undefined
            assertParamExists('getExtensionStatisticsByGroupData', 'callArea', callArea)
            const localVarPath = `/ReportExtensionStatisticsByGroup/Pbx.GetExtensionStatisticsByGroupData(groupNumber={groupNumber},periodFrom={periodFrom},periodTo={periodTo},callArea={callArea})`
                .replace(`{${"groupNumber"}}`, encodeURIComponent(String(groupNumber)))
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"callArea"}}`, encodeURIComponent(String(callArea)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportExtensionStatisticsByGroupApi - functional programming interface
 * @export
 */
export const ReportExtensionStatisticsByGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportExtensionStatisticsByGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatisticsByGroup
         * @param {string | null} groupNumber Usage: groupNumber&#x3D;{groupNumber}
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExtensionStatisticsByGroup(groupNumber: string | null, periodFrom: string, periodTo: string, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfReportExtensionStatisticsByGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExtensionStatisticsByGroup(groupNumber, periodFrom, periodTo, callArea, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionStatisticsByGroupApi.downloadExtensionStatisticsByGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsByGroupData
         * @param {string | null} groupNumber Usage: groupNumber&#x3D;{groupNumber}
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {number} callArea Usage: callArea&#x3D;{callArea}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionStatisticsByGroupData(groupNumber: string | null, periodFrom: string, periodTo: string, callArea: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfReportExtensionStatisticsByGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionStatisticsByGroupData(groupNumber, periodFrom, periodTo, callArea, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionStatisticsByGroupApi.getExtensionStatisticsByGroupData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportExtensionStatisticsByGroupApi - factory interface
 * @export
 */
export const ReportExtensionStatisticsByGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportExtensionStatisticsByGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionStatisticsByGroup
         * @param {ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionStatisticsByGroup(requestParameters: ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfReportExtensionStatisticsByGroup> {
            return localVarFp.downloadExtensionStatisticsByGroup(requestParameters.groupNumber, requestParameters.periodFrom, requestParameters.periodTo, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetExtensionStatisticsByGroupData
         * @param {ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionStatisticsByGroupData(requestParameters: ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfReportExtensionStatisticsByGroup> {
            return localVarFp.getExtensionStatisticsByGroupData(requestParameters.groupNumber, requestParameters.periodFrom, requestParameters.periodTo, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadExtensionStatisticsByGroup operation in ReportExtensionStatisticsByGroupApi.
 * @export
 * @interface ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest
 */
export interface ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest {
    /**
     * Usage: groupNumber&#x3D;{groupNumber}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly groupNumber: string | null

    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly periodTo: string

    /**
     * Usage: callArea&#x3D;{callArea}
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly callArea: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getExtensionStatisticsByGroupData operation in ReportExtensionStatisticsByGroupApi.
 * @export
 * @interface ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest
 */
export interface ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest {
    /**
     * Usage: groupNumber&#x3D;{groupNumber}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly groupNumber: string | null

    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly periodTo: string

    /**
     * Usage: callArea&#x3D;{callArea}
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly callArea: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportExtensionStatisticsByGroupApi - object-oriented interface
 * @export
 * @class ReportExtensionStatisticsByGroupApi
 * @extends {BaseAPI}
 */
export class ReportExtensionStatisticsByGroupApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadExtensionStatisticsByGroup
     * @param {ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionStatisticsByGroupApi
     */
    public downloadExtensionStatisticsByGroup(requestParameters: ReportExtensionStatisticsByGroupApiDownloadExtensionStatisticsByGroupRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionStatisticsByGroupApiFp(this.configuration).downloadExtensionStatisticsByGroup(requestParameters.groupNumber, requestParameters.periodFrom, requestParameters.periodTo, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetExtensionStatisticsByGroupData
     * @param {ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionStatisticsByGroupApi
     */
    public getExtensionStatisticsByGroupData(requestParameters: ReportExtensionStatisticsByGroupApiGetExtensionStatisticsByGroupDataRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionStatisticsByGroupApiFp(this.configuration).getExtensionStatisticsByGroupData(requestParameters.groupNumber, requestParameters.periodFrom, requestParameters.periodTo, requestParameters.callArea, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportExtensionsStatisticsByRingGroupsApi - axios parameter creator
 * @export
 */
export const ReportExtensionsStatisticsByRingGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionsStatisticsByRingGroups
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionsStatisticsByRingGroups: async (periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadExtensionsStatisticsByRingGroups', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadExtensionsStatisticsByRingGroups', 'periodTo', periodTo)
            // verify required parameter 'ringGroupDns' is not null or undefined
            assertParamExists('downloadExtensionsStatisticsByRingGroups', 'ringGroupDns', ringGroupDns)
            const localVarPath = `/ReportExtensionsStatisticsByRingGroups/Pbx.DownloadExtensionsStatisticsByRingGroups(periodFrom={periodFrom},periodTo={periodTo},ringGroupDns={ringGroupDns})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"ringGroupDns"}}`, encodeURIComponent(String(ringGroupDns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetExtensionsStatisticsByRingGroupsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsStatisticsByRingGroupsData: async (periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getExtensionsStatisticsByRingGroupsData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getExtensionsStatisticsByRingGroupsData', 'periodTo', periodTo)
            // verify required parameter 'ringGroupDns' is not null or undefined
            assertParamExists('getExtensionsStatisticsByRingGroupsData', 'ringGroupDns', ringGroupDns)
            const localVarPath = `/ReportExtensionsStatisticsByRingGroups/Pbx.GetExtensionsStatisticsByRingGroupsData(periodFrom={periodFrom},periodTo={periodTo},ringGroupDns={ringGroupDns})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"ringGroupDns"}}`, encodeURIComponent(String(ringGroupDns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportExtensionsStatisticsByRingGroupsApi - functional programming interface
 * @export
 */
export const ReportExtensionsStatisticsByRingGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportExtensionsStatisticsByRingGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionsStatisticsByRingGroups
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExtensionsStatisticsByRingGroups(periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfExtensionsStatisticsByRingGroups>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExtensionsStatisticsByRingGroups(periodFrom, periodTo, ringGroupDns, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionsStatisticsByRingGroupsApi.downloadExtensionsStatisticsByRingGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetExtensionsStatisticsByRingGroupsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionsStatisticsByRingGroupsData(periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfExtensionsStatisticsByRingGroups>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionsStatisticsByRingGroupsData(periodFrom, periodTo, ringGroupDns, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportExtensionsStatisticsByRingGroupsApi.getExtensionsStatisticsByRingGroupsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportExtensionsStatisticsByRingGroupsApi - factory interface
 * @export
 */
export const ReportExtensionsStatisticsByRingGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportExtensionsStatisticsByRingGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadExtensionsStatisticsByRingGroups
         * @param {ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExtensionsStatisticsByRingGroups(requestParameters: ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfExtensionsStatisticsByRingGroups> {
            return localVarFp.downloadExtensionsStatisticsByRingGroups(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetExtensionsStatisticsByRingGroupsData
         * @param {ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsStatisticsByRingGroupsData(requestParameters: ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfExtensionsStatisticsByRingGroups> {
            return localVarFp.getExtensionsStatisticsByRingGroupsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadExtensionsStatisticsByRingGroups operation in ReportExtensionsStatisticsByRingGroupsApi.
 * @export
 * @interface ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest
 */
export interface ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly periodTo: string

    /**
     * Usage: ringGroupDns&#x3D;{ringGroupDns}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly ringGroupDns: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroups
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getExtensionsStatisticsByRingGroupsData operation in ReportExtensionsStatisticsByRingGroupsApi.
 * @export
 * @interface ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest
 */
export interface ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly periodTo: string

    /**
     * Usage: ringGroupDns&#x3D;{ringGroupDns}
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly ringGroupDns: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportExtensionsStatisticsByRingGroupsApi - object-oriented interface
 * @export
 * @class ReportExtensionsStatisticsByRingGroupsApi
 * @extends {BaseAPI}
 */
export class ReportExtensionsStatisticsByRingGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadExtensionsStatisticsByRingGroups
     * @param {ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionsStatisticsByRingGroupsApi
     */
    public downloadExtensionsStatisticsByRingGroups(requestParameters: ReportExtensionsStatisticsByRingGroupsApiDownloadExtensionsStatisticsByRingGroupsRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionsStatisticsByRingGroupsApiFp(this.configuration).downloadExtensionsStatisticsByRingGroups(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetExtensionsStatisticsByRingGroupsData
     * @param {ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportExtensionsStatisticsByRingGroupsApi
     */
    public getExtensionsStatisticsByRingGroupsData(requestParameters: ReportExtensionsStatisticsByRingGroupsApiGetExtensionsStatisticsByRingGroupsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportExtensionsStatisticsByRingGroupsApiFp(this.configuration).getExtensionsStatisticsByRingGroupsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportGroupApi - axios parameter creator
 * @export
 */
export const ReportGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from ReportGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReportGroup: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ReportGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportGroupApi - functional programming interface
 * @export
 */
export const ReportGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from ReportGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReportGroup($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxReportGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReportGroup($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportGroupApi.listReportGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportGroupApi - factory interface
 * @export
 */
export const ReportGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from ReportGroup
         * @param {ReportGroupApiListReportGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReportGroup(requestParameters: ReportGroupApiListReportGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxReportGroupCollectionResponse> {
            return localVarFp.listReportGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listReportGroup operation in ReportGroupApi.
 * @export
 * @interface ReportGroupApiListReportGroupRequest
 */
export interface ReportGroupApiListReportGroupRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportGroupApiListReportGroup
     */
    readonly $expand?: Set<string>
}

/**
 * ReportGroupApi - object-oriented interface
 * @export
 * @class ReportGroupApi
 * @extends {BaseAPI}
 */
export class ReportGroupApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from ReportGroup
     * @param {ReportGroupApiListReportGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportGroupApi
     */
    public listReportGroup(requestParameters: ReportGroupApiListReportGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return ReportGroupApiFp(this.configuration).listReportGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportInboundRulesApi - axios parameter creator
 * @export
 */
export const ReportInboundRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadInboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInboundRules: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ReportInboundRules/Pbx.DownloadInboundRules()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetInboundRulesData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundRulesData: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ReportInboundRules/Pbx.GetInboundRulesData()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportInboundRulesApi - functional programming interface
 * @export
 */
export const ReportInboundRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportInboundRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadInboundRules
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadInboundRules($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfInboundRuleReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInboundRules($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportInboundRulesApi.downloadInboundRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetInboundRulesData
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInboundRulesData($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfInboundRuleReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInboundRulesData($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportInboundRulesApi.getInboundRulesData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportInboundRulesApi - factory interface
 * @export
 */
export const ReportInboundRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportInboundRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadInboundRules
         * @param {ReportInboundRulesApiDownloadInboundRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInboundRules(requestParameters: ReportInboundRulesApiDownloadInboundRulesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfInboundRuleReport> {
            return localVarFp.downloadInboundRules(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetInboundRulesData
         * @param {ReportInboundRulesApiGetInboundRulesDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboundRulesData(requestParameters: ReportInboundRulesApiGetInboundRulesDataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfInboundRuleReport> {
            return localVarFp.getInboundRulesData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadInboundRules operation in ReportInboundRulesApi.
 * @export
 * @interface ReportInboundRulesApiDownloadInboundRulesRequest
 */
export interface ReportInboundRulesApiDownloadInboundRulesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiDownloadInboundRules
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getInboundRulesData operation in ReportInboundRulesApi.
 * @export
 * @interface ReportInboundRulesApiGetInboundRulesDataRequest
 */
export interface ReportInboundRulesApiGetInboundRulesDataRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportInboundRulesApiGetInboundRulesData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportInboundRulesApi - object-oriented interface
 * @export
 * @class ReportInboundRulesApi
 * @extends {BaseAPI}
 */
export class ReportInboundRulesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadInboundRules
     * @param {ReportInboundRulesApiDownloadInboundRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportInboundRulesApi
     */
    public downloadInboundRules(requestParameters: ReportInboundRulesApiDownloadInboundRulesRequest = {}, options?: RawAxiosRequestConfig) {
        return ReportInboundRulesApiFp(this.configuration).downloadInboundRules(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetInboundRulesData
     * @param {ReportInboundRulesApiGetInboundRulesDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportInboundRulesApi
     */
    public getInboundRulesData(requestParameters: ReportInboundRulesApiGetInboundRulesDataRequest = {}, options?: RawAxiosRequestConfig) {
        return ReportInboundRulesApiFp(this.configuration).getInboundRulesData(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueAgentsChatStatisticsApi - axios parameter creator
 * @export
 */
export const ReportQueueAgentsChatStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAgentsChatStatistics: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatistics', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatistics', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatistics', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatistics', 'participantType', participantType)
            const localVarPath = `/ReportQueueAgentsChatStatistics/Pbx.DownloadQueueAgentsChatStatistics(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAgentsChatStatisticsData: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsData', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsData', 'participantType', participantType)
            const localVarPath = `/ReportQueueAgentsChatStatistics/Pbx.GetQueueAgentsChatStatisticsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueAgentsChatStatisticsApi - functional programming interface
 * @export
 */
export const ReportQueueAgentsChatStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueAgentsChatStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueAgentsChatStatistics(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAgentsChatStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueAgentsChatStatistics(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAgentsChatStatisticsApi.downloadQueueAgentsChatStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueAgentsChatStatisticsData(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAgentsChatStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueAgentsChatStatisticsData(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAgentsChatStatisticsApi.getQueueAgentsChatStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueAgentsChatStatisticsApi - factory interface
 * @export
 */
export const ReportQueueAgentsChatStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueAgentsChatStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatistics
         * @param {ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAgentsChatStatistics(requestParameters: ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAgentsChatStatistics> {
            return localVarFp.downloadQueueAgentsChatStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsData
         * @param {ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAgentsChatStatisticsData(requestParameters: ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAgentsChatStatistics> {
            return localVarFp.getQueueAgentsChatStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueAgentsChatStatistics operation in ReportQueueAgentsChatStatisticsApi.
 * @export
 * @interface ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest
 */
export interface ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueAgentsChatStatisticsData operation in ReportQueueAgentsChatStatisticsApi.
 * @export
 * @interface ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest
 */
export interface ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueAgentsChatStatisticsApi - object-oriented interface
 * @export
 * @class ReportQueueAgentsChatStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportQueueAgentsChatStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueAgentsChatStatistics
     * @param {ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAgentsChatStatisticsApi
     */
    public downloadQueueAgentsChatStatistics(requestParameters: ReportQueueAgentsChatStatisticsApiDownloadQueueAgentsChatStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAgentsChatStatisticsApiFp(this.configuration).downloadQueueAgentsChatStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueAgentsChatStatisticsData
     * @param {ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAgentsChatStatisticsApi
     */
    public getQueueAgentsChatStatisticsData(requestParameters: ReportQueueAgentsChatStatisticsApiGetQueueAgentsChatStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAgentsChatStatisticsApiFp(this.configuration).getQueueAgentsChatStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueAgentsChatStatisticsTotalsApi - axios parameter creator
 * @export
 */
export const ReportQueueAgentsChatStatisticsTotalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatisticsTotals
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAgentsChatStatisticsTotals: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatisticsTotals', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatisticsTotals', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatisticsTotals', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('downloadQueueAgentsChatStatisticsTotals', 'participantType', participantType)
            const localVarPath = `/ReportQueueAgentsChatStatisticsTotals/Pbx.DownloadQueueAgentsChatStatisticsTotals(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsTotalsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAgentsChatStatisticsTotalsData: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsTotalsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsTotalsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsTotalsData', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('getQueueAgentsChatStatisticsTotalsData', 'participantType', participantType)
            const localVarPath = `/ReportQueueAgentsChatStatisticsTotals/Pbx.GetQueueAgentsChatStatisticsTotalsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueAgentsChatStatisticsTotalsApi - functional programming interface
 * @export
 */
export const ReportQueueAgentsChatStatisticsTotalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueAgentsChatStatisticsTotalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatisticsTotals
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueAgentsChatStatisticsTotals(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAgentsChatStatisticsTotals>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueAgentsChatStatisticsTotals(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAgentsChatStatisticsTotalsApi.downloadQueueAgentsChatStatisticsTotals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsTotalsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueAgentsChatStatisticsTotalsData(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAgentsChatStatisticsTotals>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueAgentsChatStatisticsTotalsData(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAgentsChatStatisticsTotalsApi.getQueueAgentsChatStatisticsTotalsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueAgentsChatStatisticsTotalsApi - factory interface
 * @export
 */
export const ReportQueueAgentsChatStatisticsTotalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueAgentsChatStatisticsTotalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAgentsChatStatisticsTotals
         * @param {ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAgentsChatStatisticsTotals(requestParameters: ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAgentsChatStatisticsTotals> {
            return localVarFp.downloadQueueAgentsChatStatisticsTotals(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueAgentsChatStatisticsTotalsData
         * @param {ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAgentsChatStatisticsTotalsData(requestParameters: ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAgentsChatStatisticsTotals> {
            return localVarFp.getQueueAgentsChatStatisticsTotalsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueAgentsChatStatisticsTotals operation in ReportQueueAgentsChatStatisticsTotalsApi.
 * @export
 * @interface ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest
 */
export interface ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotals
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueAgentsChatStatisticsTotalsData operation in ReportQueueAgentsChatStatisticsTotalsApi.
 * @export
 * @interface ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest
 */
export interface ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueAgentsChatStatisticsTotalsApi - object-oriented interface
 * @export
 * @class ReportQueueAgentsChatStatisticsTotalsApi
 * @extends {BaseAPI}
 */
export class ReportQueueAgentsChatStatisticsTotalsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueAgentsChatStatisticsTotals
     * @param {ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApi
     */
    public downloadQueueAgentsChatStatisticsTotals(requestParameters: ReportQueueAgentsChatStatisticsTotalsApiDownloadQueueAgentsChatStatisticsTotalsRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAgentsChatStatisticsTotalsApiFp(this.configuration).downloadQueueAgentsChatStatisticsTotals(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueAgentsChatStatisticsTotalsData
     * @param {ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAgentsChatStatisticsTotalsApi
     */
    public getQueueAgentsChatStatisticsTotalsData(requestParameters: ReportQueueAgentsChatStatisticsTotalsApiGetQueueAgentsChatStatisticsTotalsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAgentsChatStatisticsTotalsApiFp(this.configuration).getQueueAgentsChatStatisticsTotalsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueAnUnCallsApi - axios parameter creator
 * @export
 */
export const ReportQueueAnUnCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnUnCallsReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAnUnCallsReport: async (chartDate: string, chartBy: string | null, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('downloadQueueAnUnCallsReport', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('downloadQueueAnUnCallsReport', 'chartBy', chartBy)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueAnUnCallsReport', 'queueDnStr', queueDnStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadQueueAnUnCallsReport', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadQueueAnUnCallsReport', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueueAnUnCalls/Pbx.DownloadQueueAnUnCallsReport(chartDate={chartDate},chartBy={chartBy},queueDnStr={queueDnStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueAnUnCallsData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAnUnCallsData: async (chartDate: string, chartBy: string | null, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('getQueueAnUnCallsData', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('getQueueAnUnCallsData', 'chartBy', chartBy)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueAnUnCallsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('getQueueAnUnCallsData', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getQueueAnUnCallsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueueAnUnCalls/Pbx.GetQueueAnUnCallsData(chartDate={chartDate},chartBy={chartBy},queueDnStr={queueDnStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueAnUnCallsApi - functional programming interface
 * @export
 */
export const ReportQueueAnUnCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueAnUnCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnUnCallsReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueAnUnCallsReport(chartDate: string, chartBy: string | null, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueAnUnCallsReport(chartDate, chartBy, queueDnStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAnUnCallsApi.downloadQueueAnUnCallsReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueAnUnCallsData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueAnUnCallsData(chartDate: string, chartBy: string | null, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueAnUnCallsData(chartDate, chartBy, queueDnStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAnUnCallsApi.getQueueAnUnCallsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueAnUnCallsApi - factory interface
 * @export
 */
export const ReportQueueAnUnCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueAnUnCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnUnCallsReport
         * @param {ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAnUnCallsReport(requestParameters: ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.downloadQueueAnUnCallsReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueAnUnCallsData
         * @param {ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAnUnCallsData(requestParameters: ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.getQueueAnUnCallsData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueAnUnCallsReport operation in ReportQueueAnUnCallsApi.
 * @export
 * @interface ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest
 */
export interface ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly chartBy: string | null

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly queueDnStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueAnUnCallsData operation in ReportQueueAnUnCallsApi.
 * @export
 * @interface ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest
 */
export interface ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly chartBy: string | null

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAnUnCallsApiGetQueueAnUnCallsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueAnUnCallsApi - object-oriented interface
 * @export
 * @class ReportQueueAnUnCallsApi
 * @extends {BaseAPI}
 */
export class ReportQueueAnUnCallsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueAnUnCallsReport
     * @param {ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAnUnCallsApi
     */
    public downloadQueueAnUnCallsReport(requestParameters: ReportQueueAnUnCallsApiDownloadQueueAnUnCallsReportRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAnUnCallsApiFp(this.configuration).downloadQueueAnUnCallsReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueAnUnCallsData
     * @param {ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAnUnCallsApi
     */
    public getQueueAnUnCallsData(requestParameters: ReportQueueAnUnCallsApiGetQueueAnUnCallsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAnUnCallsApiFp(this.configuration).getQueueAnUnCallsData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueAnsweredCallsByWaitTimeApi - axios parameter creator
 * @export
 */
export const ReportQueueAnsweredCallsByWaitTimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnsweredCallsByWaitTime
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} answerInterval Usage: answerInterval&#x3D;{answerInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAnsweredCallsByWaitTime: async (queueDnStr: string | null, startDt: string, endDt: string, answerInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueAnsweredCallsByWaitTime', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueAnsweredCallsByWaitTime', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueAnsweredCallsByWaitTime', 'endDt', endDt)
            // verify required parameter 'answerInterval' is not null or undefined
            assertParamExists('downloadQueueAnsweredCallsByWaitTime', 'answerInterval', answerInterval)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadQueueAnsweredCallsByWaitTime', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportQueueAnsweredCallsByWaitTime/Pbx.DownloadQueueAnsweredCallsByWaitTime(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},answerInterval={answerInterval},clientTimeZone={clientTimeZone})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"answerInterval"}}`, encodeURIComponent(String(answerInterval)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueAnsweredCallsByWaitTimeData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} answerInterval Usage: answerInterval&#x3D;{answerInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAnsweredCallsByWaitTimeData: async (queueDnStr: string | null, startDt: string, endDt: string, answerInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueAnsweredCallsByWaitTimeData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueAnsweredCallsByWaitTimeData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueAnsweredCallsByWaitTimeData', 'endDt', endDt)
            // verify required parameter 'answerInterval' is not null or undefined
            assertParamExists('getQueueAnsweredCallsByWaitTimeData', 'answerInterval', answerInterval)
            const localVarPath = `/ReportQueueAnsweredCallsByWaitTime/Pbx.GetQueueAnsweredCallsByWaitTimeData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},answerInterval={answerInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"answerInterval"}}`, encodeURIComponent(String(answerInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueAnsweredCallsByWaitTimeApi - functional programming interface
 * @export
 */
export const ReportQueueAnsweredCallsByWaitTimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueAnsweredCallsByWaitTimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnsweredCallsByWaitTime
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} answerInterval Usage: answerInterval&#x3D;{answerInterval}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueAnsweredCallsByWaitTime(queueDnStr: string | null, startDt: string, endDt: string, answerInterval: string | null, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAnsweredCallsByWaitTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueAnsweredCallsByWaitTime(queueDnStr, startDt, endDt, answerInterval, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAnsweredCallsByWaitTimeApi.downloadQueueAnsweredCallsByWaitTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueAnsweredCallsByWaitTimeData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} answerInterval Usage: answerInterval&#x3D;{answerInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueAnsweredCallsByWaitTimeData(queueDnStr: string | null, startDt: string, endDt: string, answerInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueAnsweredCallsByWaitTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueAnsweredCallsByWaitTimeData(queueDnStr, startDt, endDt, answerInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueAnsweredCallsByWaitTimeApi.getQueueAnsweredCallsByWaitTimeData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueAnsweredCallsByWaitTimeApi - factory interface
 * @export
 */
export const ReportQueueAnsweredCallsByWaitTimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueAnsweredCallsByWaitTimeApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueAnsweredCallsByWaitTime
         * @param {ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueAnsweredCallsByWaitTime(requestParameters: ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAnsweredCallsByWaitTime> {
            return localVarFp.downloadQueueAnsweredCallsByWaitTime(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.answerInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueAnsweredCallsByWaitTimeData
         * @param {ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueAnsweredCallsByWaitTimeData(requestParameters: ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueAnsweredCallsByWaitTime> {
            return localVarFp.getQueueAnsweredCallsByWaitTimeData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.answerInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueAnsweredCallsByWaitTime operation in ReportQueueAnsweredCallsByWaitTimeApi.
 * @export
 * @interface ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest
 */
export interface ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly endDt: string

    /**
     * Usage: answerInterval&#x3D;{answerInterval}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly answerInterval: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTime
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueAnsweredCallsByWaitTimeData operation in ReportQueueAnsweredCallsByWaitTimeApi.
 * @export
 * @interface ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest
 */
export interface ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly endDt: string

    /**
     * Usage: answerInterval&#x3D;{answerInterval}
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly answerInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueAnsweredCallsByWaitTimeApi - object-oriented interface
 * @export
 * @class ReportQueueAnsweredCallsByWaitTimeApi
 * @extends {BaseAPI}
 */
export class ReportQueueAnsweredCallsByWaitTimeApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueAnsweredCallsByWaitTime
     * @param {ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApi
     */
    public downloadQueueAnsweredCallsByWaitTime(requestParameters: ReportQueueAnsweredCallsByWaitTimeApiDownloadQueueAnsweredCallsByWaitTimeRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAnsweredCallsByWaitTimeApiFp(this.configuration).downloadQueueAnsweredCallsByWaitTime(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.answerInterval, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueAnsweredCallsByWaitTimeData
     * @param {ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueAnsweredCallsByWaitTimeApi
     */
    public getQueueAnsweredCallsByWaitTimeData(requestParameters: ReportQueueAnsweredCallsByWaitTimeApiGetQueueAnsweredCallsByWaitTimeDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueAnsweredCallsByWaitTimeApiFp(this.configuration).getQueueAnsweredCallsByWaitTimeData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.answerInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueCallbacksApi - axios parameter creator
 * @export
 */
export const ReportQueueCallbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueCallbacks
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueCallbacks: async (queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueCallbacks', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueCallbacks', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueCallbacks', 'endDt', endDt)
            const localVarPath = `/ReportQueueCallbacks/Pbx.DownloadQueueCallbacks(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueCallbacksData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueCallbacksData: async (queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueCallbacksData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueCallbacksData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueCallbacksData', 'endDt', endDt)
            const localVarPath = `/ReportQueueCallbacks/Pbx.GetQueueCallbacksData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueCallbacksApi - functional programming interface
 * @export
 */
export const ReportQueueCallbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueCallbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueCallbacks
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueCallbacks(queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueCallbacks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueCallbacks(queueDnStr, startDt, endDt, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueCallbacksApi.downloadQueueCallbacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueCallbacksData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueCallbacksData(queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueCallbacks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueCallbacksData(queueDnStr, startDt, endDt, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueCallbacksApi.getQueueCallbacksData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueCallbacksApi - factory interface
 * @export
 */
export const ReportQueueCallbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueCallbacksApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueCallbacks
         * @param {ReportQueueCallbacksApiDownloadQueueCallbacksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueCallbacks(requestParameters: ReportQueueCallbacksApiDownloadQueueCallbacksRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueCallbacks> {
            return localVarFp.downloadQueueCallbacks(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueCallbacksData
         * @param {ReportQueueCallbacksApiGetQueueCallbacksDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueCallbacksData(requestParameters: ReportQueueCallbacksApiGetQueueCallbacksDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueCallbacks> {
            return localVarFp.getQueueCallbacksData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueCallbacks operation in ReportQueueCallbacksApi.
 * @export
 * @interface ReportQueueCallbacksApiDownloadQueueCallbacksRequest
 */
export interface ReportQueueCallbacksApiDownloadQueueCallbacksRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly endDt: string

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiDownloadQueueCallbacks
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueCallbacksData operation in ReportQueueCallbacksApi.
 * @export
 * @interface ReportQueueCallbacksApiGetQueueCallbacksDataRequest
 */
export interface ReportQueueCallbacksApiGetQueueCallbacksDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly endDt: string

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueCallbacksApiGetQueueCallbacksData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueCallbacksApi - object-oriented interface
 * @export
 * @class ReportQueueCallbacksApi
 * @extends {BaseAPI}
 */
export class ReportQueueCallbacksApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueCallbacks
     * @param {ReportQueueCallbacksApiDownloadQueueCallbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueCallbacksApi
     */
    public downloadQueueCallbacks(requestParameters: ReportQueueCallbacksApiDownloadQueueCallbacksRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueCallbacksApiFp(this.configuration).downloadQueueCallbacks(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueCallbacksData
     * @param {ReportQueueCallbacksApiGetQueueCallbacksDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueCallbacksApi
     */
    public getQueueCallbacksData(requestParameters: ReportQueueCallbacksApiGetQueueCallbacksDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueCallbacksApiFp(this.configuration).getQueueCallbacksData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueChatPerformanceApi - axios parameter creator
 * @export
 */
export const ReportQueueChatPerformanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueChatPerformance
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueChatPerformance: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueChatPerformance', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueChatPerformance', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueChatPerformance', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('downloadQueueChatPerformance', 'participantType', participantType)
            const localVarPath = `/ReportQueueChatPerformance/Pbx.DownloadQueueChatPerformance(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueChatPerformanceData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueChatPerformanceData: async (queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueChatPerformanceData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueChatPerformanceData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueChatPerformanceData', 'endDt', endDt)
            // verify required parameter 'participantType' is not null or undefined
            assertParamExists('getQueueChatPerformanceData', 'participantType', participantType)
            const localVarPath = `/ReportQueueChatPerformance/Pbx.GetQueueChatPerformanceData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},participantType={participantType})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"participantType"}}`, encodeURIComponent(String(participantType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueChatPerformanceApi - functional programming interface
 * @export
 */
export const ReportQueueChatPerformanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueChatPerformanceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueChatPerformance
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueChatPerformance(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueChatPerformance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueChatPerformance(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueChatPerformanceApi.downloadQueueChatPerformance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueChatPerformanceData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} participantType Usage: participantType&#x3D;{participantType}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueChatPerformanceData(queueDnStr: string | null, startDt: string, endDt: string, participantType: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueChatPerformance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueChatPerformanceData(queueDnStr, startDt, endDt, participantType, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueChatPerformanceApi.getQueueChatPerformanceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueChatPerformanceApi - factory interface
 * @export
 */
export const ReportQueueChatPerformanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueChatPerformanceApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueChatPerformance
         * @param {ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueChatPerformance(requestParameters: ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueChatPerformance> {
            return localVarFp.downloadQueueChatPerformance(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueChatPerformanceData
         * @param {ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueChatPerformanceData(requestParameters: ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueChatPerformance> {
            return localVarFp.getQueueChatPerformanceData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueChatPerformance operation in ReportQueueChatPerformanceApi.
 * @export
 * @interface ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest
 */
export interface ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiDownloadQueueChatPerformance
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueChatPerformanceData operation in ReportQueueChatPerformanceApi.
 * @export
 * @interface ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest
 */
export interface ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly endDt: string

    /**
     * Usage: participantType&#x3D;{participantType}
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly participantType: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueChatPerformanceApiGetQueueChatPerformanceData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueChatPerformanceApi - object-oriented interface
 * @export
 * @class ReportQueueChatPerformanceApi
 * @extends {BaseAPI}
 */
export class ReportQueueChatPerformanceApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueChatPerformance
     * @param {ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueChatPerformanceApi
     */
    public downloadQueueChatPerformance(requestParameters: ReportQueueChatPerformanceApiDownloadQueueChatPerformanceRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueChatPerformanceApiFp(this.configuration).downloadQueueChatPerformance(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueChatPerformanceData
     * @param {ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueChatPerformanceApi
     */
    public getQueueChatPerformanceData(requestParameters: ReportQueueChatPerformanceApiGetQueueChatPerformanceDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueChatPerformanceApiFp(this.configuration).getQueueChatPerformanceData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.participantType, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueueFailedCallbacksApi - axios parameter creator
 * @export
 */
export const ReportQueueFailedCallbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueFailedCallbacks
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueFailedCallbacks: async (queueDnStr: string | null, startDt: string, endDt: string, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadQueueFailedCallbacks', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadQueueFailedCallbacks', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadQueueFailedCallbacks', 'endDt', endDt)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadQueueFailedCallbacks', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/ReportQueueFailedCallbacks/Pbx.DownloadQueueFailedCallbacks(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},clientTimeZone={clientTimeZone})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueueFailedCallbacksData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueFailedCallbacksData: async (queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getQueueFailedCallbacksData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getQueueFailedCallbacksData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getQueueFailedCallbacksData', 'endDt', endDt)
            const localVarPath = `/ReportQueueFailedCallbacks/Pbx.GetQueueFailedCallbacksData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueueFailedCallbacksApi - functional programming interface
 * @export
 */
export const ReportQueueFailedCallbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueueFailedCallbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueFailedCallbacks
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueueFailedCallbacks(queueDnStr: string | null, startDt: string, endDt: string, clientTimeZone: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueFailedCallbacks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueueFailedCallbacks(queueDnStr, startDt, endDt, clientTimeZone, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueFailedCallbacksApi.downloadQueueFailedCallbacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueueFailedCallbacksData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueFailedCallbacksData(queueDnStr: string | null, startDt: string, endDt: string, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueueFailedCallbacks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueFailedCallbacksData(queueDnStr, startDt, endDt, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueueFailedCallbacksApi.getQueueFailedCallbacksData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueueFailedCallbacksApi - factory interface
 * @export
 */
export const ReportQueueFailedCallbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueueFailedCallbacksApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueueFailedCallbacks
         * @param {ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueueFailedCallbacks(requestParameters: ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueFailedCallbacks> {
            return localVarFp.downloadQueueFailedCallbacks(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueueFailedCallbacksData
         * @param {ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueFailedCallbacksData(requestParameters: ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueueFailedCallbacks> {
            return localVarFp.getQueueFailedCallbacksData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueueFailedCallbacks operation in ReportQueueFailedCallbacksApi.
 * @export
 * @interface ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest
 */
export interface ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly endDt: string

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly clientTimeZone: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacks
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueueFailedCallbacksData operation in ReportQueueFailedCallbacksApi.
 * @export
 * @interface ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest
 */
export interface ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly endDt: string

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueueFailedCallbacksApiGetQueueFailedCallbacksData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueueFailedCallbacksApi - object-oriented interface
 * @export
 * @class ReportQueueFailedCallbacksApi
 * @extends {BaseAPI}
 */
export class ReportQueueFailedCallbacksApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueueFailedCallbacks
     * @param {ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueFailedCallbacksApi
     */
    public downloadQueueFailedCallbacks(requestParameters: ReportQueueFailedCallbacksApiDownloadQueueFailedCallbacksRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueFailedCallbacksApiFp(this.configuration).downloadQueueFailedCallbacks(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.clientTimeZone, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueueFailedCallbacksData
     * @param {ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueueFailedCallbacksApi
     */
    public getQueueFailedCallbacksData(requestParameters: ReportQueueFailedCallbacksApiGetQueueFailedCallbacksDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueueFailedCallbacksApiFp(this.configuration).getQueueFailedCallbacksData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueuePerformanceOverviewApi - axios parameter creator
 * @export
 */
export const ReportQueuePerformanceOverviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceOverview
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueuePerformanceOverview: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadQueuePerformanceOverview', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadQueuePerformanceOverview', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('downloadQueuePerformanceOverview', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadQueuePerformanceOverview', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueuePerformanceOverview/Pbx.DownloadQueuePerformanceOverview(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceOverviewData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueuePerformanceOverviewData: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getQueuePerformanceOverviewData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getQueuePerformanceOverviewData', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('getQueuePerformanceOverviewData', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getQueuePerformanceOverviewData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueuePerformanceOverview/Pbx.GetQueuePerformanceOverviewData(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueuePerformanceOverviewApi - functional programming interface
 * @export
 */
export const ReportQueuePerformanceOverviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueuePerformanceOverviewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceOverview
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueuePerformanceOverview(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueuePerformanceOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueuePerformanceOverview(periodFrom, periodTo, queueDns, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueuePerformanceOverviewApi.downloadQueuePerformanceOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceOverviewData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueuePerformanceOverviewData(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueuePerformanceOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuePerformanceOverviewData(periodFrom, periodTo, queueDns, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueuePerformanceOverviewApi.getQueuePerformanceOverviewData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueuePerformanceOverviewApi - factory interface
 * @export
 */
export const ReportQueuePerformanceOverviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueuePerformanceOverviewApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceOverview
         * @param {ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueuePerformanceOverview(requestParameters: ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueuePerformanceOverview> {
            return localVarFp.downloadQueuePerformanceOverview(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceOverviewData
         * @param {ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueuePerformanceOverviewData(requestParameters: ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueuePerformanceOverview> {
            return localVarFp.getQueuePerformanceOverviewData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueuePerformanceOverview operation in ReportQueuePerformanceOverviewApi.
 * @export
 * @interface ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest
 */
export interface ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverview
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueuePerformanceOverviewData operation in ReportQueuePerformanceOverviewApi.
 * @export
 * @interface ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest
 */
export interface ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueuePerformanceOverviewApi - object-oriented interface
 * @export
 * @class ReportQueuePerformanceOverviewApi
 * @extends {BaseAPI}
 */
export class ReportQueuePerformanceOverviewApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueuePerformanceOverview
     * @param {ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueuePerformanceOverviewApi
     */
    public downloadQueuePerformanceOverview(requestParameters: ReportQueuePerformanceOverviewApiDownloadQueuePerformanceOverviewRequest, options?: RawAxiosRequestConfig) {
        return ReportQueuePerformanceOverviewApiFp(this.configuration).downloadQueuePerformanceOverview(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueuePerformanceOverviewData
     * @param {ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueuePerformanceOverviewApi
     */
    public getQueuePerformanceOverviewData(requestParameters: ReportQueuePerformanceOverviewApiGetQueuePerformanceOverviewDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueuePerformanceOverviewApiFp(this.configuration).getQueuePerformanceOverviewData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportQueuePerformanceTotalsApi - axios parameter creator
 * @export
 */
export const ReportQueuePerformanceTotalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceTotals
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueuePerformanceTotals: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadQueuePerformanceTotals', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadQueuePerformanceTotals', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('downloadQueuePerformanceTotals', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadQueuePerformanceTotals', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueuePerformanceTotals/Pbx.DownloadQueuePerformanceTotals(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceTotalsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueuePerformanceTotalsData: async (periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getQueuePerformanceTotalsData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getQueuePerformanceTotalsData', 'periodTo', periodTo)
            // verify required parameter 'queueDns' is not null or undefined
            assertParamExists('getQueuePerformanceTotalsData', 'queueDns', queueDns)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getQueuePerformanceTotalsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportQueuePerformanceTotals/Pbx.GetQueuePerformanceTotalsData(periodFrom={periodFrom},periodTo={periodTo},queueDns={queueDns},waitInterval={waitInterval})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"queueDns"}}`, encodeURIComponent(String(queueDns)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportQueuePerformanceTotalsApi - functional programming interface
 * @export
 */
export const ReportQueuePerformanceTotalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportQueuePerformanceTotalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceTotals
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQueuePerformanceTotals(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueuePerformanceTotals>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQueuePerformanceTotals(periodFrom, periodTo, queueDns, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueuePerformanceTotalsApi.downloadQueuePerformanceTotals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceTotalsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} queueDns Usage: queueDns&#x3D;{queueDns}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueuePerformanceTotalsData(periodFrom: string, periodTo: string, queueDns: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfQueuePerformanceTotals>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuePerformanceTotalsData(periodFrom, periodTo, queueDns, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportQueuePerformanceTotalsApi.getQueuePerformanceTotalsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportQueuePerformanceTotalsApi - factory interface
 * @export
 */
export const ReportQueuePerformanceTotalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportQueuePerformanceTotalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadQueuePerformanceTotals
         * @param {ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQueuePerformanceTotals(requestParameters: ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueuePerformanceTotals> {
            return localVarFp.downloadQueuePerformanceTotals(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetQueuePerformanceTotalsData
         * @param {ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueuePerformanceTotalsData(requestParameters: ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfQueuePerformanceTotals> {
            return localVarFp.getQueuePerformanceTotalsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadQueuePerformanceTotals operation in ReportQueuePerformanceTotalsApi.
 * @export
 * @interface ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest
 */
export interface ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotals
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getQueuePerformanceTotalsData operation in ReportQueuePerformanceTotalsApi.
 * @export
 * @interface ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest
 */
export interface ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly periodTo: string

    /**
     * Usage: queueDns&#x3D;{queueDns}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly queueDns: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportQueuePerformanceTotalsApi - object-oriented interface
 * @export
 * @class ReportQueuePerformanceTotalsApi
 * @extends {BaseAPI}
 */
export class ReportQueuePerformanceTotalsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadQueuePerformanceTotals
     * @param {ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueuePerformanceTotalsApi
     */
    public downloadQueuePerformanceTotals(requestParameters: ReportQueuePerformanceTotalsApiDownloadQueuePerformanceTotalsRequest, options?: RawAxiosRequestConfig) {
        return ReportQueuePerformanceTotalsApiFp(this.configuration).downloadQueuePerformanceTotals(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetQueuePerformanceTotalsData
     * @param {ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportQueuePerformanceTotalsApi
     */
    public getQueuePerformanceTotalsData(requestParameters: ReportQueuePerformanceTotalsApiGetQueuePerformanceTotalsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportQueuePerformanceTotalsApiFp(this.configuration).getQueuePerformanceTotalsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.queueDns, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportRingGroupStatisticsApi - axios parameter creator
 * @export
 */
export const ReportRingGroupStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadRingGroupStatistics
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRingGroupStatistics: async (periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('downloadRingGroupStatistics', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('downloadRingGroupStatistics', 'periodTo', periodTo)
            // verify required parameter 'ringGroupDns' is not null or undefined
            assertParamExists('downloadRingGroupStatistics', 'ringGroupDns', ringGroupDns)
            const localVarPath = `/ReportRingGroupStatistics/Pbx.DownloadRingGroupStatistics(periodFrom={periodFrom},periodTo={periodTo},ringGroupDns={ringGroupDns})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"ringGroupDns"}}`, encodeURIComponent(String(ringGroupDns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRingGroupStatisticsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroupStatisticsData: async (periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'periodFrom' is not null or undefined
            assertParamExists('getRingGroupStatisticsData', 'periodFrom', periodFrom)
            // verify required parameter 'periodTo' is not null or undefined
            assertParamExists('getRingGroupStatisticsData', 'periodTo', periodTo)
            // verify required parameter 'ringGroupDns' is not null or undefined
            assertParamExists('getRingGroupStatisticsData', 'ringGroupDns', ringGroupDns)
            const localVarPath = `/ReportRingGroupStatistics/Pbx.GetRingGroupStatisticsData(periodFrom={periodFrom},periodTo={periodTo},ringGroupDns={ringGroupDns})`
                .replace(`{${"periodFrom"}}`, encodeURIComponent(String(periodFrom)))
                .replace(`{${"periodTo"}}`, encodeURIComponent(String(periodTo)))
                .replace(`{${"ringGroupDns"}}`, encodeURIComponent(String(ringGroupDns)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportRingGroupStatisticsApi - functional programming interface
 * @export
 */
export const ReportRingGroupStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportRingGroupStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadRingGroupStatistics
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRingGroupStatistics(periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfRingGroupStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRingGroupStatistics(periodFrom, periodTo, ringGroupDns, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportRingGroupStatisticsApi.downloadRingGroupStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRingGroupStatisticsData
         * @param {string} periodFrom Usage: periodFrom&#x3D;{periodFrom}
         * @param {string} periodTo Usage: periodTo&#x3D;{periodTo}
         * @param {string | null} ringGroupDns Usage: ringGroupDns&#x3D;{ringGroupDns}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRingGroupStatisticsData(periodFrom: string, periodTo: string, ringGroupDns: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfRingGroupStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRingGroupStatisticsData(periodFrom, periodTo, ringGroupDns, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportRingGroupStatisticsApi.getRingGroupStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportRingGroupStatisticsApi - factory interface
 * @export
 */
export const ReportRingGroupStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportRingGroupStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadRingGroupStatistics
         * @param {ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRingGroupStatistics(requestParameters: ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfRingGroupStatistics> {
            return localVarFp.downloadRingGroupStatistics(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRingGroupStatisticsData
         * @param {ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroupStatisticsData(requestParameters: ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfRingGroupStatistics> {
            return localVarFp.getRingGroupStatisticsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadRingGroupStatistics operation in ReportRingGroupStatisticsApi.
 * @export
 * @interface ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest
 */
export interface ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly periodTo: string

    /**
     * Usage: ringGroupDns&#x3D;{ringGroupDns}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly ringGroupDns: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiDownloadRingGroupStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getRingGroupStatisticsData operation in ReportRingGroupStatisticsApi.
 * @export
 * @interface ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest
 */
export interface ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest {
    /**
     * Usage: periodFrom&#x3D;{periodFrom}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly periodFrom: string

    /**
     * Usage: periodTo&#x3D;{periodTo}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly periodTo: string

    /**
     * Usage: ringGroupDns&#x3D;{ringGroupDns}
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly ringGroupDns: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportRingGroupStatisticsApiGetRingGroupStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportRingGroupStatisticsApi - object-oriented interface
 * @export
 * @class ReportRingGroupStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportRingGroupStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadRingGroupStatistics
     * @param {ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportRingGroupStatisticsApi
     */
    public downloadRingGroupStatistics(requestParameters: ReportRingGroupStatisticsApiDownloadRingGroupStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportRingGroupStatisticsApiFp(this.configuration).downloadRingGroupStatistics(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRingGroupStatisticsData
     * @param {ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportRingGroupStatisticsApi
     */
    public getRingGroupStatisticsData(requestParameters: ReportRingGroupStatisticsApiGetRingGroupStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportRingGroupStatisticsApiFp(this.configuration).getRingGroupStatisticsData(requestParameters.periodFrom, requestParameters.periodTo, requestParameters.ringGroupDns, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportStatisticSlaApi - axios parameter creator
 * @export
 */
export const ReportStatisticSlaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadStatisticSla
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadStatisticSla: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadStatisticSla', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadStatisticSla', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadStatisticSla', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadStatisticSla', 'waitInterval', waitInterval)
            const localVarPath = `/ReportStatisticSla/Pbx.DownloadStatisticSla(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetStatisticSlaData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticSlaData: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getStatisticSlaData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getStatisticSlaData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getStatisticSlaData', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getStatisticSlaData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportStatisticSla/Pbx.GetStatisticSlaData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportStatisticSlaApi - functional programming interface
 * @export
 */
export const ReportStatisticSlaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportStatisticSlaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadStatisticSla
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadStatisticSla(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfStatisticSla>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadStatisticSla(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportStatisticSlaApi.downloadStatisticSla']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetStatisticSlaData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatisticSlaData(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfStatisticSla>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatisticSlaData(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportStatisticSlaApi.getStatisticSlaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportStatisticSlaApi - factory interface
 * @export
 */
export const ReportStatisticSlaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportStatisticSlaApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadStatisticSla
         * @param {ReportStatisticSlaApiDownloadStatisticSlaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadStatisticSla(requestParameters: ReportStatisticSlaApiDownloadStatisticSlaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfStatisticSla> {
            return localVarFp.downloadStatisticSla(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetStatisticSlaData
         * @param {ReportStatisticSlaApiGetStatisticSlaDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatisticSlaData(requestParameters: ReportStatisticSlaApiGetStatisticSlaDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfStatisticSla> {
            return localVarFp.getStatisticSlaData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadStatisticSla operation in ReportStatisticSlaApi.
 * @export
 * @interface ReportStatisticSlaApiDownloadStatisticSlaRequest
 */
export interface ReportStatisticSlaApiDownloadStatisticSlaRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiDownloadStatisticSla
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getStatisticSlaData operation in ReportStatisticSlaApi.
 * @export
 * @interface ReportStatisticSlaApiGetStatisticSlaDataRequest
 */
export interface ReportStatisticSlaApiGetStatisticSlaDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportStatisticSlaApiGetStatisticSlaData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportStatisticSlaApi - object-oriented interface
 * @export
 * @class ReportStatisticSlaApi
 * @extends {BaseAPI}
 */
export class ReportStatisticSlaApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadStatisticSla
     * @param {ReportStatisticSlaApiDownloadStatisticSlaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportStatisticSlaApi
     */
    public downloadStatisticSla(requestParameters: ReportStatisticSlaApiDownloadStatisticSlaRequest, options?: RawAxiosRequestConfig) {
        return ReportStatisticSlaApiFp(this.configuration).downloadStatisticSla(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetStatisticSlaData
     * @param {ReportStatisticSlaApiGetStatisticSlaDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportStatisticSlaApi
     */
    public getStatisticSlaData(requestParameters: ReportStatisticSlaApiGetStatisticSlaDataRequest, options?: RawAxiosRequestConfig) {
        return ReportStatisticSlaApiFp(this.configuration).getStatisticSlaData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportTeamQueueGeneralStatisticsApi - axios parameter creator
 * @export
 */
export const ReportTeamQueueGeneralStatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadTeamQueueGeneralStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTeamQueueGeneralStatistics: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadTeamQueueGeneralStatistics', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('downloadTeamQueueGeneralStatistics', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('downloadTeamQueueGeneralStatistics', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadTeamQueueGeneralStatistics', 'waitInterval', waitInterval)
            const localVarPath = `/ReportTeamQueueGeneralStatistics/Pbx.DownloadTeamQueueGeneralStatistics(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetTeamQueueGeneralStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamQueueGeneralStatisticsData: async (queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getTeamQueueGeneralStatisticsData', 'queueDnStr', queueDnStr)
            // verify required parameter 'startDt' is not null or undefined
            assertParamExists('getTeamQueueGeneralStatisticsData', 'startDt', startDt)
            // verify required parameter 'endDt' is not null or undefined
            assertParamExists('getTeamQueueGeneralStatisticsData', 'endDt', endDt)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getTeamQueueGeneralStatisticsData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportTeamQueueGeneralStatistics/Pbx.GetTeamQueueGeneralStatisticsData(queueDnStr={queueDnStr},startDt={startDt},endDt={endDt},waitInterval={waitInterval})`
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"startDt"}}`, encodeURIComponent(String(startDt)))
                .replace(`{${"endDt"}}`, encodeURIComponent(String(endDt)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportTeamQueueGeneralStatisticsApi - functional programming interface
 * @export
 */
export const ReportTeamQueueGeneralStatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportTeamQueueGeneralStatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadTeamQueueGeneralStatistics
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTeamQueueGeneralStatistics(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTeamQueueGeneralStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTeamQueueGeneralStatistics(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportTeamQueueGeneralStatisticsApi.downloadTeamQueueGeneralStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetTeamQueueGeneralStatisticsData
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string} startDt Usage: startDt&#x3D;{startDt}
         * @param {string} endDt Usage: endDt&#x3D;{endDt}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamQueueGeneralStatisticsData(queueDnStr: string | null, startDt: string, endDt: string, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTeamQueueGeneralStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamQueueGeneralStatisticsData(queueDnStr, startDt, endDt, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportTeamQueueGeneralStatisticsApi.getTeamQueueGeneralStatisticsData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportTeamQueueGeneralStatisticsApi - factory interface
 * @export
 */
export const ReportTeamQueueGeneralStatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportTeamQueueGeneralStatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadTeamQueueGeneralStatistics
         * @param {ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTeamQueueGeneralStatistics(requestParameters: ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTeamQueueGeneralStatistics> {
            return localVarFp.downloadTeamQueueGeneralStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetTeamQueueGeneralStatisticsData
         * @param {ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamQueueGeneralStatisticsData(requestParameters: ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTeamQueueGeneralStatistics> {
            return localVarFp.getTeamQueueGeneralStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadTeamQueueGeneralStatistics operation in ReportTeamQueueGeneralStatisticsApi.
 * @export
 * @interface ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest
 */
export interface ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatistics
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getTeamQueueGeneralStatisticsData operation in ReportTeamQueueGeneralStatisticsApi.
 * @export
 * @interface ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest
 */
export interface ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest {
    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: startDt&#x3D;{startDt}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly startDt: string

    /**
     * Usage: endDt&#x3D;{endDt}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly endDt: string

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportTeamQueueGeneralStatisticsApi - object-oriented interface
 * @export
 * @class ReportTeamQueueGeneralStatisticsApi
 * @extends {BaseAPI}
 */
export class ReportTeamQueueGeneralStatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadTeamQueueGeneralStatistics
     * @param {ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportTeamQueueGeneralStatisticsApi
     */
    public downloadTeamQueueGeneralStatistics(requestParameters: ReportTeamQueueGeneralStatisticsApiDownloadTeamQueueGeneralStatisticsRequest, options?: RawAxiosRequestConfig) {
        return ReportTeamQueueGeneralStatisticsApiFp(this.configuration).downloadTeamQueueGeneralStatistics(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetTeamQueueGeneralStatisticsData
     * @param {ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportTeamQueueGeneralStatisticsApi
     */
    public getTeamQueueGeneralStatisticsData(requestParameters: ReportTeamQueueGeneralStatisticsApiGetTeamQueueGeneralStatisticsDataRequest, options?: RawAxiosRequestConfig) {
        return ReportTeamQueueGeneralStatisticsApiFp(this.configuration).getTeamQueueGeneralStatisticsData(requestParameters.queueDnStr, requestParameters.startDt, requestParameters.endDt, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportUserActivityApi - axios parameter creator
 * @export
 */
export const ReportUserActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function DownloadUserActivityReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUserActivityReport: async (chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'chartBy', chartBy)
            // verify required parameter 'includeInternalCalls' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'includeInternalCalls', includeInternalCalls)
            // verify required parameter 'includeQueueCalls' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'includeQueueCalls', includeQueueCalls)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'queueDnStr', queueDnStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('downloadUserActivityReport', 'waitInterval', waitInterval)
            const localVarPath = `/ReportUserActivity/Pbx.DownloadUserActivityReport(chartDate={chartDate},chartBy={chartBy},includeInternalCalls={includeInternalCalls},includeQueueCalls={includeQueueCalls},queueDnStr={queueDnStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"includeInternalCalls"}}`, encodeURIComponent(String(includeInternalCalls)))
                .replace(`{${"includeQueueCalls"}}`, encodeURIComponent(String(includeQueueCalls)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetUserActivityData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivityData: async (chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartDate' is not null or undefined
            assertParamExists('getUserActivityData', 'chartDate', chartDate)
            // verify required parameter 'chartBy' is not null or undefined
            assertParamExists('getUserActivityData', 'chartBy', chartBy)
            // verify required parameter 'includeInternalCalls' is not null or undefined
            assertParamExists('getUserActivityData', 'includeInternalCalls', includeInternalCalls)
            // verify required parameter 'includeQueueCalls' is not null or undefined
            assertParamExists('getUserActivityData', 'includeQueueCalls', includeQueueCalls)
            // verify required parameter 'queueDnStr' is not null or undefined
            assertParamExists('getUserActivityData', 'queueDnStr', queueDnStr)
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('getUserActivityData', 'clientTimeZone', clientTimeZone)
            // verify required parameter 'waitInterval' is not null or undefined
            assertParamExists('getUserActivityData', 'waitInterval', waitInterval)
            const localVarPath = `/ReportUserActivity/Pbx.GetUserActivityData(chartDate={chartDate},chartBy={chartBy},includeInternalCalls={includeInternalCalls},includeQueueCalls={includeQueueCalls},queueDnStr={queueDnStr},clientTimeZone={clientTimeZone},waitInterval={waitInterval})`
                .replace(`{${"chartDate"}}`, encodeURIComponent(String(chartDate)))
                .replace(`{${"chartBy"}}`, encodeURIComponent(String(chartBy)))
                .replace(`{${"includeInternalCalls"}}`, encodeURIComponent(String(includeInternalCalls)))
                .replace(`{${"includeQueueCalls"}}`, encodeURIComponent(String(includeQueueCalls)))
                .replace(`{${"queueDnStr"}}`, encodeURIComponent(String(queueDnStr)))
                .replace(`{${"clientTimeZone"}}`, encodeURIComponent(String(clientTimeZone)))
                .replace(`{${"waitInterval"}}`, encodeURIComponent(String(waitInterval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportUserActivityApi - functional programming interface
 * @export
 */
export const ReportUserActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportUserActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadUserActivityReport
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadUserActivityReport(chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadUserActivityReport(chartDate, chartBy, includeInternalCalls, includeQueueCalls, queueDnStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportUserActivityApi.downloadUserActivityReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetUserActivityData
         * @param {string} chartDate Usage: chartDate&#x3D;{chartDate}
         * @param {string | null} chartBy Usage: chartBy&#x3D;{chartBy}
         * @param {boolean} includeInternalCalls Usage: includeInternalCalls&#x3D;{includeInternalCalls}
         * @param {boolean} includeQueueCalls Usage: includeQueueCalls&#x3D;{includeQueueCalls}
         * @param {string | null} queueDnStr Usage: queueDnStr&#x3D;{queueDnStr}
         * @param {string | null} clientTimeZone Usage: clientTimeZone&#x3D;{clientTimeZone}
         * @param {string | null} waitInterval Usage: waitInterval&#x3D;{waitInterval}
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserActivityData(chartDate: string, chartBy: string | null, includeInternalCalls: boolean, includeQueueCalls: boolean, queueDnStr: string | null, clientTimeZone: string | null, waitInterval: string | null, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfTimeReportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserActivityData(chartDate, chartBy, includeInternalCalls, includeQueueCalls, queueDnStr, clientTimeZone, waitInterval, $top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportUserActivityApi.getUserActivityData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportUserActivityApi - factory interface
 * @export
 */
export const ReportUserActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportUserActivityApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function DownloadUserActivityReport
         * @param {ReportUserActivityApiDownloadUserActivityReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUserActivityReport(requestParameters: ReportUserActivityApiDownloadUserActivityReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.downloadUserActivityReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetUserActivityData
         * @param {ReportUserActivityApiGetUserActivityDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivityData(requestParameters: ReportUserActivityApiGetUserActivityDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfTimeReportData> {
            return localVarFp.getUserActivityData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadUserActivityReport operation in ReportUserActivityApi.
 * @export
 * @interface ReportUserActivityApiDownloadUserActivityReportRequest
 */
export interface ReportUserActivityApiDownloadUserActivityReportRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly chartBy: string | null

    /**
     * Usage: includeInternalCalls&#x3D;{includeInternalCalls}
     * @type {boolean}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly includeInternalCalls: boolean

    /**
     * Usage: includeQueueCalls&#x3D;{includeQueueCalls}
     * @type {boolean}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly includeQueueCalls: boolean

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly queueDnStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportUserActivityApiDownloadUserActivityReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getUserActivityData operation in ReportUserActivityApi.
 * @export
 * @interface ReportUserActivityApiGetUserActivityDataRequest
 */
export interface ReportUserActivityApiGetUserActivityDataRequest {
    /**
     * Usage: chartDate&#x3D;{chartDate}
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly chartDate: string

    /**
     * Usage: chartBy&#x3D;{chartBy}
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly chartBy: string | null

    /**
     * Usage: includeInternalCalls&#x3D;{includeInternalCalls}
     * @type {boolean}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly includeInternalCalls: boolean

    /**
     * Usage: includeQueueCalls&#x3D;{includeQueueCalls}
     * @type {boolean}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly includeQueueCalls: boolean

    /**
     * Usage: queueDnStr&#x3D;{queueDnStr}
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly queueDnStr: string | null

    /**
     * Usage: clientTimeZone&#x3D;{clientTimeZone}
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly clientTimeZone: string | null

    /**
     * Usage: waitInterval&#x3D;{waitInterval}
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly waitInterval: string | null

    /**
     * Show only the first n items
     * @type {number}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ReportUserActivityApiGetUserActivityData
     */
    readonly $expand?: Set<string>
}

/**
 * ReportUserActivityApi - object-oriented interface
 * @export
 * @class ReportUserActivityApi
 * @extends {BaseAPI}
 */
export class ReportUserActivityApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function DownloadUserActivityReport
     * @param {ReportUserActivityApiDownloadUserActivityReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportUserActivityApi
     */
    public downloadUserActivityReport(requestParameters: ReportUserActivityApiDownloadUserActivityReportRequest, options?: RawAxiosRequestConfig) {
        return ReportUserActivityApiFp(this.configuration).downloadUserActivityReport(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetUserActivityData
     * @param {ReportUserActivityApiGetUserActivityDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportUserActivityApi
     */
    public getUserActivityData(requestParameters: ReportUserActivityApiGetUserActivityDataRequest, options?: RawAxiosRequestConfig) {
        return ReportUserActivityApiFp(this.configuration).getUserActivityData(requestParameters.chartDate, requestParameters.chartBy, requestParameters.includeInternalCalls, requestParameters.includeQueueCalls, requestParameters.queueDnStr, requestParameters.clientTimeZone, requestParameters.waitInterval, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RingGroupsApi - axios parameter creator
 * @export
 */
export const RingGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to RingGroups
         * @param {PbxRingGroup} pbxRingGroup New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRingGroup: async (pbxRingGroup: PbxRingGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxRingGroup' is not null or undefined
            assertParamExists('createRingGroup', 'pbxRingGroup', pbxRingGroup)
            const localVarPath = `/RingGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxRingGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRingGroup: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRingGroup', 'id', id)
            const localVarPath = `/RingGroups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableRingGroupNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableRingGroupNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RingGroups/Pbx.GetFirstAvailableRingGroupNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from RingGroups by key
         * @param {number} id The unique identifier of RingGroup
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroup: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRingGroup', 'id', id)
            const localVarPath = `/RingGroups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroupByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getRingGroupByNumber', 'number', number)
            const localVarPath = `/RingGroups/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from RingGroups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRingGroup: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/RingGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Members from RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRingGroupMembers: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRingGroupMembers', 'id', id)
            const localVarPath = `/RingGroups({Id})/Members`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {PbxRingGroup} pbxRingGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRingGroup: async (id: number, pbxRingGroup: PbxRingGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRingGroup', 'id', id)
            // verify required parameter 'pbxRingGroup' is not null or undefined
            assertParamExists('updateRingGroup', 'pbxRingGroup', pbxRingGroup)
            const localVarPath = `/RingGroups({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxRingGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RingGroupsApi - functional programming interface
 * @export
 */
export const RingGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RingGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to RingGroups
         * @param {PbxRingGroup} pbxRingGroup New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRingGroup(pbxRingGroup: PbxRingGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRingGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRingGroup(pbxRingGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.createRingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRingGroup(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRingGroup(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.deleteRingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableRingGroupNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableRingGroupNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableRingGroupNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.getFirstAvailableRingGroupNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from RingGroups by key
         * @param {number} id The unique identifier of RingGroup
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRingGroup(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRingGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRingGroup(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.getRingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRingGroupByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRingGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRingGroupByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.getRingGroupByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from RingGroups
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRingGroup($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRingGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRingGroup($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.listRingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Members from RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRingGroupMembers(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRingGroupMemberCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRingGroupMembers(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.listRingGroupMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in RingGroups
         * @param {number} id The unique identifier of RingGroup
         * @param {PbxRingGroup} pbxRingGroup New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRingGroup(id: number, pbxRingGroup: PbxRingGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRingGroup(id, pbxRingGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RingGroupsApi.updateRingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RingGroupsApi - factory interface
 * @export
 */
export const RingGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RingGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to RingGroups
         * @param {RingGroupsApiCreateRingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRingGroup(requestParameters: RingGroupsApiCreateRingGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRingGroup> {
            return localVarFp.createRingGroup(requestParameters.pbxRingGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from RingGroups
         * @param {RingGroupsApiDeleteRingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRingGroup(requestParameters: RingGroupsApiDeleteRingGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRingGroup(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableRingGroupNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableRingGroupNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableRingGroupNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from RingGroups by key
         * @param {RingGroupsApiGetRingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroup(requestParameters: RingGroupsApiGetRingGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRingGroup> {
            return localVarFp.getRingGroup(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {RingGroupsApiGetRingGroupByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRingGroupByNumber(requestParameters: RingGroupsApiGetRingGroupByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRingGroup> {
            return localVarFp.getRingGroupByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from RingGroups
         * @param {RingGroupsApiListRingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRingGroup(requestParameters: RingGroupsApiListRingGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRingGroupCollectionResponse> {
            return localVarFp.listRingGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Members from RingGroups
         * @param {RingGroupsApiListRingGroupMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRingGroupMembers(requestParameters: RingGroupsApiListRingGroupMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxRingGroupMemberCollectionResponse> {
            return localVarFp.listRingGroupMembers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in RingGroups
         * @param {RingGroupsApiUpdateRingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRingGroup(requestParameters: RingGroupsApiUpdateRingGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRingGroup(requestParameters.id, requestParameters.pbxRingGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRingGroup operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiCreateRingGroupRequest
 */
export interface RingGroupsApiCreateRingGroupRequest {
    /**
     * New entity
     * @type {PbxRingGroup}
     * @memberof RingGroupsApiCreateRingGroup
     */
    readonly pbxRingGroup: PbxRingGroup
}

/**
 * Request parameters for deleteRingGroup operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiDeleteRingGroupRequest
 */
export interface RingGroupsApiDeleteRingGroupRequest {
    /**
     * The unique identifier of RingGroup
     * @type {number}
     * @memberof RingGroupsApiDeleteRingGroup
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof RingGroupsApiDeleteRingGroup
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getRingGroup operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiGetRingGroupRequest
 */
export interface RingGroupsApiGetRingGroupRequest {
    /**
     * The unique identifier of RingGroup
     * @type {number}
     * @memberof RingGroupsApiGetRingGroup
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof RingGroupsApiGetRingGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof RingGroupsApiGetRingGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getRingGroupByNumber operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiGetRingGroupByNumberRequest
 */
export interface RingGroupsApiGetRingGroupByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof RingGroupsApiGetRingGroupByNumber
     */
    readonly number: string
}

/**
 * Request parameters for listRingGroup operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiListRingGroupRequest
 */
export interface RingGroupsApiListRingGroupRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroup
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listRingGroupMembers operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiListRingGroupMembersRequest
 */
export interface RingGroupsApiListRingGroupMembersRequest {
    /**
     * The unique identifier of RingGroup
     * @type {number}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof RingGroupsApiListRingGroupMembers
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateRingGroup operation in RingGroupsApi.
 * @export
 * @interface RingGroupsApiUpdateRingGroupRequest
 */
export interface RingGroupsApiUpdateRingGroupRequest {
    /**
     * The unique identifier of RingGroup
     * @type {number}
     * @memberof RingGroupsApiUpdateRingGroup
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxRingGroup}
     * @memberof RingGroupsApiUpdateRingGroup
     */
    readonly pbxRingGroup: PbxRingGroup
}

/**
 * RingGroupsApi - object-oriented interface
 * @export
 * @class RingGroupsApi
 * @extends {BaseAPI}
 */
export class RingGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to RingGroups
     * @param {RingGroupsApiCreateRingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public createRingGroup(requestParameters: RingGroupsApiCreateRingGroupRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).createRingGroup(requestParameters.pbxRingGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from RingGroups
     * @param {RingGroupsApiDeleteRingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public deleteRingGroup(requestParameters: RingGroupsApiDeleteRingGroupRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).deleteRingGroup(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableRingGroupNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public getFirstAvailableRingGroupNumber(options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).getFirstAvailableRingGroupNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from RingGroups by key
     * @param {RingGroupsApiGetRingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public getRingGroup(requestParameters: RingGroupsApiGetRingGroupRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).getRingGroup(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {RingGroupsApiGetRingGroupByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public getRingGroupByNumber(requestParameters: RingGroupsApiGetRingGroupByNumberRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).getRingGroupByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from RingGroups
     * @param {RingGroupsApiListRingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public listRingGroup(requestParameters: RingGroupsApiListRingGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).listRingGroup(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Members from RingGroups
     * @param {RingGroupsApiListRingGroupMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public listRingGroupMembers(requestParameters: RingGroupsApiListRingGroupMembersRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).listRingGroupMembers(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in RingGroups
     * @param {RingGroupsApiUpdateRingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RingGroupsApi
     */
    public updateRingGroup(requestParameters: RingGroupsApiUpdateRingGroupRequest, options?: RawAxiosRequestConfig) {
        return RingGroupsApiFp(this.configuration).updateRingGroup(requestParameters.id, requestParameters.pbxRingGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SbcsApi - axios parameter creator
 * @export
 */
export const SbcsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Sbcs
         * @param {PbxSbc} pbxSbc New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSbc: async (pbxSbc: PbxSbc, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxSbc' is not null or undefined
            assertParamExists('createSbc', 'pbxSbc', pbxSbc)
            const localVarPath = `/Sbcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxSbc, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Sbcs
         * @param {string} name The unique identifier of Sbc
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSbc: async (name: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteSbc', 'name', name)
            const localVarPath = `/Sbcs({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Sbcs by key
         * @param {string} name The unique identifier of Sbc
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSbc: async (name: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getSbc', 'name', name)
            const localVarPath = `/Sbcs({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Sbcs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSbc: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sbcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Sbcs
         * @param {string} name The unique identifier of Sbc
         * @param {PbxSbc} pbxSbc New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSbc: async (name: string, pbxSbc: PbxSbc, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateSbc', 'name', name)
            // verify required parameter 'pbxSbc' is not null or undefined
            assertParamExists('updateSbc', 'pbxSbc', pbxSbc)
            const localVarPath = `/Sbcs({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxSbc, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SbcsApi - functional programming interface
 * @export
 */
export const SbcsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SbcsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Sbcs
         * @param {PbxSbc} pbxSbc New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSbc(pbxSbc: PbxSbc, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSbc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSbc(pbxSbc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SbcsApi.createSbc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Sbcs
         * @param {string} name The unique identifier of Sbc
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSbc(name: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSbc(name, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SbcsApi.deleteSbc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Sbcs by key
         * @param {string} name The unique identifier of Sbc
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSbc(name: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSbc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSbc(name, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SbcsApi.getSbc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Sbcs
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSbc($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSbcCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSbc($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SbcsApi.listSbc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Sbcs
         * @param {string} name The unique identifier of Sbc
         * @param {PbxSbc} pbxSbc New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSbc(name: string, pbxSbc: PbxSbc, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSbc(name, pbxSbc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SbcsApi.updateSbc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SbcsApi - factory interface
 * @export
 */
export const SbcsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SbcsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Sbcs
         * @param {SbcsApiCreateSbcRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSbc(requestParameters: SbcsApiCreateSbcRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxSbc> {
            return localVarFp.createSbc(requestParameters.pbxSbc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Sbcs
         * @param {SbcsApiDeleteSbcRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSbc(requestParameters: SbcsApiDeleteSbcRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSbc(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Sbcs by key
         * @param {SbcsApiGetSbcRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSbc(requestParameters: SbcsApiGetSbcRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxSbc> {
            return localVarFp.getSbc(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Sbcs
         * @param {SbcsApiListSbcRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSbc(requestParameters: SbcsApiListSbcRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxSbcCollectionResponse> {
            return localVarFp.listSbc(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Sbcs
         * @param {SbcsApiUpdateSbcRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSbc(requestParameters: SbcsApiUpdateSbcRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSbc(requestParameters.name, requestParameters.pbxSbc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSbc operation in SbcsApi.
 * @export
 * @interface SbcsApiCreateSbcRequest
 */
export interface SbcsApiCreateSbcRequest {
    /**
     * New entity
     * @type {PbxSbc}
     * @memberof SbcsApiCreateSbc
     */
    readonly pbxSbc: PbxSbc
}

/**
 * Request parameters for deleteSbc operation in SbcsApi.
 * @export
 * @interface SbcsApiDeleteSbcRequest
 */
export interface SbcsApiDeleteSbcRequest {
    /**
     * The unique identifier of Sbc
     * @type {string}
     * @memberof SbcsApiDeleteSbc
     */
    readonly name: string

    /**
     * ETag
     * @type {string}
     * @memberof SbcsApiDeleteSbc
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getSbc operation in SbcsApi.
 * @export
 * @interface SbcsApiGetSbcRequest
 */
export interface SbcsApiGetSbcRequest {
    /**
     * The unique identifier of Sbc
     * @type {string}
     * @memberof SbcsApiGetSbc
     */
    readonly name: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SbcsApiGetSbc
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SbcsApiGetSbc
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listSbc operation in SbcsApi.
 * @export
 * @interface SbcsApiListSbcRequest
 */
export interface SbcsApiListSbcRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof SbcsApiListSbc
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof SbcsApiListSbc
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof SbcsApiListSbc
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof SbcsApiListSbc
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof SbcsApiListSbc
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof SbcsApiListSbc
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SbcsApiListSbc
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SbcsApiListSbc
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateSbc operation in SbcsApi.
 * @export
 * @interface SbcsApiUpdateSbcRequest
 */
export interface SbcsApiUpdateSbcRequest {
    /**
     * The unique identifier of Sbc
     * @type {string}
     * @memberof SbcsApiUpdateSbc
     */
    readonly name: string

    /**
     * New property values
     * @type {PbxSbc}
     * @memberof SbcsApiUpdateSbc
     */
    readonly pbxSbc: PbxSbc
}

/**
 * SbcsApi - object-oriented interface
 * @export
 * @class SbcsApi
 * @extends {BaseAPI}
 */
export class SbcsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Sbcs
     * @param {SbcsApiCreateSbcRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SbcsApi
     */
    public createSbc(requestParameters: SbcsApiCreateSbcRequest, options?: RawAxiosRequestConfig) {
        return SbcsApiFp(this.configuration).createSbc(requestParameters.pbxSbc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Sbcs
     * @param {SbcsApiDeleteSbcRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SbcsApi
     */
    public deleteSbc(requestParameters: SbcsApiDeleteSbcRequest, options?: RawAxiosRequestConfig) {
        return SbcsApiFp(this.configuration).deleteSbc(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Sbcs by key
     * @param {SbcsApiGetSbcRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SbcsApi
     */
    public getSbc(requestParameters: SbcsApiGetSbcRequest, options?: RawAxiosRequestConfig) {
        return SbcsApiFp(this.configuration).getSbc(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Sbcs
     * @param {SbcsApiListSbcRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SbcsApi
     */
    public listSbc(requestParameters: SbcsApiListSbcRequest = {}, options?: RawAxiosRequestConfig) {
        return SbcsApiFp(this.configuration).listSbc(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Sbcs
     * @param {SbcsApiUpdateSbcRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SbcsApi
     */
    public updateSbc(requestParameters: SbcsApiUpdateSbcRequest, options?: RawAxiosRequestConfig) {
        return SbcsApiFp(this.configuration).updateSbc(requestParameters.name, requestParameters.pbxSbc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduledReportsApi - axios parameter creator
 * @export
 */
export const ScheduledReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to ScheduledReports
         * @param {PbxScheduledReport} pbxScheduledReport New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledReport: async (pbxScheduledReport: PbxScheduledReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxScheduledReport' is not null or undefined
            assertParamExists('createScheduledReport', 'pbxScheduledReport', pbxScheduledReport)
            const localVarPath = `/ScheduledReports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxScheduledReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from ScheduledReports
         * @param {number} id The unique identifier of ScheduledReport
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledReport: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduledReport', 'id', id)
            const localVarPath = `/ScheduledReports({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from ScheduledReports by key
         * @param {number} id The unique identifier of ScheduledReport
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledReport: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduledReport', 'id', id)
            const localVarPath = `/ScheduledReports({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from ScheduledReports
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledReport: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ScheduledReports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in ScheduledReports
         * @param {number} id The unique identifier of ScheduledReport
         * @param {PbxScheduledReport} pbxScheduledReport New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledReport: async (id: number, pbxScheduledReport: PbxScheduledReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScheduledReport', 'id', id)
            // verify required parameter 'pbxScheduledReport' is not null or undefined
            assertParamExists('updateScheduledReport', 'pbxScheduledReport', pbxScheduledReport)
            const localVarPath = `/ScheduledReports({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxScheduledReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledReportsApi - functional programming interface
 * @export
 */
export const ScheduledReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to ScheduledReports
         * @param {PbxScheduledReport} pbxScheduledReport New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduledReport(pbxScheduledReport: PbxScheduledReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxScheduledReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledReport(pbxScheduledReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledReportsApi.createScheduledReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from ScheduledReports
         * @param {number} id The unique identifier of ScheduledReport
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledReport(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledReport(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledReportsApi.deleteScheduledReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from ScheduledReports by key
         * @param {number} id The unique identifier of ScheduledReport
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduledReport(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxScheduledReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledReport(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledReportsApi.getScheduledReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from ScheduledReports
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledReport($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxScheduledReportCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledReport($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledReportsApi.listScheduledReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in ScheduledReports
         * @param {number} id The unique identifier of ScheduledReport
         * @param {PbxScheduledReport} pbxScheduledReport New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduledReport(id: number, pbxScheduledReport: PbxScheduledReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduledReport(id, pbxScheduledReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduledReportsApi.updateScheduledReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduledReportsApi - factory interface
 * @export
 */
export const ScheduledReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to ScheduledReports
         * @param {ScheduledReportsApiCreateScheduledReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledReport(requestParameters: ScheduledReportsApiCreateScheduledReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxScheduledReport> {
            return localVarFp.createScheduledReport(requestParameters.pbxScheduledReport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from ScheduledReports
         * @param {ScheduledReportsApiDeleteScheduledReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledReport(requestParameters: ScheduledReportsApiDeleteScheduledReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteScheduledReport(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from ScheduledReports by key
         * @param {ScheduledReportsApiGetScheduledReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledReport(requestParameters: ScheduledReportsApiGetScheduledReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxScheduledReport> {
            return localVarFp.getScheduledReport(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from ScheduledReports
         * @param {ScheduledReportsApiListScheduledReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledReport(requestParameters: ScheduledReportsApiListScheduledReportRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxScheduledReportCollectionResponse> {
            return localVarFp.listScheduledReport(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in ScheduledReports
         * @param {ScheduledReportsApiUpdateScheduledReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledReport(requestParameters: ScheduledReportsApiUpdateScheduledReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateScheduledReport(requestParameters.id, requestParameters.pbxScheduledReport, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createScheduledReport operation in ScheduledReportsApi.
 * @export
 * @interface ScheduledReportsApiCreateScheduledReportRequest
 */
export interface ScheduledReportsApiCreateScheduledReportRequest {
    /**
     * New entity
     * @type {PbxScheduledReport}
     * @memberof ScheduledReportsApiCreateScheduledReport
     */
    readonly pbxScheduledReport: PbxScheduledReport
}

/**
 * Request parameters for deleteScheduledReport operation in ScheduledReportsApi.
 * @export
 * @interface ScheduledReportsApiDeleteScheduledReportRequest
 */
export interface ScheduledReportsApiDeleteScheduledReportRequest {
    /**
     * The unique identifier of ScheduledReport
     * @type {number}
     * @memberof ScheduledReportsApiDeleteScheduledReport
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ScheduledReportsApiDeleteScheduledReport
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getScheduledReport operation in ScheduledReportsApi.
 * @export
 * @interface ScheduledReportsApiGetScheduledReportRequest
 */
export interface ScheduledReportsApiGetScheduledReportRequest {
    /**
     * The unique identifier of ScheduledReport
     * @type {number}
     * @memberof ScheduledReportsApiGetScheduledReport
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ScheduledReportsApiGetScheduledReport
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ScheduledReportsApiGetScheduledReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listScheduledReport operation in ScheduledReportsApi.
 * @export
 * @interface ScheduledReportsApiListScheduledReportRequest
 */
export interface ScheduledReportsApiListScheduledReportRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ScheduledReportsApiListScheduledReport
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateScheduledReport operation in ScheduledReportsApi.
 * @export
 * @interface ScheduledReportsApiUpdateScheduledReportRequest
 */
export interface ScheduledReportsApiUpdateScheduledReportRequest {
    /**
     * The unique identifier of ScheduledReport
     * @type {number}
     * @memberof ScheduledReportsApiUpdateScheduledReport
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxScheduledReport}
     * @memberof ScheduledReportsApiUpdateScheduledReport
     */
    readonly pbxScheduledReport: PbxScheduledReport
}

/**
 * ScheduledReportsApi - object-oriented interface
 * @export
 * @class ScheduledReportsApi
 * @extends {BaseAPI}
 */
export class ScheduledReportsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to ScheduledReports
     * @param {ScheduledReportsApiCreateScheduledReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledReportsApi
     */
    public createScheduledReport(requestParameters: ScheduledReportsApiCreateScheduledReportRequest, options?: RawAxiosRequestConfig) {
        return ScheduledReportsApiFp(this.configuration).createScheduledReport(requestParameters.pbxScheduledReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from ScheduledReports
     * @param {ScheduledReportsApiDeleteScheduledReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledReportsApi
     */
    public deleteScheduledReport(requestParameters: ScheduledReportsApiDeleteScheduledReportRequest, options?: RawAxiosRequestConfig) {
        return ScheduledReportsApiFp(this.configuration).deleteScheduledReport(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from ScheduledReports by key
     * @param {ScheduledReportsApiGetScheduledReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledReportsApi
     */
    public getScheduledReport(requestParameters: ScheduledReportsApiGetScheduledReportRequest, options?: RawAxiosRequestConfig) {
        return ScheduledReportsApiFp(this.configuration).getScheduledReport(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from ScheduledReports
     * @param {ScheduledReportsApiListScheduledReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledReportsApi
     */
    public listScheduledReport(requestParameters: ScheduledReportsApiListScheduledReportRequest = {}, options?: RawAxiosRequestConfig) {
        return ScheduledReportsApiFp(this.configuration).listScheduledReport(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in ScheduledReports
     * @param {ScheduledReportsApiUpdateScheduledReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledReportsApi
     */
    public updateScheduledReport(requestParameters: ScheduledReportsApiUpdateScheduledReportRequest, options?: RawAxiosRequestConfig) {
        return ScheduledReportsApiFp(this.configuration).updateScheduledReport(requestParameters.id, requestParameters.pbxScheduledReport, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecureSipSettingsApi - axios parameter creator
 * @export
 */
export const SecureSipSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get SecureSipSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecureSipSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SecureSipSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update SecureSipSettings
         * @param {PbxSecureSipSettings} pbxSecureSipSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecureSipSettings: async (pbxSecureSipSettings: PbxSecureSipSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxSecureSipSettings' is not null or undefined
            assertParamExists('updateSecureSipSettings', 'pbxSecureSipSettings', pbxSecureSipSettings)
            const localVarPath = `/SecureSipSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxSecureSipSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecureSipSettingsApi - functional programming interface
 * @export
 */
export const SecureSipSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecureSipSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get SecureSipSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecureSipSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSecureSipSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecureSipSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecureSipSettingsApi.getSecureSipSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update SecureSipSettings
         * @param {PbxSecureSipSettings} pbxSecureSipSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecureSipSettings(pbxSecureSipSettings: PbxSecureSipSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecureSipSettings(pbxSecureSipSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecureSipSettingsApi.updateSecureSipSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecureSipSettingsApi - factory interface
 * @export
 */
export const SecureSipSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecureSipSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get SecureSipSettings
         * @param {SecureSipSettingsApiGetSecureSipSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecureSipSettings(requestParameters: SecureSipSettingsApiGetSecureSipSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxSecureSipSettings> {
            return localVarFp.getSecureSipSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update SecureSipSettings
         * @param {SecureSipSettingsApiUpdateSecureSipSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecureSipSettings(requestParameters: SecureSipSettingsApiUpdateSecureSipSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSecureSipSettings(requestParameters.pbxSecureSipSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSecureSipSettings operation in SecureSipSettingsApi.
 * @export
 * @interface SecureSipSettingsApiGetSecureSipSettingsRequest
 */
export interface SecureSipSettingsApiGetSecureSipSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SecureSipSettingsApiGetSecureSipSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SecureSipSettingsApiGetSecureSipSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateSecureSipSettings operation in SecureSipSettingsApi.
 * @export
 * @interface SecureSipSettingsApiUpdateSecureSipSettingsRequest
 */
export interface SecureSipSettingsApiUpdateSecureSipSettingsRequest {
    /**
     * New property values
     * @type {PbxSecureSipSettings}
     * @memberof SecureSipSettingsApiUpdateSecureSipSettings
     */
    readonly pbxSecureSipSettings: PbxSecureSipSettings
}

/**
 * SecureSipSettingsApi - object-oriented interface
 * @export
 * @class SecureSipSettingsApi
 * @extends {BaseAPI}
 */
export class SecureSipSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get SecureSipSettings
     * @param {SecureSipSettingsApiGetSecureSipSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureSipSettingsApi
     */
    public getSecureSipSettings(requestParameters: SecureSipSettingsApiGetSecureSipSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return SecureSipSettingsApiFp(this.configuration).getSecureSipSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update SecureSipSettings
     * @param {SecureSipSettingsApiUpdateSecureSipSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureSipSettingsApi
     */
    public updateSecureSipSettings(requestParameters: SecureSipSettingsApiUpdateSecureSipSettingsRequest, options?: RawAxiosRequestConfig) {
        return SecureSipSettingsApiFp(this.configuration).updateSecureSipSettings(requestParameters.pbxSecureSipSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityTokensApi - axios parameter creator
 * @export
 */
export const SecurityTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from SecurityTokens
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityRefreshToken: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SecurityTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {number} id The unique identifier of RefreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSecurityToken: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokeSecurityToken', 'id', id)
            const localVarPath = `/SecurityTokens({Id})/Pbx.RevokeToken`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityTokensApi - functional programming interface
 * @export
 */
export const SecurityTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from SecurityTokens
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSecurityRefreshToken($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxRefreshTokenCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSecurityRefreshToken($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityTokensApi.listSecurityRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {number} id The unique identifier of RefreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSecurityToken(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSecurityToken(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityTokensApi.revokeSecurityToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityTokensApi - factory interface
 * @export
 */
export const SecurityTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityTokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from SecurityTokens
         * @param {SecurityTokensApiListSecurityRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityRefreshToken(requestParameters: SecurityTokensApiListSecurityRefreshTokenRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxRefreshTokenCollectionResponse> {
            return localVarFp.listSecurityRefreshToken(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RevokeToken
         * @param {SecurityTokensApiRevokeSecurityTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSecurityToken(requestParameters: SecurityTokensApiRevokeSecurityTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeSecurityToken(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listSecurityRefreshToken operation in SecurityTokensApi.
 * @export
 * @interface SecurityTokensApiListSecurityRefreshTokenRequest
 */
export interface SecurityTokensApiListSecurityRefreshTokenRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SecurityTokensApiListSecurityRefreshToken
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for revokeSecurityToken operation in SecurityTokensApi.
 * @export
 * @interface SecurityTokensApiRevokeSecurityTokenRequest
 */
export interface SecurityTokensApiRevokeSecurityTokenRequest {
    /**
     * The unique identifier of RefreshToken
     * @type {number}
     * @memberof SecurityTokensApiRevokeSecurityToken
     */
    readonly id: number
}

/**
 * SecurityTokensApi - object-oriented interface
 * @export
 * @class SecurityTokensApi
 * @extends {BaseAPI}
 */
export class SecurityTokensApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from SecurityTokens
     * @param {SecurityTokensApiListSecurityRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityTokensApi
     */
    public listSecurityRefreshToken(requestParameters: SecurityTokensApiListSecurityRefreshTokenRequest = {}, options?: RawAxiosRequestConfig) {
        return SecurityTokensApiFp(this.configuration).listSecurityRefreshToken(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RevokeToken
     * @param {SecurityTokensApiRevokeSecurityTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityTokensApi
     */
    public revokeSecurityToken(requestParameters: SecurityTokensApiRevokeSecurityTokenRequest, options?: RawAxiosRequestConfig) {
        return SecurityTokensApiFp(this.configuration).revokeSecurityToken(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicePrincipalsApi - axios parameter creator
 * @export
 */
export const ServicePrincipalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to ServicePrincipals
         * @param {PbxServicePrincipal} pbxServicePrincipal New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePrincipal: async (pbxServicePrincipal: PbxServicePrincipal, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxServicePrincipal' is not null or undefined
            assertParamExists('createServicePrincipal', 'pbxServicePrincipal', pbxServicePrincipal)
            const localVarPath = `/ServicePrincipals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxServicePrincipal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from ServicePrincipals
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServicePrincipal: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServicePrincipal', 'id', id)
            const localVarPath = `/ServicePrincipals({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GenerateAppToken
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAppToken: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generateAppToken', 'id', id)
            const localVarPath = `/ServicePrincipals({Id})/Pbx.GenerateAppToken`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from ServicePrincipals by key
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicePrincipal: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServicePrincipal', 'id', id)
            const localVarPath = `/ServicePrincipals({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from ServicePrincipals
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePrincipal: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ServicePrincipals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in ServicePrincipals
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {PbxServicePrincipal} pbxServicePrincipal New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServicePrincipal: async (id: number, pbxServicePrincipal: PbxServicePrincipal, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServicePrincipal', 'id', id)
            // verify required parameter 'pbxServicePrincipal' is not null or undefined
            assertParamExists('updateServicePrincipal', 'pbxServicePrincipal', pbxServicePrincipal)
            const localVarPath = `/ServicePrincipals({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxServicePrincipal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicePrincipalsApi - functional programming interface
 * @export
 */
export const ServicePrincipalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicePrincipalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to ServicePrincipals
         * @param {PbxServicePrincipal} pbxServicePrincipal New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServicePrincipal(pbxServicePrincipal: PbxServicePrincipal, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxServicePrincipal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServicePrincipal(pbxServicePrincipal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.createServicePrincipal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from ServicePrincipals
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServicePrincipal(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServicePrincipal(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.deleteServicePrincipal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GenerateAppToken
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAppToken(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAppToken(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.generateAppToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from ServicePrincipals by key
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServicePrincipal(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxServicePrincipal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServicePrincipal(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.getServicePrincipal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from ServicePrincipals
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicePrincipal($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxServicePrincipalCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServicePrincipal($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.listServicePrincipal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in ServicePrincipals
         * @param {number} id The unique identifier of ServicePrincipal
         * @param {PbxServicePrincipal} pbxServicePrincipal New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServicePrincipal(id: number, pbxServicePrincipal: PbxServicePrincipal, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServicePrincipal(id, pbxServicePrincipal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.updateServicePrincipal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicePrincipalsApi - factory interface
 * @export
 */
export const ServicePrincipalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicePrincipalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to ServicePrincipals
         * @param {ServicePrincipalsApiCreateServicePrincipalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePrincipal(requestParameters: ServicePrincipalsApiCreateServicePrincipalRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxServicePrincipal> {
            return localVarFp.createServicePrincipal(requestParameters.pbxServicePrincipal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from ServicePrincipals
         * @param {ServicePrincipalsApiDeleteServicePrincipalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServicePrincipal(requestParameters: ServicePrincipalsApiDeleteServicePrincipalRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServicePrincipal(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GenerateAppToken
         * @param {ServicePrincipalsApiGenerateAppTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAppToken(requestParameters: ServicePrincipalsApiGenerateAppTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.generateAppToken(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from ServicePrincipals by key
         * @param {ServicePrincipalsApiGetServicePrincipalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicePrincipal(requestParameters: ServicePrincipalsApiGetServicePrincipalRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxServicePrincipal> {
            return localVarFp.getServicePrincipal(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from ServicePrincipals
         * @param {ServicePrincipalsApiListServicePrincipalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePrincipal(requestParameters: ServicePrincipalsApiListServicePrincipalRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxServicePrincipalCollectionResponse> {
            return localVarFp.listServicePrincipal(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in ServicePrincipals
         * @param {ServicePrincipalsApiUpdateServicePrincipalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServicePrincipal(requestParameters: ServicePrincipalsApiUpdateServicePrincipalRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateServicePrincipal(requestParameters.id, requestParameters.pbxServicePrincipal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServicePrincipal operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiCreateServicePrincipalRequest
 */
export interface ServicePrincipalsApiCreateServicePrincipalRequest {
    /**
     * New entity
     * @type {PbxServicePrincipal}
     * @memberof ServicePrincipalsApiCreateServicePrincipal
     */
    readonly pbxServicePrincipal: PbxServicePrincipal
}

/**
 * Request parameters for deleteServicePrincipal operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiDeleteServicePrincipalRequest
 */
export interface ServicePrincipalsApiDeleteServicePrincipalRequest {
    /**
     * The unique identifier of ServicePrincipal
     * @type {number}
     * @memberof ServicePrincipalsApiDeleteServicePrincipal
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof ServicePrincipalsApiDeleteServicePrincipal
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for generateAppToken operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiGenerateAppTokenRequest
 */
export interface ServicePrincipalsApiGenerateAppTokenRequest {
    /**
     * The unique identifier of ServicePrincipal
     * @type {number}
     * @memberof ServicePrincipalsApiGenerateAppToken
     */
    readonly id: number
}

/**
 * Request parameters for getServicePrincipal operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiGetServicePrincipalRequest
 */
export interface ServicePrincipalsApiGetServicePrincipalRequest {
    /**
     * The unique identifier of ServicePrincipal
     * @type {number}
     * @memberof ServicePrincipalsApiGetServicePrincipal
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ServicePrincipalsApiGetServicePrincipal
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ServicePrincipalsApiGetServicePrincipal
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listServicePrincipal operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiListServicePrincipalRequest
 */
export interface ServicePrincipalsApiListServicePrincipalRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ServicePrincipalsApiListServicePrincipal
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateServicePrincipal operation in ServicePrincipalsApi.
 * @export
 * @interface ServicePrincipalsApiUpdateServicePrincipalRequest
 */
export interface ServicePrincipalsApiUpdateServicePrincipalRequest {
    /**
     * The unique identifier of ServicePrincipal
     * @type {number}
     * @memberof ServicePrincipalsApiUpdateServicePrincipal
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxServicePrincipal}
     * @memberof ServicePrincipalsApiUpdateServicePrincipal
     */
    readonly pbxServicePrincipal: PbxServicePrincipal
}

/**
 * ServicePrincipalsApi - object-oriented interface
 * @export
 * @class ServicePrincipalsApi
 * @extends {BaseAPI}
 */
export class ServicePrincipalsApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to ServicePrincipals
     * @param {ServicePrincipalsApiCreateServicePrincipalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public createServicePrincipal(requestParameters: ServicePrincipalsApiCreateServicePrincipalRequest, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).createServicePrincipal(requestParameters.pbxServicePrincipal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from ServicePrincipals
     * @param {ServicePrincipalsApiDeleteServicePrincipalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public deleteServicePrincipal(requestParameters: ServicePrincipalsApiDeleteServicePrincipalRequest, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).deleteServicePrincipal(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GenerateAppToken
     * @param {ServicePrincipalsApiGenerateAppTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public generateAppToken(requestParameters: ServicePrincipalsApiGenerateAppTokenRequest, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).generateAppToken(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from ServicePrincipals by key
     * @param {ServicePrincipalsApiGetServicePrincipalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public getServicePrincipal(requestParameters: ServicePrincipalsApiGetServicePrincipalRequest, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).getServicePrincipal(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from ServicePrincipals
     * @param {ServicePrincipalsApiListServicePrincipalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public listServicePrincipal(requestParameters: ServicePrincipalsApiListServicePrincipalRequest = {}, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).listServicePrincipal(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in ServicePrincipals
     * @param {ServicePrincipalsApiUpdateServicePrincipalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePrincipalsApi
     */
    public updateServicePrincipal(requestParameters: ServicePrincipalsApiUpdateServicePrincipalRequest, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).updateServicePrincipal(requestParameters.id, requestParameters.pbxServicePrincipal, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action Disable
         * @param {ServicesDisableRequestBody} servicesDisableRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable: async (servicesDisableRequestBody: ServicesDisableRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesDisableRequestBody' is not null or undefined
            assertParamExists('disable', 'servicesDisableRequestBody', servicesDisableRequestBody)
            const localVarPath = `/Services/Pbx.Disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesDisableRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Enable
         * @param {ServicesEnableRequestBody} servicesEnableRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable: async (servicesEnableRequestBody: ServicesEnableRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesEnableRequestBody' is not null or undefined
            assertParamExists('enable', 'servicesEnableRequestBody', servicesEnableRequestBody)
            const localVarPath = `/Services/Pbx.Enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesEnableRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GarbageCollect
         * @param {ServicesGarbageCollectRequestBody} servicesGarbageCollectRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        garbageCollect: async (servicesGarbageCollectRequestBody: ServicesGarbageCollectRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesGarbageCollectRequestBody' is not null or undefined
            assertParamExists('garbageCollect', 'servicesGarbageCollectRequestBody', servicesGarbageCollectRequestBody)
            const localVarPath = `/Services/Pbx.GarbageCollect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesGarbageCollectRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Services
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInfo: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Restart
         * @param {ServicesRestartRequestBody} servicesRestartRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restart: async (servicesRestartRequestBody: ServicesRestartRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesRestartRequestBody' is not null or undefined
            assertParamExists('restart', 'servicesRestartRequestBody', servicesRestartRequestBody)
            const localVarPath = `/Services/Pbx.Restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesRestartRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RestartAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Services/Pbx.RestartAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RestartOperatingSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperatingSystem: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Services/Pbx.RestartOperatingSystem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Start
         * @param {ServicesStartRequestBody} servicesStartRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: async (servicesStartRequestBody: ServicesStartRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesStartRequestBody' is not null or undefined
            assertParamExists('start', 'servicesStartRequestBody', servicesStartRequestBody)
            const localVarPath = `/Services/Pbx.Start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesStartRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Stop
         * @param {ServicesStopRequestBody} servicesStopRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop: async (servicesStopRequestBody: ServicesStopRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'servicesStopRequestBody' is not null or undefined
            assertParamExists('stop', 'servicesStopRequestBody', servicesStopRequestBody)
            const localVarPath = `/Services/Pbx.Stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(servicesStopRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action Disable
         * @param {ServicesDisableRequestBody} servicesDisableRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disable(servicesDisableRequestBody: ServicesDisableRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disable(servicesDisableRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.disable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Enable
         * @param {ServicesEnableRequestBody} servicesEnableRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enable(servicesEnableRequestBody: ServicesEnableRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enable(servicesEnableRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.enable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GarbageCollect
         * @param {ServicesGarbageCollectRequestBody} servicesGarbageCollectRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async garbageCollect(servicesGarbageCollectRequestBody: ServicesGarbageCollectRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.garbageCollect(servicesGarbageCollectRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.garbageCollect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Services
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInfo($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxServiceInfoCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServiceInfo($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.listServiceInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Restart
         * @param {ServicesRestartRequestBody} servicesRestartRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restart(servicesRestartRequestBody: ServicesRestartRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restart(servicesRestartRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.restart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RestartAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.restartAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RestartOperatingSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartOperatingSystem(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartOperatingSystem(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.restartOperatingSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Start
         * @param {ServicesStartRequestBody} servicesStartRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async start(servicesStartRequestBody: ServicesStartRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.start(servicesStartRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.start']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Stop
         * @param {ServicesStopRequestBody} servicesStopRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stop(servicesStopRequestBody: ServicesStopRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stop(servicesStopRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.stop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action Disable
         * @param {ServicesApiDisableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable(requestParameters: ServicesApiDisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disable(requestParameters.servicesDisableRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Enable
         * @param {ServicesApiEnableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable(requestParameters: ServicesApiEnableRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.enable(requestParameters.servicesEnableRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GarbageCollect
         * @param {ServicesApiGarbageCollectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        garbageCollect(requestParameters: ServicesApiGarbageCollectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.garbageCollect(requestParameters.servicesGarbageCollectRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Services
         * @param {ServicesApiListServiceInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInfo(requestParameters: ServicesApiListServiceInfoRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxServiceInfoCollectionResponse> {
            return localVarFp.listServiceInfo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Restart
         * @param {ServicesApiRestartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restart(requestParameters: ServicesApiRestartRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restart(requestParameters.servicesRestartRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RestartAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restartAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RestartOperatingSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperatingSystem(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restartOperatingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Start
         * @param {ServicesApiStartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(requestParameters: ServicesApiStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.start(requestParameters.servicesStartRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Stop
         * @param {ServicesApiStopRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(requestParameters: ServicesApiStopRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stop(requestParameters.servicesStopRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for disable operation in ServicesApi.
 * @export
 * @interface ServicesApiDisableRequest
 */
export interface ServicesApiDisableRequest {
    /**
     * Action parameters
     * @type {ServicesDisableRequestBody}
     * @memberof ServicesApiDisable
     */
    readonly servicesDisableRequestBody: ServicesDisableRequestBody
}

/**
 * Request parameters for enable operation in ServicesApi.
 * @export
 * @interface ServicesApiEnableRequest
 */
export interface ServicesApiEnableRequest {
    /**
     * Action parameters
     * @type {ServicesEnableRequestBody}
     * @memberof ServicesApiEnable
     */
    readonly servicesEnableRequestBody: ServicesEnableRequestBody
}

/**
 * Request parameters for garbageCollect operation in ServicesApi.
 * @export
 * @interface ServicesApiGarbageCollectRequest
 */
export interface ServicesApiGarbageCollectRequest {
    /**
     * Action parameters
     * @type {ServicesGarbageCollectRequestBody}
     * @memberof ServicesApiGarbageCollect
     */
    readonly servicesGarbageCollectRequestBody: ServicesGarbageCollectRequestBody
}

/**
 * Request parameters for listServiceInfo operation in ServicesApi.
 * @export
 * @interface ServicesApiListServiceInfoRequest
 */
export interface ServicesApiListServiceInfoRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof ServicesApiListServiceInfo
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for restart operation in ServicesApi.
 * @export
 * @interface ServicesApiRestartRequest
 */
export interface ServicesApiRestartRequest {
    /**
     * Action parameters
     * @type {ServicesRestartRequestBody}
     * @memberof ServicesApiRestart
     */
    readonly servicesRestartRequestBody: ServicesRestartRequestBody
}

/**
 * Request parameters for start operation in ServicesApi.
 * @export
 * @interface ServicesApiStartRequest
 */
export interface ServicesApiStartRequest {
    /**
     * Action parameters
     * @type {ServicesStartRequestBody}
     * @memberof ServicesApiStart
     */
    readonly servicesStartRequestBody: ServicesStartRequestBody
}

/**
 * Request parameters for stop operation in ServicesApi.
 * @export
 * @interface ServicesApiStopRequest
 */
export interface ServicesApiStopRequest {
    /**
     * Action parameters
     * @type {ServicesStopRequestBody}
     * @memberof ServicesApiStop
     */
    readonly servicesStopRequestBody: ServicesStopRequestBody
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action Disable
     * @param {ServicesApiDisableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public disable(requestParameters: ServicesApiDisableRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).disable(requestParameters.servicesDisableRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Enable
     * @param {ServicesApiEnableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public enable(requestParameters: ServicesApiEnableRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).enable(requestParameters.servicesEnableRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GarbageCollect
     * @param {ServicesApiGarbageCollectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public garbageCollect(requestParameters: ServicesApiGarbageCollectRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).garbageCollect(requestParameters.servicesGarbageCollectRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Services
     * @param {ServicesApiListServiceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public listServiceInfo(requestParameters: ServicesApiListServiceInfoRequest = {}, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).listServiceInfo(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Restart
     * @param {ServicesApiRestartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public restart(requestParameters: ServicesApiRestartRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).restart(requestParameters.servicesRestartRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RestartAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public restartAll(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).restartAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RestartOperatingSystem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public restartOperatingSystem(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).restartOperatingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Start
     * @param {ServicesApiStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public start(requestParameters: ServicesApiStartRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).start(requestParameters.servicesStartRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Stop
     * @param {ServicesApiStopRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public stop(requestParameters: ServicesApiStopRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).stop(requestParameters.servicesStopRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SipDevicesApi - axios parameter creator
 * @export
 */
export const SipDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get entities from SipDevices
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSipDevice: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SipDevices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action PushFirmware
         * @param {number} id The unique identifier of SipDevice
         * @param {SipDevicesSipDevicePushFirmwareRequestBody} sipDevicesSipDevicePushFirmwareRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushFirmware: async (id: number, sipDevicesSipDevicePushFirmwareRequestBody: SipDevicesSipDevicePushFirmwareRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pushFirmware', 'id', id)
            // verify required parameter 'sipDevicesSipDevicePushFirmwareRequestBody' is not null or undefined
            assertParamExists('pushFirmware', 'sipDevicesSipDevicePushFirmwareRequestBody', sipDevicesSipDevicePushFirmwareRequestBody)
            const localVarPath = `/SipDevices({Id})/Pbx.PushFirmware`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sipDevicesSipDevicePushFirmwareRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SipDevicesApi - functional programming interface
 * @export
 */
export const SipDevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SipDevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get entities from SipDevices
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSipDevice($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSipDeviceCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSipDevice($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SipDevicesApi.listSipDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action PushFirmware
         * @param {number} id The unique identifier of SipDevice
         * @param {SipDevicesSipDevicePushFirmwareRequestBody} sipDevicesSipDevicePushFirmwareRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushFirmware(id: number, sipDevicesSipDevicePushFirmwareRequestBody: SipDevicesSipDevicePushFirmwareRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushFirmware(id, sipDevicesSipDevicePushFirmwareRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SipDevicesApi.pushFirmware']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SipDevicesApi - factory interface
 * @export
 */
export const SipDevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SipDevicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get entities from SipDevices
         * @param {SipDevicesApiListSipDeviceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSipDevice(requestParameters: SipDevicesApiListSipDeviceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxSipDeviceCollectionResponse> {
            return localVarFp.listSipDevice(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action PushFirmware
         * @param {SipDevicesApiPushFirmwareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushFirmware(requestParameters: SipDevicesApiPushFirmwareRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pushFirmware(requestParameters.id, requestParameters.sipDevicesSipDevicePushFirmwareRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listSipDevice operation in SipDevicesApi.
 * @export
 * @interface SipDevicesApiListSipDeviceRequest
 */
export interface SipDevicesApiListSipDeviceRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SipDevicesApiListSipDevice
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for pushFirmware operation in SipDevicesApi.
 * @export
 * @interface SipDevicesApiPushFirmwareRequest
 */
export interface SipDevicesApiPushFirmwareRequest {
    /**
     * The unique identifier of SipDevice
     * @type {number}
     * @memberof SipDevicesApiPushFirmware
     */
    readonly id: number

    /**
     * Action parameters
     * @type {SipDevicesSipDevicePushFirmwareRequestBody}
     * @memberof SipDevicesApiPushFirmware
     */
    readonly sipDevicesSipDevicePushFirmwareRequestBody: SipDevicesSipDevicePushFirmwareRequestBody
}

/**
 * SipDevicesApi - object-oriented interface
 * @export
 * @class SipDevicesApi
 * @extends {BaseAPI}
 */
export class SipDevicesApi extends BaseAPI {
    /**
     * 
     * @summary Get entities from SipDevices
     * @param {SipDevicesApiListSipDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SipDevicesApi
     */
    public listSipDevice(requestParameters: SipDevicesApiListSipDeviceRequest = {}, options?: RawAxiosRequestConfig) {
        return SipDevicesApiFp(this.configuration).listSipDevice(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action PushFirmware
     * @param {SipDevicesApiPushFirmwareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SipDevicesApi
     */
    public pushFirmware(requestParameters: SipDevicesApiPushFirmwareRequest, options?: RawAxiosRequestConfig) {
        return SipDevicesApiFp(this.configuration).pushFirmware(requestParameters.id, requestParameters.sipDevicesSipDevicePushFirmwareRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemStatusApi - axios parameter creator
 * @export
 */
export const SystemStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke function APIToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aPIToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.APIToken()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetRequestHelpLink
         * @param {number} grantPeriodDays Usage: grantPeriodDays&#x3D;{grantPeriodDays}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestHelpLink: async (grantPeriodDays: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantPeriodDays' is not null or undefined
            assertParamExists('getRequestHelpLink', 'grantPeriodDays', grantPeriodDays)
            const localVarPath = `/SystemStatus/Pbx.GetRequestHelpLink(grantPeriodDays={grantPeriodDays})`
                .replace(`{${"grantPeriodDays"}}`, encodeURIComponent(String(grantPeriodDays)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SystemStatus
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemStatus: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetVersionType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.GetVersionType()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function IsRequestHelpEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRequestHelpEnabled: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.IsRequestHelpEnabled()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RequestHelp
         * @param {SystemStatusRequestHelpRequestBody} systemStatusRequestHelpRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestHelp: async (systemStatusRequestHelpRequestBody: SystemStatusRequestHelpRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemStatusRequestHelpRequestBody' is not null or undefined
            assertParamExists('requestHelp', 'systemStatusRequestHelpRequestBody', systemStatusRequestHelpRequestBody)
            const localVarPath = `/SystemStatus/Pbx.RequestHelp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemStatusRequestHelpRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetChatLogStatus
         * @param {SystemStatusSetChatLogStatusRequestBody} systemStatusSetChatLogStatusRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChatLogStatus: async (systemStatusSetChatLogStatusRequestBody: SystemStatusSetChatLogStatusRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemStatusSetChatLogStatusRequestBody' is not null or undefined
            assertParamExists('setChatLogStatus', 'systemStatusSetChatLogStatusRequestBody', systemStatusSetChatLogStatusRequestBody)
            const localVarPath = `/SystemStatus/Pbx.SetChatLogStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemStatusSetChatLogStatusRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetMultiCompanyMode
         * @param {SystemStatusSetMultiCompanyModeRequestBody} systemStatusSetMultiCompanyModeRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMultiCompanyMode: async (systemStatusSetMultiCompanyModeRequestBody: SystemStatusSetMultiCompanyModeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemStatusSetMultiCompanyModeRequestBody' is not null or undefined
            assertParamExists('setMultiCompanyMode', 'systemStatusSetMultiCompanyModeRequestBody', systemStatusSetMultiCompanyModeRequestBody)
            const localVarPath = `/SystemStatus/Pbx.SetMultiCompanyMode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemStatusSetMultiCompanyModeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action StartDBMaintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDBMaintenance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.StartDBMaintenance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function SystemDatabaseInformation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDatabaseInformation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.SystemDatabaseInformation()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function SystemExtensions
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemExtensions: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.SystemExtensions()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function SystemHealthStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHealthStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/SystemStatus/Pbx.SystemHealthStatus()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemStatusApi - functional programming interface
 * @export
 */
export const SystemStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke function APIToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aPIToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aPIToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.aPIToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetRequestHelpLink
         * @param {number} grantPeriodDays Usage: grantPeriodDays&#x3D;{grantPeriodDays}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestHelpLink(grantPeriodDays: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestHelpLink(grantPeriodDays, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.getRequestHelpLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get SystemStatus
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemStatus($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSystemStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemStatus($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.getSystemStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetVersionType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxVersionUpdateType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.getVersionType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function IsRequestHelpEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRequestHelpEnabled(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRequestHelpEnabled(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.isRequestHelpEnabled']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RequestHelp
         * @param {SystemStatusRequestHelpRequestBody} systemStatusRequestHelpRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestHelp(systemStatusRequestHelpRequestBody: SystemStatusRequestHelpRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestHelp(systemStatusRequestHelpRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.requestHelp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetChatLogStatus
         * @param {SystemStatusSetChatLogStatusRequestBody} systemStatusSetChatLogStatusRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChatLogStatus(systemStatusSetChatLogStatusRequestBody: SystemStatusSetChatLogStatusRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setChatLogStatus(systemStatusSetChatLogStatusRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.setChatLogStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetMultiCompanyMode
         * @param {SystemStatusSetMultiCompanyModeRequestBody} systemStatusSetMultiCompanyModeRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMultiCompanyMode(systemStatusSetMultiCompanyModeRequestBody: SystemStatusSetMultiCompanyModeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMultiCompanyMode(systemStatusSetMultiCompanyModeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.setMultiCompanyMode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action StartDBMaintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startDBMaintenance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startDBMaintenance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.startDBMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function SystemDatabaseInformation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemDatabaseInformation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSystemDatabaseInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemDatabaseInformation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.systemDatabaseInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function SystemExtensions
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemExtensions($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemExtensions($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.systemExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function SystemHealthStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemHealthStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxSystemHealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemHealthStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemStatusApi.systemHealthStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemStatusApi - factory interface
 * @export
 */
export const SystemStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemStatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke function APIToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aPIToken(options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.aPIToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetRequestHelpLink
         * @param {SystemStatusApiGetRequestHelpLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestHelpLink(requestParameters: SystemStatusApiGetRequestHelpLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.getRequestHelpLink(requestParameters.grantPeriodDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SystemStatus
         * @param {SystemStatusApiGetSystemStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemStatus(requestParameters: SystemStatusApiGetSystemStatusRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxSystemStatus> {
            return localVarFp.getSystemStatus(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetVersionType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionType(options?: RawAxiosRequestConfig): AxiosPromise<PbxVersionUpdateType> {
            return localVarFp.getVersionType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function IsRequestHelpEnabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRequestHelpEnabled(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.isRequestHelpEnabled(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RequestHelp
         * @param {SystemStatusApiRequestHelpRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestHelp(requestParameters: SystemStatusApiRequestHelpRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestHelp(requestParameters.systemStatusRequestHelpRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetChatLogStatus
         * @param {SystemStatusApiSetChatLogStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChatLogStatus(requestParameters: SystemStatusApiSetChatLogStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setChatLogStatus(requestParameters.systemStatusSetChatLogStatusRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetMultiCompanyMode
         * @param {SystemStatusApiSetMultiCompanyModeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMultiCompanyMode(requestParameters: SystemStatusApiSetMultiCompanyModeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMultiCompanyMode(requestParameters.systemStatusSetMultiCompanyModeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action StartDBMaintenance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDBMaintenance(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startDBMaintenance(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function SystemDatabaseInformation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDatabaseInformation(options?: RawAxiosRequestConfig): AxiosPromise<PbxSystemDatabaseInformation> {
            return localVarFp.systemDatabaseInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function SystemExtensions
         * @param {SystemStatusApiSystemExtensionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemExtensions(requestParameters: SystemStatusApiSystemExtensionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SystemExtensions200Response> {
            return localVarFp.systemExtensions(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function SystemHealthStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemHealthStatus(options?: RawAxiosRequestConfig): AxiosPromise<PbxSystemHealthStatus> {
            return localVarFp.systemHealthStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRequestHelpLink operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiGetRequestHelpLinkRequest
 */
export interface SystemStatusApiGetRequestHelpLinkRequest {
    /**
     * Usage: grantPeriodDays&#x3D;{grantPeriodDays}
     * @type {number}
     * @memberof SystemStatusApiGetRequestHelpLink
     */
    readonly grantPeriodDays: number
}

/**
 * Request parameters for getSystemStatus operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiGetSystemStatusRequest
 */
export interface SystemStatusApiGetSystemStatusRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof SystemStatusApiGetSystemStatus
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof SystemStatusApiGetSystemStatus
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for requestHelp operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiRequestHelpRequest
 */
export interface SystemStatusApiRequestHelpRequest {
    /**
     * Action parameters
     * @type {SystemStatusRequestHelpRequestBody}
     * @memberof SystemStatusApiRequestHelp
     */
    readonly systemStatusRequestHelpRequestBody: SystemStatusRequestHelpRequestBody
}

/**
 * Request parameters for setChatLogStatus operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiSetChatLogStatusRequest
 */
export interface SystemStatusApiSetChatLogStatusRequest {
    /**
     * Action parameters
     * @type {SystemStatusSetChatLogStatusRequestBody}
     * @memberof SystemStatusApiSetChatLogStatus
     */
    readonly systemStatusSetChatLogStatusRequestBody: SystemStatusSetChatLogStatusRequestBody
}

/**
 * Request parameters for setMultiCompanyMode operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiSetMultiCompanyModeRequest
 */
export interface SystemStatusApiSetMultiCompanyModeRequest {
    /**
     * Action parameters
     * @type {SystemStatusSetMultiCompanyModeRequestBody}
     * @memberof SystemStatusApiSetMultiCompanyMode
     */
    readonly systemStatusSetMultiCompanyModeRequestBody: SystemStatusSetMultiCompanyModeRequestBody
}

/**
 * Request parameters for systemExtensions operation in SystemStatusApi.
 * @export
 * @interface SystemStatusApiSystemExtensionsRequest
 */
export interface SystemStatusApiSystemExtensionsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof SystemStatusApiSystemExtensions
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof SystemStatusApiSystemExtensions
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof SystemStatusApiSystemExtensions
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof SystemStatusApiSystemExtensions
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof SystemStatusApiSystemExtensions
     */
    readonly $count?: boolean
}

/**
 * SystemStatusApi - object-oriented interface
 * @export
 * @class SystemStatusApi
 * @extends {BaseAPI}
 */
export class SystemStatusApi extends BaseAPI {
    /**
     * 
     * @summary Invoke function APIToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public aPIToken(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).aPIToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetRequestHelpLink
     * @param {SystemStatusApiGetRequestHelpLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public getRequestHelpLink(requestParameters: SystemStatusApiGetRequestHelpLinkRequest, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).getRequestHelpLink(requestParameters.grantPeriodDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SystemStatus
     * @param {SystemStatusApiGetSystemStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public getSystemStatus(requestParameters: SystemStatusApiGetSystemStatusRequest = {}, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).getSystemStatus(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetVersionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public getVersionType(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).getVersionType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function IsRequestHelpEnabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public isRequestHelpEnabled(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).isRequestHelpEnabled(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RequestHelp
     * @param {SystemStatusApiRequestHelpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public requestHelp(requestParameters: SystemStatusApiRequestHelpRequest, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).requestHelp(requestParameters.systemStatusRequestHelpRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetChatLogStatus
     * @param {SystemStatusApiSetChatLogStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public setChatLogStatus(requestParameters: SystemStatusApiSetChatLogStatusRequest, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).setChatLogStatus(requestParameters.systemStatusSetChatLogStatusRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetMultiCompanyMode
     * @param {SystemStatusApiSetMultiCompanyModeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public setMultiCompanyMode(requestParameters: SystemStatusApiSetMultiCompanyModeRequest, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).setMultiCompanyMode(requestParameters.systemStatusSetMultiCompanyModeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action StartDBMaintenance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public startDBMaintenance(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).startDBMaintenance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function SystemDatabaseInformation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public systemDatabaseInformation(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).systemDatabaseInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function SystemExtensions
     * @param {SystemStatusApiSystemExtensionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public systemExtensions(requestParameters: SystemStatusApiSystemExtensionsRequest = {}, options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).systemExtensions(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function SystemHealthStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemStatusApi
     */
    public systemHealthStatus(options?: RawAxiosRequestConfig) {
        return SystemStatusApiFp(this.configuration).systemHealthStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TenantPropertiesApi - axios parameter creator
 * @export
 */
export const TenantPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to TenantProperties
         * @param {PbxProperty} pbxProperty New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty: async (pbxProperty: PbxProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxProperty' is not null or undefined
            assertParamExists('createProperty', 'pbxProperty', pbxProperty)
            const localVarPath = `/TenantProperties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxProperty, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from TenantProperties
         * @param {string} name The unique identifier of Property
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty: async (name: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteProperty', 'name', name)
            const localVarPath = `/TenantProperties({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from TenantProperties by key
         * @param {string} name The unique identifier of Property
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperty: async (name: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getProperty', 'name', name)
            const localVarPath = `/TenantProperties({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from TenantProperties
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProperty: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/TenantProperties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in TenantProperties
         * @param {string} name The unique identifier of Property
         * @param {PbxProperty} pbxProperty New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (name: string, pbxProperty: PbxProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateProperty', 'name', name)
            // verify required parameter 'pbxProperty' is not null or undefined
            assertParamExists('updateProperty', 'pbxProperty', pbxProperty)
            const localVarPath = `/TenantProperties({Name})`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxProperty, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantPropertiesApi - functional programming interface
 * @export
 */
export const TenantPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to TenantProperties
         * @param {PbxProperty} pbxProperty New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProperty(pbxProperty: PbxProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProperty(pbxProperty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantPropertiesApi.createProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from TenantProperties
         * @param {string} name The unique identifier of Property
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty(name: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty(name, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantPropertiesApi.deleteProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from TenantProperties by key
         * @param {string} name The unique identifier of Property
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProperty(name: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProperty(name, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantPropertiesApi.getProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from TenantProperties
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProperty($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPropertyCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProperty($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantPropertiesApi.listProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in TenantProperties
         * @param {string} name The unique identifier of Property
         * @param {PbxProperty} pbxProperty New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(name: string, pbxProperty: PbxProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(name, pbxProperty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantPropertiesApi.updateProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TenantPropertiesApi - factory interface
 * @export
 */
export const TenantPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantPropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to TenantProperties
         * @param {TenantPropertiesApiCreatePropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty(requestParameters: TenantPropertiesApiCreatePropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxProperty> {
            return localVarFp.createProperty(requestParameters.pbxProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from TenantProperties
         * @param {TenantPropertiesApiDeletePropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty(requestParameters: TenantPropertiesApiDeletePropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProperty(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from TenantProperties by key
         * @param {TenantPropertiesApiGetPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperty(requestParameters: TenantPropertiesApiGetPropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxProperty> {
            return localVarFp.getProperty(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from TenantProperties
         * @param {TenantPropertiesApiListPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProperty(requestParameters: TenantPropertiesApiListPropertyRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxPropertyCollectionResponse> {
            return localVarFp.listProperty(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in TenantProperties
         * @param {TenantPropertiesApiUpdatePropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(requestParameters: TenantPropertiesApiUpdatePropertyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateProperty(requestParameters.name, requestParameters.pbxProperty, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProperty operation in TenantPropertiesApi.
 * @export
 * @interface TenantPropertiesApiCreatePropertyRequest
 */
export interface TenantPropertiesApiCreatePropertyRequest {
    /**
     * New entity
     * @type {PbxProperty}
     * @memberof TenantPropertiesApiCreateProperty
     */
    readonly pbxProperty: PbxProperty
}

/**
 * Request parameters for deleteProperty operation in TenantPropertiesApi.
 * @export
 * @interface TenantPropertiesApiDeletePropertyRequest
 */
export interface TenantPropertiesApiDeletePropertyRequest {
    /**
     * The unique identifier of Property
     * @type {string}
     * @memberof TenantPropertiesApiDeleteProperty
     */
    readonly name: string

    /**
     * ETag
     * @type {string}
     * @memberof TenantPropertiesApiDeleteProperty
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getProperty operation in TenantPropertiesApi.
 * @export
 * @interface TenantPropertiesApiGetPropertyRequest
 */
export interface TenantPropertiesApiGetPropertyRequest {
    /**
     * The unique identifier of Property
     * @type {string}
     * @memberof TenantPropertiesApiGetProperty
     */
    readonly name: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TenantPropertiesApiGetProperty
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TenantPropertiesApiGetProperty
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listProperty operation in TenantPropertiesApi.
 * @export
 * @interface TenantPropertiesApiListPropertyRequest
 */
export interface TenantPropertiesApiListPropertyRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TenantPropertiesApiListProperty
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateProperty operation in TenantPropertiesApi.
 * @export
 * @interface TenantPropertiesApiUpdatePropertyRequest
 */
export interface TenantPropertiesApiUpdatePropertyRequest {
    /**
     * The unique identifier of Property
     * @type {string}
     * @memberof TenantPropertiesApiUpdateProperty
     */
    readonly name: string

    /**
     * New property values
     * @type {PbxProperty}
     * @memberof TenantPropertiesApiUpdateProperty
     */
    readonly pbxProperty: PbxProperty
}

/**
 * TenantPropertiesApi - object-oriented interface
 * @export
 * @class TenantPropertiesApi
 * @extends {BaseAPI}
 */
export class TenantPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to TenantProperties
     * @param {TenantPropertiesApiCreatePropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantPropertiesApi
     */
    public createProperty(requestParameters: TenantPropertiesApiCreatePropertyRequest, options?: RawAxiosRequestConfig) {
        return TenantPropertiesApiFp(this.configuration).createProperty(requestParameters.pbxProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from TenantProperties
     * @param {TenantPropertiesApiDeletePropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantPropertiesApi
     */
    public deleteProperty(requestParameters: TenantPropertiesApiDeletePropertyRequest, options?: RawAxiosRequestConfig) {
        return TenantPropertiesApiFp(this.configuration).deleteProperty(requestParameters.name, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from TenantProperties by key
     * @param {TenantPropertiesApiGetPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantPropertiesApi
     */
    public getProperty(requestParameters: TenantPropertiesApiGetPropertyRequest, options?: RawAxiosRequestConfig) {
        return TenantPropertiesApiFp(this.configuration).getProperty(requestParameters.name, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from TenantProperties
     * @param {TenantPropertiesApiListPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantPropertiesApi
     */
    public listProperty(requestParameters: TenantPropertiesApiListPropertyRequest = {}, options?: RawAxiosRequestConfig) {
        return TenantPropertiesApiFp(this.configuration).listProperty(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in TenantProperties
     * @param {TenantPropertiesApiUpdatePropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantPropertiesApi
     */
    public updateProperty(requestParameters: TenantPropertiesApiUpdatePropertyRequest, options?: RawAxiosRequestConfig) {
        return TenantPropertiesApiFp(this.configuration).updateProperty(requestParameters.name, requestParameters.pbxProperty, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrunkTemplatesApi - axios parameter creator
 * @export
 */
export const TrunkTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to TrunkTemplates
         * @param {PbxTrunkTemplate} pbxTrunkTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrunkTemplate: async (pbxTrunkTemplate: PbxTrunkTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxTrunkTemplate' is not null or undefined
            assertParamExists('createTrunkTemplate', 'pbxTrunkTemplate', pbxTrunkTemplate)
            const localVarPath = `/TrunkTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxTrunkTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from TrunkTemplates
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrunkTemplate: async (id: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTrunkTemplate', 'id', id)
            const localVarPath = `/TrunkTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from TrunkTemplates by key
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunkTemplate: async (id: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTrunkTemplate', 'id', id)
            const localVarPath = `/TrunkTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from TrunkTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrunkTemplate: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/TrunkTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in TrunkTemplates
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {PbxTrunkTemplate} pbxTrunkTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrunkTemplate: async (id: string, pbxTrunkTemplate: PbxTrunkTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTrunkTemplate', 'id', id)
            // verify required parameter 'pbxTrunkTemplate' is not null or undefined
            assertParamExists('updateTrunkTemplate', 'pbxTrunkTemplate', pbxTrunkTemplate)
            const localVarPath = `/TrunkTemplates({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxTrunkTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrunkTemplatesApi - functional programming interface
 * @export
 */
export const TrunkTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrunkTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to TrunkTemplates
         * @param {PbxTrunkTemplate} pbxTrunkTemplate New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrunkTemplate(pbxTrunkTemplate: PbxTrunkTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunkTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrunkTemplate(pbxTrunkTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunkTemplatesApi.createTrunkTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from TrunkTemplates
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrunkTemplate(id: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrunkTemplate(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunkTemplatesApi.deleteTrunkTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from TrunkTemplates by key
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrunkTemplate(id: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunkTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrunkTemplate(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunkTemplatesApi.getTrunkTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from TrunkTemplates
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrunkTemplate($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunkTemplateCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrunkTemplate($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunkTemplatesApi.listTrunkTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in TrunkTemplates
         * @param {string} id The unique identifier of TrunkTemplate
         * @param {PbxTrunkTemplate} pbxTrunkTemplate New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrunkTemplate(id: string, pbxTrunkTemplate: PbxTrunkTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrunkTemplate(id, pbxTrunkTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunkTemplatesApi.updateTrunkTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrunkTemplatesApi - factory interface
 * @export
 */
export const TrunkTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrunkTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to TrunkTemplates
         * @param {TrunkTemplatesApiCreateTrunkTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrunkTemplate(requestParameters: TrunkTemplatesApiCreateTrunkTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunkTemplate> {
            return localVarFp.createTrunkTemplate(requestParameters.pbxTrunkTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from TrunkTemplates
         * @param {TrunkTemplatesApiDeleteTrunkTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrunkTemplate(requestParameters: TrunkTemplatesApiDeleteTrunkTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTrunkTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from TrunkTemplates by key
         * @param {TrunkTemplatesApiGetTrunkTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunkTemplate(requestParameters: TrunkTemplatesApiGetTrunkTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunkTemplate> {
            return localVarFp.getTrunkTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from TrunkTemplates
         * @param {TrunkTemplatesApiListTrunkTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrunkTemplate(requestParameters: TrunkTemplatesApiListTrunkTemplateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunkTemplateCollectionResponse> {
            return localVarFp.listTrunkTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in TrunkTemplates
         * @param {TrunkTemplatesApiUpdateTrunkTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrunkTemplate(requestParameters: TrunkTemplatesApiUpdateTrunkTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTrunkTemplate(requestParameters.id, requestParameters.pbxTrunkTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrunkTemplate operation in TrunkTemplatesApi.
 * @export
 * @interface TrunkTemplatesApiCreateTrunkTemplateRequest
 */
export interface TrunkTemplatesApiCreateTrunkTemplateRequest {
    /**
     * New entity
     * @type {PbxTrunkTemplate}
     * @memberof TrunkTemplatesApiCreateTrunkTemplate
     */
    readonly pbxTrunkTemplate: PbxTrunkTemplate
}

/**
 * Request parameters for deleteTrunkTemplate operation in TrunkTemplatesApi.
 * @export
 * @interface TrunkTemplatesApiDeleteTrunkTemplateRequest
 */
export interface TrunkTemplatesApiDeleteTrunkTemplateRequest {
    /**
     * The unique identifier of TrunkTemplate
     * @type {string}
     * @memberof TrunkTemplatesApiDeleteTrunkTemplate
     */
    readonly id: string

    /**
     * ETag
     * @type {string}
     * @memberof TrunkTemplatesApiDeleteTrunkTemplate
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getTrunkTemplate operation in TrunkTemplatesApi.
 * @export
 * @interface TrunkTemplatesApiGetTrunkTemplateRequest
 */
export interface TrunkTemplatesApiGetTrunkTemplateRequest {
    /**
     * The unique identifier of TrunkTemplate
     * @type {string}
     * @memberof TrunkTemplatesApiGetTrunkTemplate
     */
    readonly id: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TrunkTemplatesApiGetTrunkTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TrunkTemplatesApiGetTrunkTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listTrunkTemplate operation in TrunkTemplatesApi.
 * @export
 * @interface TrunkTemplatesApiListTrunkTemplateRequest
 */
export interface TrunkTemplatesApiListTrunkTemplateRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TrunkTemplatesApiListTrunkTemplate
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateTrunkTemplate operation in TrunkTemplatesApi.
 * @export
 * @interface TrunkTemplatesApiUpdateTrunkTemplateRequest
 */
export interface TrunkTemplatesApiUpdateTrunkTemplateRequest {
    /**
     * The unique identifier of TrunkTemplate
     * @type {string}
     * @memberof TrunkTemplatesApiUpdateTrunkTemplate
     */
    readonly id: string

    /**
     * New property values
     * @type {PbxTrunkTemplate}
     * @memberof TrunkTemplatesApiUpdateTrunkTemplate
     */
    readonly pbxTrunkTemplate: PbxTrunkTemplate
}

/**
 * TrunkTemplatesApi - object-oriented interface
 * @export
 * @class TrunkTemplatesApi
 * @extends {BaseAPI}
 */
export class TrunkTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to TrunkTemplates
     * @param {TrunkTemplatesApiCreateTrunkTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunkTemplatesApi
     */
    public createTrunkTemplate(requestParameters: TrunkTemplatesApiCreateTrunkTemplateRequest, options?: RawAxiosRequestConfig) {
        return TrunkTemplatesApiFp(this.configuration).createTrunkTemplate(requestParameters.pbxTrunkTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from TrunkTemplates
     * @param {TrunkTemplatesApiDeleteTrunkTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunkTemplatesApi
     */
    public deleteTrunkTemplate(requestParameters: TrunkTemplatesApiDeleteTrunkTemplateRequest, options?: RawAxiosRequestConfig) {
        return TrunkTemplatesApiFp(this.configuration).deleteTrunkTemplate(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from TrunkTemplates by key
     * @param {TrunkTemplatesApiGetTrunkTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunkTemplatesApi
     */
    public getTrunkTemplate(requestParameters: TrunkTemplatesApiGetTrunkTemplateRequest, options?: RawAxiosRequestConfig) {
        return TrunkTemplatesApiFp(this.configuration).getTrunkTemplate(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from TrunkTemplates
     * @param {TrunkTemplatesApiListTrunkTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunkTemplatesApi
     */
    public listTrunkTemplate(requestParameters: TrunkTemplatesApiListTrunkTemplateRequest = {}, options?: RawAxiosRequestConfig) {
        return TrunkTemplatesApiFp(this.configuration).listTrunkTemplate(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in TrunkTemplates
     * @param {TrunkTemplatesApiUpdateTrunkTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunkTemplatesApi
     */
    public updateTrunkTemplate(requestParameters: TrunkTemplatesApiUpdateTrunkTemplateRequest, options?: RawAxiosRequestConfig) {
        return TrunkTemplatesApiFp(this.configuration).updateTrunkTemplate(requestParameters.id, requestParameters.pbxTrunkTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrunksApi - axios parameter creator
 * @export
 */
export const TrunksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new entity to Trunks
         * @param {PbxTrunk} pbxTrunk New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrunk: async (pbxTrunk: PbxTrunk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxTrunk' is not null or undefined
            assertParamExists('createTrunk', 'pbxTrunk', pbxTrunk)
            const localVarPath = `/Trunks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxTrunk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Trunks
         * @param {number} id The unique identifier of Trunk
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrunk: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTrunk', 'id', id)
            const localVarPath = `/Trunks({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function ExportTrunk
         * @param {number} id The unique identifier of Trunk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTrunk: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportTrunk', 'id', id)
            const localVarPath = `/Trunks({Id})/Pbx.ExportTrunk()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableTrunkNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableTrunkNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trunks/Pbx.GetFirstAvailableTrunkNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Trunks by key
         * @param {number} id The unique identifier of Trunk
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunk: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTrunk', 'id', id)
            const localVarPath = `/Trunks({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetTrunkByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunkByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getTrunkByNumber', 'number', number)
            const localVarPath = `/Trunks/Pbx.GetTrunkByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function InitMasterBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMasterBridge: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trunks/Pbx.InitMasterBridge()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function InitSlaveBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSlaveBridge: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trunks/Pbx.InitSlaveBridge()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function InitTrunk
         * @param {string} template Usage: template&#x3D;{template}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTrunk: async (template: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'template' is not null or undefined
            assertParamExists('initTrunk', 'template', template)
            const localVarPath = `/Trunks/Pbx.InitTrunk(template={template})`
                .replace(`{${"template"}}`, encodeURIComponent(String(template)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Trunks
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrunk: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trunks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ProvisionTrunk
         * @param {TrunksProvisionTrunkRequestBody} trunksProvisionTrunkRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionTrunk: async (trunksProvisionTrunkRequestBody: TrunksProvisionTrunkRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunksProvisionTrunkRequestBody' is not null or undefined
            assertParamExists('provisionTrunk', 'trunksProvisionTrunkRequestBody', trunksProvisionTrunkRequestBody)
            const localVarPath = `/Trunks/Pbx.ProvisionTrunk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trunksProvisionTrunkRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RefreshRegistration
         * @param {TrunksRefreshRegistrationRequestBody} trunksRefreshRegistrationRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshRegistration: async (trunksRefreshRegistrationRequestBody: TrunksRefreshRegistrationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunksRefreshRegistrationRequestBody' is not null or undefined
            assertParamExists('refreshRegistration', 'trunksRefreshRegistrationRequestBody', trunksRefreshRegistrationRequestBody)
            const localVarPath = `/Trunks/Pbx.RefreshRegistration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trunksRefreshRegistrationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetRoutes
         * @param {TrunksSetRoutesRequestBody} trunksSetRoutesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutes: async (trunksSetRoutesRequestBody: TrunksSetRoutesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunksSetRoutesRequestBody' is not null or undefined
            assertParamExists('setRoutes', 'trunksSetRoutesRequestBody', trunksSetRoutesRequestBody)
            const localVarPath = `/Trunks/Pbx.SetRoutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trunksSetRoutesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Trunks
         * @param {number} id The unique identifier of Trunk
         * @param {PbxTrunk} pbxTrunk New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrunk: async (id: number, pbxTrunk: PbxTrunk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTrunk', 'id', id)
            // verify required parameter 'pbxTrunk' is not null or undefined
            assertParamExists('updateTrunk', 'pbxTrunk', pbxTrunk)
            const localVarPath = `/Trunks({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxTrunk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrunksApi - functional programming interface
 * @export
 */
export const TrunksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrunksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Trunks
         * @param {PbxTrunk} pbxTrunk New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrunk(pbxTrunk: PbxTrunk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrunk(pbxTrunk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.createTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Trunks
         * @param {number} id The unique identifier of Trunk
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrunk(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrunk(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.deleteTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function ExportTrunk
         * @param {number} id The unique identifier of Trunk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportTrunk(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportTrunk(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.exportTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableTrunkNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableTrunkNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableTrunkNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.getFirstAvailableTrunkNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Trunks by key
         * @param {number} id The unique identifier of Trunk
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrunk(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrunk(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.getTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetTrunkByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrunkByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrunkByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.getTrunkByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function InitMasterBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initMasterBridge(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initMasterBridge(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.initMasterBridge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function InitSlaveBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initSlaveBridge(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initSlaveBridge(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.initSlaveBridge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function InitTrunk
         * @param {string} template Usage: template&#x3D;{template}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initTrunk(template: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initTrunk(template, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.initTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Trunks
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrunk($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxTrunkCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrunk($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.listTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ProvisionTrunk
         * @param {TrunksProvisionTrunkRequestBody} trunksProvisionTrunkRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provisionTrunk(trunksProvisionTrunkRequestBody: TrunksProvisionTrunkRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxProvisionedTrunk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provisionTrunk(trunksProvisionTrunkRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.provisionTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RefreshRegistration
         * @param {TrunksRefreshRegistrationRequestBody} trunksRefreshRegistrationRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshRegistration(trunksRefreshRegistrationRequestBody: TrunksRefreshRegistrationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshRegistration(trunksRefreshRegistrationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.refreshRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetRoutes
         * @param {TrunksSetRoutesRequestBody} trunksSetRoutesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoutes(trunksSetRoutesRequestBody: TrunksSetRoutesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoutes(trunksSetRoutesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.setRoutes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Trunks
         * @param {number} id The unique identifier of Trunk
         * @param {PbxTrunk} pbxTrunk New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrunk(id: number, pbxTrunk: PbxTrunk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrunk(id, pbxTrunk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrunksApi.updateTrunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrunksApi - factory interface
 * @export
 */
export const TrunksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrunksApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new entity to Trunks
         * @param {TrunksApiCreateTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrunk(requestParameters: TrunksApiCreateTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.createTrunk(requestParameters.pbxTrunk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Trunks
         * @param {TrunksApiDeleteTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrunk(requestParameters: TrunksApiDeleteTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTrunk(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function ExportTrunk
         * @param {TrunksApiExportTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTrunk(requestParameters: TrunksApiExportTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.exportTrunk(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableTrunkNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableTrunkNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableTrunkNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Trunks by key
         * @param {TrunksApiGetTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunk(requestParameters: TrunksApiGetTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.getTrunk(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetTrunkByNumber
         * @param {TrunksApiGetTrunkByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrunkByNumber(requestParameters: TrunksApiGetTrunkByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.getTrunkByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function InitMasterBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMasterBridge(options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.initMasterBridge(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function InitSlaveBridge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSlaveBridge(options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.initSlaveBridge(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function InitTrunk
         * @param {TrunksApiInitTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTrunk(requestParameters: TrunksApiInitTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunk> {
            return localVarFp.initTrunk(requestParameters.template, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Trunks
         * @param {TrunksApiListTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrunk(requestParameters: TrunksApiListTrunkRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxTrunkCollectionResponse> {
            return localVarFp.listTrunk(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ProvisionTrunk
         * @param {TrunksApiProvisionTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionTrunk(requestParameters: TrunksApiProvisionTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxProvisionedTrunk> {
            return localVarFp.provisionTrunk(requestParameters.trunksProvisionTrunkRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RefreshRegistration
         * @param {TrunksApiRefreshRegistrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshRegistration(requestParameters: TrunksApiRefreshRegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.refreshRegistration(requestParameters.trunksRefreshRegistrationRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetRoutes
         * @param {TrunksApiSetRoutesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutes(requestParameters: TrunksApiSetRoutesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setRoutes(requestParameters.trunksSetRoutesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Trunks
         * @param {TrunksApiUpdateTrunkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrunk(requestParameters: TrunksApiUpdateTrunkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTrunk(requestParameters.id, requestParameters.pbxTrunk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiCreateTrunkRequest
 */
export interface TrunksApiCreateTrunkRequest {
    /**
     * New entity
     * @type {PbxTrunk}
     * @memberof TrunksApiCreateTrunk
     */
    readonly pbxTrunk: PbxTrunk
}

/**
 * Request parameters for deleteTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiDeleteTrunkRequest
 */
export interface TrunksApiDeleteTrunkRequest {
    /**
     * The unique identifier of Trunk
     * @type {number}
     * @memberof TrunksApiDeleteTrunk
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof TrunksApiDeleteTrunk
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for exportTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiExportTrunkRequest
 */
export interface TrunksApiExportTrunkRequest {
    /**
     * The unique identifier of Trunk
     * @type {number}
     * @memberof TrunksApiExportTrunk
     */
    readonly id: number
}

/**
 * Request parameters for getTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiGetTrunkRequest
 */
export interface TrunksApiGetTrunkRequest {
    /**
     * The unique identifier of Trunk
     * @type {number}
     * @memberof TrunksApiGetTrunk
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TrunksApiGetTrunk
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TrunksApiGetTrunk
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getTrunkByNumber operation in TrunksApi.
 * @export
 * @interface TrunksApiGetTrunkByNumberRequest
 */
export interface TrunksApiGetTrunkByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof TrunksApiGetTrunkByNumber
     */
    readonly number: string
}

/**
 * Request parameters for initTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiInitTrunkRequest
 */
export interface TrunksApiInitTrunkRequest {
    /**
     * Usage: template&#x3D;{template}
     * @type {string}
     * @memberof TrunksApiInitTrunk
     */
    readonly template: string
}

/**
 * Request parameters for listTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiListTrunkRequest
 */
export interface TrunksApiListTrunkRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof TrunksApiListTrunk
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof TrunksApiListTrunk
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof TrunksApiListTrunk
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof TrunksApiListTrunk
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof TrunksApiListTrunk
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof TrunksApiListTrunk
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof TrunksApiListTrunk
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof TrunksApiListTrunk
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for provisionTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiProvisionTrunkRequest
 */
export interface TrunksApiProvisionTrunkRequest {
    /**
     * Action parameters
     * @type {TrunksProvisionTrunkRequestBody}
     * @memberof TrunksApiProvisionTrunk
     */
    readonly trunksProvisionTrunkRequestBody: TrunksProvisionTrunkRequestBody
}

/**
 * Request parameters for refreshRegistration operation in TrunksApi.
 * @export
 * @interface TrunksApiRefreshRegistrationRequest
 */
export interface TrunksApiRefreshRegistrationRequest {
    /**
     * Action parameters
     * @type {TrunksRefreshRegistrationRequestBody}
     * @memberof TrunksApiRefreshRegistration
     */
    readonly trunksRefreshRegistrationRequestBody: TrunksRefreshRegistrationRequestBody
}

/**
 * Request parameters for setRoutes operation in TrunksApi.
 * @export
 * @interface TrunksApiSetRoutesRequest
 */
export interface TrunksApiSetRoutesRequest {
    /**
     * Action parameters
     * @type {TrunksSetRoutesRequestBody}
     * @memberof TrunksApiSetRoutes
     */
    readonly trunksSetRoutesRequestBody: TrunksSetRoutesRequestBody
}

/**
 * Request parameters for updateTrunk operation in TrunksApi.
 * @export
 * @interface TrunksApiUpdateTrunkRequest
 */
export interface TrunksApiUpdateTrunkRequest {
    /**
     * The unique identifier of Trunk
     * @type {number}
     * @memberof TrunksApiUpdateTrunk
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxTrunk}
     * @memberof TrunksApiUpdateTrunk
     */
    readonly pbxTrunk: PbxTrunk
}

/**
 * TrunksApi - object-oriented interface
 * @export
 * @class TrunksApi
 * @extends {BaseAPI}
 */
export class TrunksApi extends BaseAPI {
    /**
     * 
     * @summary Add new entity to Trunks
     * @param {TrunksApiCreateTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public createTrunk(requestParameters: TrunksApiCreateTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).createTrunk(requestParameters.pbxTrunk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Trunks
     * @param {TrunksApiDeleteTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public deleteTrunk(requestParameters: TrunksApiDeleteTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).deleteTrunk(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function ExportTrunk
     * @param {TrunksApiExportTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public exportTrunk(requestParameters: TrunksApiExportTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).exportTrunk(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableTrunkNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public getFirstAvailableTrunkNumber(options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).getFirstAvailableTrunkNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Trunks by key
     * @param {TrunksApiGetTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public getTrunk(requestParameters: TrunksApiGetTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).getTrunk(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetTrunkByNumber
     * @param {TrunksApiGetTrunkByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public getTrunkByNumber(requestParameters: TrunksApiGetTrunkByNumberRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).getTrunkByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function InitMasterBridge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public initMasterBridge(options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).initMasterBridge(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function InitSlaveBridge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public initSlaveBridge(options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).initSlaveBridge(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function InitTrunk
     * @param {TrunksApiInitTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public initTrunk(requestParameters: TrunksApiInitTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).initTrunk(requestParameters.template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Trunks
     * @param {TrunksApiListTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public listTrunk(requestParameters: TrunksApiListTrunkRequest = {}, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).listTrunk(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ProvisionTrunk
     * @param {TrunksApiProvisionTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public provisionTrunk(requestParameters: TrunksApiProvisionTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).provisionTrunk(requestParameters.trunksProvisionTrunkRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RefreshRegistration
     * @param {TrunksApiRefreshRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public refreshRegistration(requestParameters: TrunksApiRefreshRegistrationRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).refreshRegistration(requestParameters.trunksRefreshRegistrationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetRoutes
     * @param {TrunksApiSetRoutesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public setRoutes(requestParameters: TrunksApiSetRoutesRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).setRoutes(requestParameters.trunksSetRoutesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Trunks
     * @param {TrunksApiUpdateTrunkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public updateTrunk(requestParameters: TrunksApiUpdateTrunkRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).updateTrunk(requestParameters.id, requestParameters.pbxTrunk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UpdatesApi - axios parameter creator
 * @export
 */
export const UpdatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke functionImport GetClientCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientCrmUpdates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetClientCrmUpdates()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport GetPromptSetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptSetUpdates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetPromptSetUpdates()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport GetServerCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerCrmUpdates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetServerCrmUpdates()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdateSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUpdateSettings()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUpdates()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdatesStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatesStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUpdatesStats()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke functionImport HasDebianUpgrade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDebianUpgrade: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/HasDebianUpgrade()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke actionImport InstallUpdates
         * @param {ActionImportInstallUpdatesRequestBody} actionImportInstallUpdatesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installUpdates: async (actionImportInstallUpdatesRequestBody: ActionImportInstallUpdatesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionImportInstallUpdatesRequestBody' is not null or undefined
            assertParamExists('installUpdates', 'actionImportInstallUpdatesRequestBody', actionImportInstallUpdatesRequestBody)
            const localVarPath = `/InstallUpdates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionImportInstallUpdatesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke actionImport SetUpdateSettings
         * @param {ActionImportSetUpdateSettingsRequestBody} actionImportSetUpdateSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUpdateSettings: async (actionImportSetUpdateSettingsRequestBody: ActionImportSetUpdateSettingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionImportSetUpdateSettingsRequestBody' is not null or undefined
            assertParamExists('setUpdateSettings', 'actionImportSetUpdateSettingsRequestBody', actionImportSetUpdateSettingsRequestBody)
            const localVarPath = `/SetUpdateSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionImportSetUpdateSettingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke actionImport UpgradeDebian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeDebian: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/UpgradeDebian`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesApi - functional programming interface
 * @export
 */
export const UpdatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke functionImport GetClientCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientCrmUpdates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientCrmUpdates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getClientCrmUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport GetPromptSetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptSetUpdates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptSetUpdates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getPromptSetUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport GetServerCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerCrmUpdates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerCrmUpdates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getServerCrmUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdateSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdateSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdateSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdateSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getUpdateSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdatesStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdatesStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUpdatesStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdatesStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.getUpdatesStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke functionImport HasDebianUpgrade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasDebianUpgrade(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasDebianUpgrade(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.hasDebianUpgrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke actionImport InstallUpdates
         * @param {ActionImportInstallUpdatesRequestBody} actionImportInstallUpdatesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installUpdates(actionImportInstallUpdatesRequestBody: ActionImportInstallUpdatesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installUpdates(actionImportInstallUpdatesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.installUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke actionImport SetUpdateSettings
         * @param {ActionImportSetUpdateSettingsRequestBody} actionImportSetUpdateSettingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUpdateSettings(actionImportSetUpdateSettingsRequestBody: ActionImportSetUpdateSettingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUpdateSettings(actionImportSetUpdateSettingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.setUpdateSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke actionImport UpgradeDebian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeDebian(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeDebian(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdatesApi.upgradeDebian']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UpdatesApi - factory interface
 * @export
 */
export const UpdatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke functionImport GetClientCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientCrmUpdates(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdateList> {
            return localVarFp.getClientCrmUpdates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport GetPromptSetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptSetUpdates(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdateList> {
            return localVarFp.getPromptSetUpdates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport GetServerCrmUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerCrmUpdates(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdateList> {
            return localVarFp.getServerCrmUpdates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdateSettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateSettings(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdateSettings> {
            return localVarFp.getUpdateSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdates(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdateList> {
            return localVarFp.getUpdates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport GetUpdatesStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatesStats(options?: RawAxiosRequestConfig): AxiosPromise<PbxUpdatesStats> {
            return localVarFp.getUpdatesStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke functionImport HasDebianUpgrade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDebianUpgrade(options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.hasDebianUpgrade(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke actionImport InstallUpdates
         * @param {UpdatesApiInstallUpdatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installUpdates(requestParameters: UpdatesApiInstallUpdatesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.installUpdates(requestParameters.actionImportInstallUpdatesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke actionImport SetUpdateSettings
         * @param {UpdatesApiSetUpdateSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUpdateSettings(requestParameters: UpdatesApiSetUpdateSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setUpdateSettings(requestParameters.actionImportSetUpdateSettingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke actionImport UpgradeDebian
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeDebian(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.upgradeDebian(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for installUpdates operation in UpdatesApi.
 * @export
 * @interface UpdatesApiInstallUpdatesRequest
 */
export interface UpdatesApiInstallUpdatesRequest {
    /**
     * Action parameters
     * @type {ActionImportInstallUpdatesRequestBody}
     * @memberof UpdatesApiInstallUpdates
     */
    readonly actionImportInstallUpdatesRequestBody: ActionImportInstallUpdatesRequestBody
}

/**
 * Request parameters for setUpdateSettings operation in UpdatesApi.
 * @export
 * @interface UpdatesApiSetUpdateSettingsRequest
 */
export interface UpdatesApiSetUpdateSettingsRequest {
    /**
     * Action parameters
     * @type {ActionImportSetUpdateSettingsRequestBody}
     * @memberof UpdatesApiSetUpdateSettings
     */
    readonly actionImportSetUpdateSettingsRequestBody: ActionImportSetUpdateSettingsRequestBody
}

/**
 * UpdatesApi - object-oriented interface
 * @export
 * @class UpdatesApi
 * @extends {BaseAPI}
 */
export class UpdatesApi extends BaseAPI {
    /**
     * 
     * @summary Invoke functionImport GetClientCrmUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getClientCrmUpdates(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getClientCrmUpdates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport GetPromptSetUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getPromptSetUpdates(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getPromptSetUpdates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport GetServerCrmUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getServerCrmUpdates(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getServerCrmUpdates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport GetUpdateSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getUpdateSettings(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getUpdateSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport GetUpdates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getUpdates(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getUpdates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport GetUpdatesStats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public getUpdatesStats(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).getUpdatesStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke functionImport HasDebianUpgrade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public hasDebianUpgrade(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).hasDebianUpgrade(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke actionImport InstallUpdates
     * @param {UpdatesApiInstallUpdatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public installUpdates(requestParameters: UpdatesApiInstallUpdatesRequest, options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).installUpdates(requestParameters.actionImportInstallUpdatesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke actionImport SetUpdateSettings
     * @param {UpdatesApiSetUpdateSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public setUpdateSettings(requestParameters: UpdatesApiSetUpdateSettingsRequest, options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).setUpdateSettings(requestParameters.actionImportSetUpdateSettingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke actionImport UpgradeDebian
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesApi
     */
    public upgradeDebian(options?: RawAxiosRequestConfig) {
        return UpdatesApiFp(this.configuration).upgradeDebian(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BatchDelete
         * @param {UsersBatchDeleteRequestBody} usersBatchDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchDelete: async (usersBatchDeleteRequestBody: UsersBatchDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersBatchDeleteRequestBody' is not null or undefined
            assertParamExists('batchDelete', 'usersBatchDeleteRequestBody', usersBatchDeleteRequestBody)
            const localVarPath = `/Users/Pbx.BatchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersBatchDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action BulkUpdate
         * @param {UsersBulkUpdateRequestBody} usersBulkUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate: async (usersBulkUpdateRequestBody: UsersBulkUpdateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersBulkUpdateRequestBody' is not null or undefined
            assertParamExists('bulkUpdate', 'usersBulkUpdateRequestBody', usersBulkUpdateRequestBody)
            const localVarPath = `/Users/Pbx.BulkUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersBulkUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to Users
         * @param {PbxUser} pbxUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (pbxUser: PbxUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxUser' is not null or undefined
            assertParamExists('createUser', 'pbxUser', pbxUser)
            const localVarPath = `/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from Users
         * @param {number} id The unique identifier of User
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/Users({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function DownloadGreeting
         * @param {number} userId Usage: userId&#x3D;{userId}
         * @param {string} fileName Usage: fileName&#x3D;{fileName}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGreeting: async (userId: number, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('downloadGreeting', 'userId', userId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadGreeting', 'fileName', fileName)
            const localVarPath = `/Users/Pbx.DownloadGreeting(userId={userId},fileName={fileName})`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function ExportExtensions
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportExtensions: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Pbx.ExportExtensions()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateProvLink: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generateProvLink', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.GenerateProvLink()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetDuplicatedEmails
         * @param {UsersGetDuplicatedEmailsRequestBody} usersGetDuplicatedEmailsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDuplicatedEmails: async (usersGetDuplicatedEmailsRequestBody: UsersGetDuplicatedEmailsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersGetDuplicatedEmailsRequestBody' is not null or undefined
            assertParamExists('getDuplicatedEmails', 'usersGetDuplicatedEmailsRequestBody', usersGetDuplicatedEmailsRequestBody)
            const localVarPath = `/Users/Pbx.GetDuplicatedEmails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersGetDuplicatedEmailsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableExtensionNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableExtensionNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Pbx.GetFirstAvailableExtensionNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableHotdeskingNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableHotdeskingNumber: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Pbx.GetFirstAvailableHotdeskingNumber()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetMonitorStatus
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorStatus: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Pbx.GetMonitorStatus()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetMultiEditGreetings
         * @param {UsersGetMultiEditGreetingsRequestBody} usersGetMultiEditGreetingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiEditGreetings: async (usersGetMultiEditGreetingsRequestBody: UsersGetMultiEditGreetingsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersGetMultiEditGreetingsRequestBody' is not null or undefined
            assertParamExists('getMultiEditGreetings', 'usersGetMultiEditGreetingsRequestBody', usersGetMultiEditGreetingsRequestBody)
            const localVarPath = `/Users/Pbx.GetMultiEditGreetings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersGetMultiEditGreetingsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetPhoneRegistrar
         * @param {string} mac Usage: mac&#x3D;{mac}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneRegistrar: async (mac: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mac' is not null or undefined
            assertParamExists('getPhoneRegistrar', 'mac', mac)
            const localVarPath = `/Users/Pbx.GetPhoneRegistrar(mac={mac})`
                .replace(`{${"mac"}}`, encodeURIComponent(String(mac)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action GetPhoneRegistrars
         * @param {UsersGetPhoneRegistrarsRequestBody} usersGetPhoneRegistrarsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneRegistrars: async (usersGetPhoneRegistrarsRequestBody: UsersGetPhoneRegistrarsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersGetPhoneRegistrarsRequestBody' is not null or undefined
            assertParamExists('getPhoneRegistrars', 'usersGetPhoneRegistrarsRequestBody', usersGetPhoneRegistrarsRequestBody)
            const localVarPath = `/Users/Pbx.GetPhoneRegistrars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersGetPhoneRegistrarsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetPhoneSecret
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneSecret: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhoneSecret', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.GetPhoneSecret()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from Users by key
         * @param {number} id The unique identifier of User
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: number, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/Users({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByNumber: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getUserByNumber', 'number', number)
            const localVarPath = `/Users/Pbx.GetByNumber(number={number})`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function HasDuplicatedEmail
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDuplicatedEmail: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hasDuplicatedEmail', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.HasDuplicatedEmail()`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ForwardingProfiles from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForwardingProfiles: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listForwardingProfiles', 'id', id)
            const localVarPath = `/Users({Id})/ForwardingProfiles`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Greetings from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGreetings: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listGreetings', 'id', id)
            const localVarPath = `/Users({Id})/Greetings`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Groups from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listGroups', 'id', id)
            const localVarPath = `/Users({Id})/Groups`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from Users
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MakeCall
         * @param {UsersMakeCallRequestBody} usersMakeCallRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCall: async (usersMakeCallRequestBody: UsersMakeCallRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersMakeCallRequestBody' is not null or undefined
            assertParamExists('makeCall', 'usersMakeCallRequestBody', usersMakeCallRequestBody)
            const localVarPath = `/Users/Pbx.MakeCall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersMakeCallRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MakeCallUserRecordGreeting
         * @param {number} id The unique identifier of User
         * @param {MakeCallUserRecordGreetingRequestBody} [makeCallUserRecordGreetingRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCallUserRecordGreeting: async (id: number, makeCallUserRecordGreetingRequestBody?: MakeCallUserRecordGreetingRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeCallUserRecordGreeting', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.MakeCallUserRecordGreeting`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(makeCallUserRecordGreetingRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MultiDeleteGreeting
         * @param {UsersMultiDeleteGreetingRequestBody} usersMultiDeleteGreetingRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiDeleteGreeting: async (usersMultiDeleteGreetingRequestBody: UsersMultiDeleteGreetingRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersMultiDeleteGreetingRequestBody' is not null or undefined
            assertParamExists('multiDeleteGreeting', 'usersMultiDeleteGreetingRequestBody', usersMultiDeleteGreetingRequestBody)
            const localVarPath = `/Users/Pbx.MultiDeleteGreeting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersMultiDeleteGreetingRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action MultiUserUpdate
         * @param {UsersMultiUserUpdateRequestBody} usersMultiUserUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiUserUpdate: async (usersMultiUserUpdateRequestBody: UsersMultiUserUpdateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersMultiUserUpdateRequestBody' is not null or undefined
            assertParamExists('multiUserUpdate', 'usersMultiUserUpdateRequestBody', usersMultiUserUpdateRequestBody)
            const localVarPath = `/Users/Pbx.MultiUserUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersMultiUserUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RebootPhone
         * @param {UsersRebootPhoneRequestBody} usersRebootPhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootPhone: async (usersRebootPhoneRequestBody: UsersRebootPhoneRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRebootPhoneRequestBody' is not null or undefined
            assertParamExists('rebootPhone', 'usersRebootPhoneRequestBody', usersRebootPhoneRequestBody)
            const localVarPath = `/Users/Pbx.RebootPhone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRebootPhoneRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action Regenerate
         * @param {number} id The unique identifier of User
         * @param {RegenerateRequestBody} [regenerateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerate: async (id: number, regenerateRequestBody?: RegenerateRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('regenerate', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.Regenerate`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regenerateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action RegeneratePasswords
         * @param {UsersRegeneratePasswordsRequestBody} usersRegeneratePasswordsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regeneratePasswords: async (usersRegeneratePasswordsRequestBody: UsersRegeneratePasswordsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRegeneratePasswordsRequestBody' is not null or undefined
            assertParamExists('regeneratePasswords', 'usersRegeneratePasswordsRequestBody', usersRegeneratePasswordsRequestBody)
            const localVarPath = `/Users/Pbx.RegeneratePasswords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRegeneratePasswordsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ReprovisionAllPhones
         * @param {UsersReprovisionAllPhonesRequestBody} usersReprovisionAllPhonesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprovisionAllPhones: async (usersReprovisionAllPhonesRequestBody: UsersReprovisionAllPhonesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersReprovisionAllPhonesRequestBody' is not null or undefined
            assertParamExists('reprovisionAllPhones', 'usersReprovisionAllPhonesRequestBody', usersReprovisionAllPhonesRequestBody)
            const localVarPath = `/Users/Pbx.ReprovisionAllPhones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersReprovisionAllPhonesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ReprovisionPhone
         * @param {UsersReprovisionPhoneRequestBody} usersReprovisionPhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprovisionPhone: async (usersReprovisionPhoneRequestBody: UsersReprovisionPhoneRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersReprovisionPhoneRequestBody' is not null or undefined
            assertParamExists('reprovisionPhone', 'usersReprovisionPhoneRequestBody', usersReprovisionPhoneRequestBody)
            const localVarPath = `/Users/Pbx.ReprovisionPhone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersReprovisionPhoneRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SendWelcomeEmail
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWelcomeEmail: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendWelcomeEmail', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.SendWelcomeEmail`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action SetMonitorStatus
         * @param {number} id The unique identifier of User
         * @param {SetMonitorStatusRequestBody} [setMonitorStatusRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMonitorStatus: async (id: number, setMonitorStatusRequestBody?: SetMonitorStatusRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setMonitorStatus', 'id', id)
            const localVarPath = `/Users({Id})/Pbx.SetMonitorStatus`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setMonitorStatusRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in Users
         * @param {number} id The unique identifier of User
         * @param {PbxUser} pbxUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, pbxUser: PbxUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'pbxUser' is not null or undefined
            assertParamExists('updateUser', 'pbxUser', pbxUser)
            const localVarPath = `/Users({Id})`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action UpgradePhone
         * @param {UsersUpgradePhoneRequestBody} usersUpgradePhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradePhone: async (usersUpgradePhoneRequestBody: UsersUpgradePhoneRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersUpgradePhoneRequestBody' is not null or undefined
            assertParamExists('upgradePhone', 'usersUpgradePhoneRequestBody', usersUpgradePhoneRequestBody)
            const localVarPath = `/Users/Pbx.UpgradePhone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersUpgradePhoneRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BatchDelete
         * @param {UsersBatchDeleteRequestBody} usersBatchDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchDelete(usersBatchDeleteRequestBody: UsersBatchDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchDelete(usersBatchDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.batchDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action BulkUpdate
         * @param {UsersBulkUpdateRequestBody} usersBulkUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdate(usersBulkUpdateRequestBody: UsersBulkUpdateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdate(usersBulkUpdateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.bulkUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to Users
         * @param {PbxUser} pbxUser New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(pbxUser: PbxUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(pbxUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from Users
         * @param {number} id The unique identifier of User
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function DownloadGreeting
         * @param {number} userId Usage: userId&#x3D;{userId}
         * @param {string} fileName Usage: fileName&#x3D;{fileName}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadGreeting(userId: number, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadGreeting(userId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.downloadGreeting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function ExportExtensions
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportExtensions($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $select?: Set<string>, $orderby?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOfUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportExtensions($top, $skip, $search, $filter, $count, $select, $orderby, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.exportExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateProvLink(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateProvLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.generateProvLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetDuplicatedEmails
         * @param {UsersGetDuplicatedEmailsRequestBody} usersGetDuplicatedEmailsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDuplicatedEmails(usersGetDuplicatedEmailsRequestBody: UsersGetDuplicatedEmailsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDuplicatedEmails(usersGetDuplicatedEmailsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getDuplicatedEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableExtensionNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableExtensionNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableExtensionNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFirstAvailableExtensionNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableHotdeskingNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstAvailableHotdeskingNumber(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxFirstAvailableNumber>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirstAvailableHotdeskingNumber(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getFirstAvailableHotdeskingNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetMonitorStatus
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitorStatus($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMonitorStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitorStatus($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getMonitorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetMultiEditGreetings
         * @param {UsersGetMultiEditGreetingsRequestBody} usersGetMultiEditGreetingsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultiEditGreetings(usersGetMultiEditGreetingsRequestBody: UsersGetMultiEditGreetingsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMultiEditGreetings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultiEditGreetings(usersGetMultiEditGreetingsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getMultiEditGreetings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetPhoneRegistrar
         * @param {string} mac Usage: mac&#x3D;{mac}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoneRegistrar(mac: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxPhoneRegistrar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoneRegistrar(mac, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getPhoneRegistrar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action GetPhoneRegistrars
         * @param {UsersGetPhoneRegistrarsRequestBody} usersGetPhoneRegistrarsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoneRegistrars(usersGetPhoneRegistrarsRequestBody: UsersGetPhoneRegistrarsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPhoneRegistrars200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoneRegistrars(usersGetPhoneRegistrarsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getPhoneRegistrars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetPhoneSecret
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoneSecret(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoneSecret(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getPhoneSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from Users by key
         * @param {number} id The unique identifier of User
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: number, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {string} number Usage: number&#x3D;{number}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByNumber(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByNumber(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserByNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function HasDuplicatedEmail
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasDuplicatedEmail(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCanCreateBackup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasDuplicatedEmail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.hasDuplicatedEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get ForwardingProfiles from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForwardingProfiles(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxForwardingProfileCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForwardingProfiles(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listForwardingProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Greetings from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGreetings(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxGreetingCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGreetings(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listGreetings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Groups from Users
         * @param {number} id The unique identifier of User
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(id: number, $top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserGroupCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(id, $top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from Users
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUser($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxUserCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUser($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MakeCall
         * @param {UsersMakeCallRequestBody} usersMakeCallRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeCall(usersMakeCallRequestBody: UsersMakeCallRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MakeCall200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeCall(usersMakeCallRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.makeCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MakeCallUserRecordGreeting
         * @param {number} id The unique identifier of User
         * @param {MakeCallUserRecordGreetingRequestBody} [makeCallUserRecordGreetingRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeCallUserRecordGreeting(id: number, makeCallUserRecordGreetingRequestBody?: MakeCallUserRecordGreetingRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeCallUserRecordGreeting(id, makeCallUserRecordGreetingRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.makeCallUserRecordGreeting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MultiDeleteGreeting
         * @param {UsersMultiDeleteGreetingRequestBody} usersMultiDeleteGreetingRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async multiDeleteGreeting(usersMultiDeleteGreetingRequestBody: UsersMultiDeleteGreetingRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.multiDeleteGreeting(usersMultiDeleteGreetingRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.multiDeleteGreeting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action MultiUserUpdate
         * @param {UsersMultiUserUpdateRequestBody} usersMultiUserUpdateRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async multiUserUpdate(usersMultiUserUpdateRequestBody: UsersMultiUserUpdateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.multiUserUpdate(usersMultiUserUpdateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.multiUserUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RebootPhone
         * @param {UsersRebootPhoneRequestBody} usersRebootPhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootPhone(usersRebootPhoneRequestBody: UsersRebootPhoneRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootPhone(usersRebootPhoneRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.rebootPhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action Regenerate
         * @param {number} id The unique identifier of User
         * @param {RegenerateRequestBody} [regenerateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerate(id: number, regenerateRequestBody?: RegenerateRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerate(id, regenerateRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.regenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action RegeneratePasswords
         * @param {UsersRegeneratePasswordsRequestBody} usersRegeneratePasswordsRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regeneratePasswords(usersRegeneratePasswordsRequestBody: UsersRegeneratePasswordsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regeneratePasswords(usersRegeneratePasswordsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.regeneratePasswords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ReprovisionAllPhones
         * @param {UsersReprovisionAllPhonesRequestBody} usersReprovisionAllPhonesRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reprovisionAllPhones(usersReprovisionAllPhonesRequestBody: UsersReprovisionAllPhonesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reprovisionAllPhones(usersReprovisionAllPhonesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.reprovisionAllPhones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ReprovisionPhone
         * @param {UsersReprovisionPhoneRequestBody} usersReprovisionPhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reprovisionPhone(usersReprovisionPhoneRequestBody: UsersReprovisionPhoneRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reprovisionPhone(usersReprovisionPhoneRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.reprovisionPhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SendWelcomeEmail
         * @param {number} id The unique identifier of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendWelcomeEmail(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendWelcomeEmail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendWelcomeEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action SetMonitorStatus
         * @param {number} id The unique identifier of User
         * @param {SetMonitorStatusRequestBody} [setMonitorStatusRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMonitorStatus(id: number, setMonitorStatusRequestBody?: SetMonitorStatusRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMonitorStatus(id, setMonitorStatusRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setMonitorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in Users
         * @param {number} id The unique identifier of User
         * @param {PbxUser} pbxUser New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, pbxUser: PbxUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, pbxUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action UpgradePhone
         * @param {UsersUpgradePhoneRequestBody} usersUpgradePhoneRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradePhone(usersUpgradePhoneRequestBody: UsersUpgradePhoneRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradePhone(usersUpgradePhoneRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.upgradePhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BatchDelete
         * @param {UsersApiBatchDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchDelete(requestParameters: UsersApiBatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchDelete200Response> {
            return localVarFp.batchDelete(requestParameters.usersBatchDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action BulkUpdate
         * @param {UsersApiBulkUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(requestParameters: UsersApiBulkUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkUpdate(requestParameters.usersBulkUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to Users
         * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(requestParameters: UsersApiCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUser> {
            return localVarFp.createUser(requestParameters.pbxUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from Users
         * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function DownloadGreeting
         * @param {UsersApiDownloadGreetingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGreeting(requestParameters: UsersApiDownloadGreetingRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.downloadGreeting(requestParameters.userId, requestParameters.fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function ExportExtensions
         * @param {UsersApiExportExtensionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportExtensions(requestParameters: UsersApiExportExtensionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOfUser> {
            return localVarFp.exportExtensions(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GenerateProvLink
         * @param {UsersApiGenerateProvLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateProvLink(requestParameters: UsersApiGenerateProvLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.generateProvLink(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetDuplicatedEmails
         * @param {UsersApiGetDuplicatedEmailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDuplicatedEmails(requestParameters: UsersApiGetDuplicatedEmailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAudioFiles200Response> {
            return localVarFp.getDuplicatedEmails(requestParameters.usersGetDuplicatedEmailsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableExtensionNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableExtensionNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableExtensionNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetFirstAvailableHotdeskingNumber
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstAvailableHotdeskingNumber(options?: RawAxiosRequestConfig): AxiosPromise<PbxFirstAvailableNumber> {
            return localVarFp.getFirstAvailableHotdeskingNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetMonitorStatus
         * @param {UsersApiGetMonitorStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorStatus(requestParameters: UsersApiGetMonitorStatusRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetMonitorStatus200Response> {
            return localVarFp.getMonitorStatus(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetMultiEditGreetings
         * @param {UsersApiGetMultiEditGreetingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiEditGreetings(requestParameters: UsersApiGetMultiEditGreetingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMultiEditGreetings200Response> {
            return localVarFp.getMultiEditGreetings(requestParameters.usersGetMultiEditGreetingsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetPhoneRegistrar
         * @param {UsersApiGetPhoneRegistrarRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneRegistrar(requestParameters: UsersApiGetPhoneRegistrarRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxPhoneRegistrar> {
            return localVarFp.getPhoneRegistrar(requestParameters.mac, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action GetPhoneRegistrars
         * @param {UsersApiGetPhoneRegistrarsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneRegistrars(requestParameters: UsersApiGetPhoneRegistrarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetPhoneRegistrars200Response> {
            return localVarFp.getPhoneRegistrars(requestParameters.usersGetPhoneRegistrarsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetPhoneSecret
         * @param {UsersApiGetPhoneSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoneSecret(requestParameters: UsersApiGetPhoneSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateApiKey200Response> {
            return localVarFp.getPhoneSecret(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from Users by key
         * @param {UsersApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UsersApiGetUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUser> {
            return localVarFp.getUser(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetByNumber
         * @param {UsersApiGetUserByNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByNumber(requestParameters: UsersApiGetUserByNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUser> {
            return localVarFp.getUserByNumber(requestParameters.number, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function HasDuplicatedEmail
         * @param {UsersApiHasDuplicatedEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasDuplicatedEmail(requestParameters: UsersApiHasDuplicatedEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCanCreateBackup200Response> {
            return localVarFp.hasDuplicatedEmail(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ForwardingProfiles from Users
         * @param {UsersApiListForwardingProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForwardingProfiles(requestParameters: UsersApiListForwardingProfilesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxForwardingProfileCollectionResponse> {
            return localVarFp.listForwardingProfiles(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Greetings from Users
         * @param {UsersApiListGreetingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGreetings(requestParameters: UsersApiListGreetingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxGreetingCollectionResponse> {
            return localVarFp.listGreetings(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Groups from Users
         * @param {UsersApiListGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(requestParameters: UsersApiListGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserGroupCollectionResponse> {
            return localVarFp.listGroups(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from Users
         * @param {UsersApiListUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser(requestParameters: UsersApiListUserRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxUserCollectionResponse> {
            return localVarFp.listUser(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MakeCall
         * @param {UsersApiMakeCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCall(requestParameters: UsersApiMakeCallRequest, options?: RawAxiosRequestConfig): AxiosPromise<MakeCall200Response> {
            return localVarFp.makeCall(requestParameters.usersMakeCallRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MakeCallUserRecordGreeting
         * @param {UsersApiMakeCallUserRecordGreetingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeCallUserRecordGreeting(requestParameters: UsersApiMakeCallUserRecordGreetingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.makeCallUserRecordGreeting(requestParameters.id, requestParameters.makeCallUserRecordGreetingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MultiDeleteGreeting
         * @param {UsersApiMultiDeleteGreetingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiDeleteGreeting(requestParameters: UsersApiMultiDeleteGreetingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.multiDeleteGreeting(requestParameters.usersMultiDeleteGreetingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action MultiUserUpdate
         * @param {UsersApiMultiUserUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiUserUpdate(requestParameters: UsersApiMultiUserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.multiUserUpdate(requestParameters.usersMultiUserUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RebootPhone
         * @param {UsersApiRebootPhoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootPhone(requestParameters: UsersApiRebootPhoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rebootPhone(requestParameters.usersRebootPhoneRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action Regenerate
         * @param {UsersApiRegenerateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerate(requestParameters: UsersApiRegenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.regenerate(requestParameters.id, requestParameters.regenerateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action RegeneratePasswords
         * @param {UsersApiRegeneratePasswordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regeneratePasswords(requestParameters: UsersApiRegeneratePasswordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.regeneratePasswords(requestParameters.usersRegeneratePasswordsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ReprovisionAllPhones
         * @param {UsersApiReprovisionAllPhonesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprovisionAllPhones(requestParameters: UsersApiReprovisionAllPhonesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reprovisionAllPhones(requestParameters.usersReprovisionAllPhonesRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ReprovisionPhone
         * @param {UsersApiReprovisionPhoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprovisionPhone(requestParameters: UsersApiReprovisionPhoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.reprovisionPhone(requestParameters.usersReprovisionPhoneRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SendWelcomeEmail
         * @param {UsersApiSendWelcomeEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWelcomeEmail(requestParameters: UsersApiSendWelcomeEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendWelcomeEmail(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action SetMonitorStatus
         * @param {UsersApiSetMonitorStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMonitorStatus(requestParameters: UsersApiSetMonitorStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setMonitorStatus(requestParameters.id, requestParameters.setMonitorStatusRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in Users
         * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UsersApiUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(requestParameters.id, requestParameters.pbxUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action UpgradePhone
         * @param {UsersApiUpgradePhoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradePhone(requestParameters: UsersApiUpgradePhoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.upgradePhone(requestParameters.usersUpgradePhoneRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for batchDelete operation in UsersApi.
 * @export
 * @interface UsersApiBatchDeleteRequest
 */
export interface UsersApiBatchDeleteRequest {
    /**
     * Action parameters
     * @type {UsersBatchDeleteRequestBody}
     * @memberof UsersApiBatchDelete
     */
    readonly usersBatchDeleteRequestBody: UsersBatchDeleteRequestBody
}

/**
 * Request parameters for bulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiBulkUpdateRequest
 */
export interface UsersApiBulkUpdateRequest {
    /**
     * Action parameters
     * @type {UsersBulkUpdateRequestBody}
     * @memberof UsersApiBulkUpdate
     */
    readonly usersBulkUpdateRequestBody: UsersBulkUpdateRequestBody
}

/**
 * Request parameters for createUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateUserRequest
 */
export interface UsersApiCreateUserRequest {
    /**
     * New entity
     * @type {PbxUser}
     * @memberof UsersApiCreateUser
     */
    readonly pbxUser: PbxUser
}

/**
 * Request parameters for deleteUser operation in UsersApi.
 * @export
 * @interface UsersApiDeleteUserRequest
 */
export interface UsersApiDeleteUserRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiDeleteUser
     */
    readonly id: number

    /**
     * ETag
     * @type {string}
     * @memberof UsersApiDeleteUser
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for downloadGreeting operation in UsersApi.
 * @export
 * @interface UsersApiDownloadGreetingRequest
 */
export interface UsersApiDownloadGreetingRequest {
    /**
     * Usage: userId&#x3D;{userId}
     * @type {number}
     * @memberof UsersApiDownloadGreeting
     */
    readonly userId: number

    /**
     * Usage: fileName&#x3D;{fileName}
     * @type {string}
     * @memberof UsersApiDownloadGreeting
     */
    readonly fileName: string
}

/**
 * Request parameters for exportExtensions operation in UsersApi.
 * @export
 * @interface UsersApiExportExtensionsRequest
 */
export interface UsersApiExportExtensionsRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiExportExtensions
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiExportExtensions
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiExportExtensions
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiExportExtensions
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiExportExtensions
     */
    readonly $count?: boolean

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiExportExtensions
     */
    readonly $select?: Set<string>

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof UsersApiExportExtensions
     */
    readonly $orderby?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiExportExtensions
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for generateProvLink operation in UsersApi.
 * @export
 * @interface UsersApiGenerateProvLinkRequest
 */
export interface UsersApiGenerateProvLinkRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiGenerateProvLink
     */
    readonly id: number
}

/**
 * Request parameters for getDuplicatedEmails operation in UsersApi.
 * @export
 * @interface UsersApiGetDuplicatedEmailsRequest
 */
export interface UsersApiGetDuplicatedEmailsRequest {
    /**
     * Action parameters
     * @type {UsersGetDuplicatedEmailsRequestBody}
     * @memberof UsersApiGetDuplicatedEmails
     */
    readonly usersGetDuplicatedEmailsRequestBody: UsersGetDuplicatedEmailsRequestBody
}

/**
 * Request parameters for getMonitorStatus operation in UsersApi.
 * @export
 * @interface UsersApiGetMonitorStatusRequest
 */
export interface UsersApiGetMonitorStatusRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiGetMonitorStatus
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiGetMonitorStatus
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiGetMonitorStatus
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiGetMonitorStatus
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiGetMonitorStatus
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getMultiEditGreetings operation in UsersApi.
 * @export
 * @interface UsersApiGetMultiEditGreetingsRequest
 */
export interface UsersApiGetMultiEditGreetingsRequest {
    /**
     * Action parameters
     * @type {UsersGetMultiEditGreetingsRequestBody}
     * @memberof UsersApiGetMultiEditGreetings
     */
    readonly usersGetMultiEditGreetingsRequestBody: UsersGetMultiEditGreetingsRequestBody
}

/**
 * Request parameters for getPhoneRegistrar operation in UsersApi.
 * @export
 * @interface UsersApiGetPhoneRegistrarRequest
 */
export interface UsersApiGetPhoneRegistrarRequest {
    /**
     * Usage: mac&#x3D;{mac}
     * @type {string}
     * @memberof UsersApiGetPhoneRegistrar
     */
    readonly mac: string
}

/**
 * Request parameters for getPhoneRegistrars operation in UsersApi.
 * @export
 * @interface UsersApiGetPhoneRegistrarsRequest
 */
export interface UsersApiGetPhoneRegistrarsRequest {
    /**
     * Action parameters
     * @type {UsersGetPhoneRegistrarsRequestBody}
     * @memberof UsersApiGetPhoneRegistrars
     */
    readonly usersGetPhoneRegistrarsRequestBody: UsersGetPhoneRegistrarsRequestBody
}

/**
 * Request parameters for getPhoneSecret operation in UsersApi.
 * @export
 * @interface UsersApiGetPhoneSecretRequest
 */
export interface UsersApiGetPhoneSecretRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiGetPhoneSecret
     */
    readonly id: number
}

/**
 * Request parameters for getUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRequest
 */
export interface UsersApiGetUserRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiGetUser
     */
    readonly id: number

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiGetUser
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiGetUser
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for getUserByNumber operation in UsersApi.
 * @export
 * @interface UsersApiGetUserByNumberRequest
 */
export interface UsersApiGetUserByNumberRequest {
    /**
     * Usage: number&#x3D;{number}
     * @type {string}
     * @memberof UsersApiGetUserByNumber
     */
    readonly number: string
}

/**
 * Request parameters for hasDuplicatedEmail operation in UsersApi.
 * @export
 * @interface UsersApiHasDuplicatedEmailRequest
 */
export interface UsersApiHasDuplicatedEmailRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiHasDuplicatedEmail
     */
    readonly id: number
}

/**
 * Request parameters for listForwardingProfiles operation in UsersApi.
 * @export
 * @interface UsersApiListForwardingProfilesRequest
 */
export interface UsersApiListForwardingProfilesRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiListForwardingProfiles
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listGreetings operation in UsersApi.
 * @export
 * @interface UsersApiListGreetingsRequest
 */
export interface UsersApiListGreetingsRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiListGreetings
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiListGreetings
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiListGreetings
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiListGreetings
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiListGreetings
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiListGreetings
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof UsersApiListGreetings
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiListGreetings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiListGreetings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listGroups operation in UsersApi.
 * @export
 * @interface UsersApiListGroupsRequest
 */
export interface UsersApiListGroupsRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiListGroups
     */
    readonly id: number

    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiListGroups
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiListGroups
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiListGroups
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiListGroups
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiListGroups
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof UsersApiListGroups
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiListGroups
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiListGroups
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listUser operation in UsersApi.
 * @export
 * @interface UsersApiListUserRequest
 */
export interface UsersApiListUserRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof UsersApiListUser
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof UsersApiListUser
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof UsersApiListUser
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof UsersApiListUser
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof UsersApiListUser
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof UsersApiListUser
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof UsersApiListUser
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof UsersApiListUser
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for makeCall operation in UsersApi.
 * @export
 * @interface UsersApiMakeCallRequest
 */
export interface UsersApiMakeCallRequest {
    /**
     * Action parameters
     * @type {UsersMakeCallRequestBody}
     * @memberof UsersApiMakeCall
     */
    readonly usersMakeCallRequestBody: UsersMakeCallRequestBody
}

/**
 * Request parameters for makeCallUserRecordGreeting operation in UsersApi.
 * @export
 * @interface UsersApiMakeCallUserRecordGreetingRequest
 */
export interface UsersApiMakeCallUserRecordGreetingRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiMakeCallUserRecordGreeting
     */
    readonly id: number

    /**
     * 
     * @type {MakeCallUserRecordGreetingRequestBody}
     * @memberof UsersApiMakeCallUserRecordGreeting
     */
    readonly makeCallUserRecordGreetingRequestBody?: MakeCallUserRecordGreetingRequestBody
}

/**
 * Request parameters for multiDeleteGreeting operation in UsersApi.
 * @export
 * @interface UsersApiMultiDeleteGreetingRequest
 */
export interface UsersApiMultiDeleteGreetingRequest {
    /**
     * Action parameters
     * @type {UsersMultiDeleteGreetingRequestBody}
     * @memberof UsersApiMultiDeleteGreeting
     */
    readonly usersMultiDeleteGreetingRequestBody: UsersMultiDeleteGreetingRequestBody
}

/**
 * Request parameters for multiUserUpdate operation in UsersApi.
 * @export
 * @interface UsersApiMultiUserUpdateRequest
 */
export interface UsersApiMultiUserUpdateRequest {
    /**
     * Action parameters
     * @type {UsersMultiUserUpdateRequestBody}
     * @memberof UsersApiMultiUserUpdate
     */
    readonly usersMultiUserUpdateRequestBody: UsersMultiUserUpdateRequestBody
}

/**
 * Request parameters for rebootPhone operation in UsersApi.
 * @export
 * @interface UsersApiRebootPhoneRequest
 */
export interface UsersApiRebootPhoneRequest {
    /**
     * Action parameters
     * @type {UsersRebootPhoneRequestBody}
     * @memberof UsersApiRebootPhone
     */
    readonly usersRebootPhoneRequestBody: UsersRebootPhoneRequestBody
}

/**
 * Request parameters for regenerate operation in UsersApi.
 * @export
 * @interface UsersApiRegenerateRequest
 */
export interface UsersApiRegenerateRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiRegenerate
     */
    readonly id: number

    /**
     * 
     * @type {RegenerateRequestBody}
     * @memberof UsersApiRegenerate
     */
    readonly regenerateRequestBody?: RegenerateRequestBody
}

/**
 * Request parameters for regeneratePasswords operation in UsersApi.
 * @export
 * @interface UsersApiRegeneratePasswordsRequest
 */
export interface UsersApiRegeneratePasswordsRequest {
    /**
     * Action parameters
     * @type {UsersRegeneratePasswordsRequestBody}
     * @memberof UsersApiRegeneratePasswords
     */
    readonly usersRegeneratePasswordsRequestBody: UsersRegeneratePasswordsRequestBody
}

/**
 * Request parameters for reprovisionAllPhones operation in UsersApi.
 * @export
 * @interface UsersApiReprovisionAllPhonesRequest
 */
export interface UsersApiReprovisionAllPhonesRequest {
    /**
     * Action parameters
     * @type {UsersReprovisionAllPhonesRequestBody}
     * @memberof UsersApiReprovisionAllPhones
     */
    readonly usersReprovisionAllPhonesRequestBody: UsersReprovisionAllPhonesRequestBody
}

/**
 * Request parameters for reprovisionPhone operation in UsersApi.
 * @export
 * @interface UsersApiReprovisionPhoneRequest
 */
export interface UsersApiReprovisionPhoneRequest {
    /**
     * Action parameters
     * @type {UsersReprovisionPhoneRequestBody}
     * @memberof UsersApiReprovisionPhone
     */
    readonly usersReprovisionPhoneRequestBody: UsersReprovisionPhoneRequestBody
}

/**
 * Request parameters for sendWelcomeEmail operation in UsersApi.
 * @export
 * @interface UsersApiSendWelcomeEmailRequest
 */
export interface UsersApiSendWelcomeEmailRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiSendWelcomeEmail
     */
    readonly id: number
}

/**
 * Request parameters for setMonitorStatus operation in UsersApi.
 * @export
 * @interface UsersApiSetMonitorStatusRequest
 */
export interface UsersApiSetMonitorStatusRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiSetMonitorStatus
     */
    readonly id: number

    /**
     * 
     * @type {SetMonitorStatusRequestBody}
     * @memberof UsersApiSetMonitorStatus
     */
    readonly setMonitorStatusRequestBody?: SetMonitorStatusRequestBody
}

/**
 * Request parameters for updateUser operation in UsersApi.
 * @export
 * @interface UsersApiUpdateUserRequest
 */
export interface UsersApiUpdateUserRequest {
    /**
     * The unique identifier of User
     * @type {number}
     * @memberof UsersApiUpdateUser
     */
    readonly id: number

    /**
     * New property values
     * @type {PbxUser}
     * @memberof UsersApiUpdateUser
     */
    readonly pbxUser: PbxUser
}

/**
 * Request parameters for upgradePhone operation in UsersApi.
 * @export
 * @interface UsersApiUpgradePhoneRequest
 */
export interface UsersApiUpgradePhoneRequest {
    /**
     * Action parameters
     * @type {UsersUpgradePhoneRequestBody}
     * @memberof UsersApiUpgradePhone
     */
    readonly usersUpgradePhoneRequestBody: UsersUpgradePhoneRequestBody
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BatchDelete
     * @param {UsersApiBatchDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public batchDelete(requestParameters: UsersApiBatchDeleteRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).batchDelete(requestParameters.usersBatchDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action BulkUpdate
     * @param {UsersApiBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public bulkUpdate(requestParameters: UsersApiBulkUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).bulkUpdate(requestParameters.usersBulkUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to Users
     * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(requestParameters: UsersApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(requestParameters.pbxUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from Users
     * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(requestParameters: UsersApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(requestParameters.id, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function DownloadGreeting
     * @param {UsersApiDownloadGreetingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public downloadGreeting(requestParameters: UsersApiDownloadGreetingRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).downloadGreeting(requestParameters.userId, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function ExportExtensions
     * @param {UsersApiExportExtensionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public exportExtensions(requestParameters: UsersApiExportExtensionsRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).exportExtensions(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$select, requestParameters.$orderby, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GenerateProvLink
     * @param {UsersApiGenerateProvLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public generateProvLink(requestParameters: UsersApiGenerateProvLinkRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).generateProvLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetDuplicatedEmails
     * @param {UsersApiGetDuplicatedEmailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getDuplicatedEmails(requestParameters: UsersApiGetDuplicatedEmailsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getDuplicatedEmails(requestParameters.usersGetDuplicatedEmailsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableExtensionNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFirstAvailableExtensionNumber(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFirstAvailableExtensionNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetFirstAvailableHotdeskingNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFirstAvailableHotdeskingNumber(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFirstAvailableHotdeskingNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetMonitorStatus
     * @param {UsersApiGetMonitorStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMonitorStatus(requestParameters: UsersApiGetMonitorStatusRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMonitorStatus(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetMultiEditGreetings
     * @param {UsersApiGetMultiEditGreetingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMultiEditGreetings(requestParameters: UsersApiGetMultiEditGreetingsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMultiEditGreetings(requestParameters.usersGetMultiEditGreetingsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetPhoneRegistrar
     * @param {UsersApiGetPhoneRegistrarRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPhoneRegistrar(requestParameters: UsersApiGetPhoneRegistrarRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPhoneRegistrar(requestParameters.mac, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action GetPhoneRegistrars
     * @param {UsersApiGetPhoneRegistrarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPhoneRegistrars(requestParameters: UsersApiGetPhoneRegistrarsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPhoneRegistrars(requestParameters.usersGetPhoneRegistrarsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetPhoneSecret
     * @param {UsersApiGetPhoneSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getPhoneSecret(requestParameters: UsersApiGetPhoneSecretRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPhoneSecret(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from Users by key
     * @param {UsersApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(requestParameters: UsersApiGetUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(requestParameters.id, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetByNumber
     * @param {UsersApiGetUserByNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByNumber(requestParameters: UsersApiGetUserByNumberRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByNumber(requestParameters.number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function HasDuplicatedEmail
     * @param {UsersApiHasDuplicatedEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public hasDuplicatedEmail(requestParameters: UsersApiHasDuplicatedEmailRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).hasDuplicatedEmail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ForwardingProfiles from Users
     * @param {UsersApiListForwardingProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listForwardingProfiles(requestParameters: UsersApiListForwardingProfilesRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listForwardingProfiles(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Greetings from Users
     * @param {UsersApiListGreetingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listGreetings(requestParameters: UsersApiListGreetingsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listGreetings(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Groups from Users
     * @param {UsersApiListGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listGroups(requestParameters: UsersApiListGroupsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listGroups(requestParameters.id, requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from Users
     * @param {UsersApiListUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUser(requestParameters: UsersApiListUserRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUser(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MakeCall
     * @param {UsersApiMakeCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public makeCall(requestParameters: UsersApiMakeCallRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).makeCall(requestParameters.usersMakeCallRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MakeCallUserRecordGreeting
     * @param {UsersApiMakeCallUserRecordGreetingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public makeCallUserRecordGreeting(requestParameters: UsersApiMakeCallUserRecordGreetingRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).makeCallUserRecordGreeting(requestParameters.id, requestParameters.makeCallUserRecordGreetingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MultiDeleteGreeting
     * @param {UsersApiMultiDeleteGreetingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public multiDeleteGreeting(requestParameters: UsersApiMultiDeleteGreetingRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).multiDeleteGreeting(requestParameters.usersMultiDeleteGreetingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action MultiUserUpdate
     * @param {UsersApiMultiUserUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public multiUserUpdate(requestParameters: UsersApiMultiUserUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).multiUserUpdate(requestParameters.usersMultiUserUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RebootPhone
     * @param {UsersApiRebootPhoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public rebootPhone(requestParameters: UsersApiRebootPhoneRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).rebootPhone(requestParameters.usersRebootPhoneRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action Regenerate
     * @param {UsersApiRegenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public regenerate(requestParameters: UsersApiRegenerateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).regenerate(requestParameters.id, requestParameters.regenerateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action RegeneratePasswords
     * @param {UsersApiRegeneratePasswordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public regeneratePasswords(requestParameters: UsersApiRegeneratePasswordsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).regeneratePasswords(requestParameters.usersRegeneratePasswordsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ReprovisionAllPhones
     * @param {UsersApiReprovisionAllPhonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public reprovisionAllPhones(requestParameters: UsersApiReprovisionAllPhonesRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).reprovisionAllPhones(requestParameters.usersReprovisionAllPhonesRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ReprovisionPhone
     * @param {UsersApiReprovisionPhoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public reprovisionPhone(requestParameters: UsersApiReprovisionPhoneRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).reprovisionPhone(requestParameters.usersReprovisionPhoneRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SendWelcomeEmail
     * @param {UsersApiSendWelcomeEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendWelcomeEmail(requestParameters: UsersApiSendWelcomeEmailRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendWelcomeEmail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action SetMonitorStatus
     * @param {UsersApiSetMonitorStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setMonitorStatus(requestParameters: UsersApiSetMonitorStatusRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setMonitorStatus(requestParameters.id, requestParameters.setMonitorStatusRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in Users
     * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(requestParameters: UsersApiUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(requestParameters.id, requestParameters.pbxUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action UpgradePhone
     * @param {UsersApiUpgradePhoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public upgradePhone(requestParameters: UsersApiUpgradePhoneRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).upgradePhone(requestParameters.usersUpgradePhoneRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoicemailSettingsApi - axios parameter creator
 * @export
 */
export const VoicemailSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action DeleteAllUserVoicemails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUserVoicemails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/VoicemailSettings/Pbx.DeleteAllUserVoicemails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke function GetTranscribeLanguages
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscribeLanguages: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/VoicemailSettings/Pbx.GetTranscribeLanguages()`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get VoicemailSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoicemailSettings: async ($select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/VoicemailSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update VoicemailSettings
         * @param {PbxVoicemailSettings} pbxVoicemailSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoicemailSettings: async (pbxVoicemailSettings: PbxVoicemailSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxVoicemailSettings' is not null or undefined
            assertParamExists('updateVoicemailSettings', 'pbxVoicemailSettings', pbxVoicemailSettings)
            const localVarPath = `/VoicemailSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxVoicemailSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoicemailSettingsApi - functional programming interface
 * @export
 */
export const VoicemailSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoicemailSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action DeleteAllUserVoicemails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllUserVoicemails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllUserVoicemails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoicemailSettingsApi.deleteAllUserVoicemails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke function GetTranscribeLanguages
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscribeLanguages($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTranscribeLanguages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscribeLanguages($top, $skip, $search, $filter, $count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoicemailSettingsApi.getTranscribeLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get VoicemailSettings
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoicemailSettings($select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxVoicemailSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoicemailSettings($select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoicemailSettingsApi.getVoicemailSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update VoicemailSettings
         * @param {PbxVoicemailSettings} pbxVoicemailSettings New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoicemailSettings(pbxVoicemailSettings: PbxVoicemailSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoicemailSettings(pbxVoicemailSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoicemailSettingsApi.updateVoicemailSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoicemailSettingsApi - factory interface
 * @export
 */
export const VoicemailSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoicemailSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action DeleteAllUserVoicemails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUserVoicemails(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllUserVoicemails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke function GetTranscribeLanguages
         * @param {VoicemailSettingsApiGetTranscribeLanguagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscribeLanguages(requestParameters: VoicemailSettingsApiGetTranscribeLanguagesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetTranscribeLanguages200Response> {
            return localVarFp.getTranscribeLanguages(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get VoicemailSettings
         * @param {VoicemailSettingsApiGetVoicemailSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoicemailSettings(requestParameters: VoicemailSettingsApiGetVoicemailSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxVoicemailSettings> {
            return localVarFp.getVoicemailSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update VoicemailSettings
         * @param {VoicemailSettingsApiUpdateVoicemailSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoicemailSettings(requestParameters: VoicemailSettingsApiUpdateVoicemailSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateVoicemailSettings(requestParameters.pbxVoicemailSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTranscribeLanguages operation in VoicemailSettingsApi.
 * @export
 * @interface VoicemailSettingsApiGetTranscribeLanguagesRequest
 */
export interface VoicemailSettingsApiGetTranscribeLanguagesRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof VoicemailSettingsApiGetTranscribeLanguages
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof VoicemailSettingsApiGetTranscribeLanguages
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof VoicemailSettingsApiGetTranscribeLanguages
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof VoicemailSettingsApiGetTranscribeLanguages
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof VoicemailSettingsApiGetTranscribeLanguages
     */
    readonly $count?: boolean
}

/**
 * Request parameters for getVoicemailSettings operation in VoicemailSettingsApi.
 * @export
 * @interface VoicemailSettingsApiGetVoicemailSettingsRequest
 */
export interface VoicemailSettingsApiGetVoicemailSettingsRequest {
    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof VoicemailSettingsApiGetVoicemailSettings
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof VoicemailSettingsApiGetVoicemailSettings
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateVoicemailSettings operation in VoicemailSettingsApi.
 * @export
 * @interface VoicemailSettingsApiUpdateVoicemailSettingsRequest
 */
export interface VoicemailSettingsApiUpdateVoicemailSettingsRequest {
    /**
     * New property values
     * @type {PbxVoicemailSettings}
     * @memberof VoicemailSettingsApiUpdateVoicemailSettings
     */
    readonly pbxVoicemailSettings: PbxVoicemailSettings
}

/**
 * VoicemailSettingsApi - object-oriented interface
 * @export
 * @class VoicemailSettingsApi
 * @extends {BaseAPI}
 */
export class VoicemailSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action DeleteAllUserVoicemails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicemailSettingsApi
     */
    public deleteAllUserVoicemails(options?: RawAxiosRequestConfig) {
        return VoicemailSettingsApiFp(this.configuration).deleteAllUserVoicemails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke function GetTranscribeLanguages
     * @param {VoicemailSettingsApiGetTranscribeLanguagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicemailSettingsApi
     */
    public getTranscribeLanguages(requestParameters: VoicemailSettingsApiGetTranscribeLanguagesRequest = {}, options?: RawAxiosRequestConfig) {
        return VoicemailSettingsApiFp(this.configuration).getTranscribeLanguages(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get VoicemailSettings
     * @param {VoicemailSettingsApiGetVoicemailSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicemailSettingsApi
     */
    public getVoicemailSettings(requestParameters: VoicemailSettingsApiGetVoicemailSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return VoicemailSettingsApiFp(this.configuration).getVoicemailSettings(requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update VoicemailSettings
     * @param {VoicemailSettingsApiUpdateVoicemailSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicemailSettingsApi
     */
    public updateVoicemailSettings(requestParameters: VoicemailSettingsApiUpdateVoicemailSettingsRequest, options?: RawAxiosRequestConfig) {
        return VoicemailSettingsApiFp(this.configuration).updateVoicemailSettings(requestParameters.pbxVoicemailSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebsiteLinksApi - axios parameter creator
 * @export
 */
export const WebsiteLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invoke action BulkLinksDelete
         * @param {WebsiteLinksBulkLinksDeleteRequestBody} websiteLinksBulkLinksDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkLinksDelete: async (websiteLinksBulkLinksDeleteRequestBody: WebsiteLinksBulkLinksDeleteRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'websiteLinksBulkLinksDeleteRequestBody' is not null or undefined
            assertParamExists('bulkLinksDelete', 'websiteLinksBulkLinksDeleteRequestBody', websiteLinksBulkLinksDeleteRequestBody)
            const localVarPath = `/WebsiteLinks/Pbx.BulkLinksDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteLinksBulkLinksDeleteRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new entity to WebsiteLinks
         * @param {PbxWeblink} pbxWeblink New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeblink: async (pbxWeblink: PbxWeblink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pbxWeblink' is not null or undefined
            assertParamExists('createWeblink', 'pbxWeblink', pbxWeblink)
            const localVarPath = `/WebsiteLinks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxWeblink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete entity from WebsiteLinks
         * @param {string} link The unique identifier of Weblink
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWeblink: async (link: string, ifMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'link' is not null or undefined
            assertParamExists('deleteWeblink', 'link', link)
            const localVarPath = `/WebsiteLinks({Link})`
                .replace(`{${"Link"}}`, encodeURIComponent(String(link)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entity from WebsiteLinks by key
         * @param {string} link The unique identifier of Weblink
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeblink: async (link: string, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'link' is not null or undefined
            assertParamExists('getWeblink', 'link', link)
            const localVarPath = `/WebsiteLinks({Link})`
                .replace(`{${"Link"}}`, encodeURIComponent(String(link)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get entities from WebsiteLinks
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWeblink: async ($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/WebsiteLinks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($search !== undefined) {
                localVarQueryParameter['$search'] = $search;
            }

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($orderby) {
                localVarQueryParameter['$orderby'] = Array.from($orderby).join(COLLECTION_FORMATS.csv);
            }

            if ($select) {
                localVarQueryParameter['$select'] = Array.from($select).join(COLLECTION_FORMATS.csv);
            }

            if ($expand) {
                localVarQueryParameter['$expand'] = Array.from($expand).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update entity in WebsiteLinks
         * @param {string} link The unique identifier of Weblink
         * @param {PbxWeblink} pbxWeblink New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeblink: async (link: string, pbxWeblink: PbxWeblink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'link' is not null or undefined
            assertParamExists('updateWeblink', 'link', link)
            // verify required parameter 'pbxWeblink' is not null or undefined
            assertParamExists('updateWeblink', 'pbxWeblink', pbxWeblink)
            const localVarPath = `/WebsiteLinks({Link})`
                .replace(`{${"Link"}}`, encodeURIComponent(String(link)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pbxWeblink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke action ValidateLink
         * @param {WebsiteLinksValidateLinkRequestBody} websiteLinksValidateLinkRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLink: async (websiteLinksValidateLinkRequestBody: WebsiteLinksValidateLinkRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'websiteLinksValidateLinkRequestBody' is not null or undefined
            assertParamExists('validateLink', 'websiteLinksValidateLinkRequestBody', websiteLinksValidateLinkRequestBody)
            const localVarPath = `/WebsiteLinks/Pbx.ValidateLink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Application", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteLinksValidateLinkRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsiteLinksApi - functional programming interface
 * @export
 */
export const WebsiteLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsiteLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkLinksDelete
         * @param {WebsiteLinksBulkLinksDeleteRequestBody} websiteLinksBulkLinksDeleteRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkLinksDelete(websiteLinksBulkLinksDeleteRequestBody: WebsiteLinksBulkLinksDeleteRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkLinksDelete(websiteLinksBulkLinksDeleteRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.bulkLinksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add new entity to WebsiteLinks
         * @param {PbxWeblink} pbxWeblink New entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWeblink(pbxWeblink: PbxWeblink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxWeblink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWeblink(pbxWeblink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.createWeblink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete entity from WebsiteLinks
         * @param {string} link The unique identifier of Weblink
         * @param {string} [ifMatch] ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWeblink(link: string, ifMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWeblink(link, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.deleteWeblink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entity from WebsiteLinks by key
         * @param {string} link The unique identifier of Weblink
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeblink(link: string, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxWeblink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeblink(link, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.getWeblink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get entities from WebsiteLinks
         * @param {number} [$top] Show only the first n items
         * @param {number} [$skip] Skip the first n items
         * @param {string} [$search] Search items by search phrases
         * @param {string} [$filter] Filter items by property values
         * @param {boolean} [$count] Include count of items
         * @param {Set<string>} [$orderby] Order items by property values
         * @param {Set<string>} [$select] Select properties to be returned
         * @param {Set<string>} [$expand] Expand related entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWeblink($top?: number, $skip?: number, $search?: string, $filter?: string, $count?: boolean, $orderby?: Set<string>, $select?: Set<string>, $expand?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PbxWeblinkCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWeblink($top, $skip, $search, $filter, $count, $orderby, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.listWeblink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update entity in WebsiteLinks
         * @param {string} link The unique identifier of Weblink
         * @param {PbxWeblink} pbxWeblink New property values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWeblink(link: string, pbxWeblink: PbxWeblink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWeblink(link, pbxWeblink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.updateWeblink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke action ValidateLink
         * @param {WebsiteLinksValidateLinkRequestBody} websiteLinksValidateLinkRequestBody Action parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLink(websiteLinksValidateLinkRequestBody: WebsiteLinksValidateLinkRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLink(websiteLinksValidateLinkRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsiteLinksApi.validateLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebsiteLinksApi - factory interface
 * @export
 */
export const WebsiteLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsiteLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Invoke action BulkLinksDelete
         * @param {WebsiteLinksApiBulkLinksDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkLinksDelete(requestParameters: WebsiteLinksApiBulkLinksDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkLinksDelete(requestParameters.websiteLinksBulkLinksDeleteRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new entity to WebsiteLinks
         * @param {WebsiteLinksApiCreateWeblinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeblink(requestParameters: WebsiteLinksApiCreateWeblinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxWeblink> {
            return localVarFp.createWeblink(requestParameters.pbxWeblink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete entity from WebsiteLinks
         * @param {WebsiteLinksApiDeleteWeblinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWeblink(requestParameters: WebsiteLinksApiDeleteWeblinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWeblink(requestParameters.link, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entity from WebsiteLinks by key
         * @param {WebsiteLinksApiGetWeblinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeblink(requestParameters: WebsiteLinksApiGetWeblinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<PbxWeblink> {
            return localVarFp.getWeblink(requestParameters.link, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get entities from WebsiteLinks
         * @param {WebsiteLinksApiListWeblinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWeblink(requestParameters: WebsiteLinksApiListWeblinkRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PbxWeblinkCollectionResponse> {
            return localVarFp.listWeblink(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update entity in WebsiteLinks
         * @param {WebsiteLinksApiUpdateWeblinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWeblink(requestParameters: WebsiteLinksApiUpdateWeblinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateWeblink(requestParameters.link, requestParameters.pbxWeblink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke action ValidateLink
         * @param {WebsiteLinksApiValidateLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLink(requestParameters: WebsiteLinksApiValidateLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateLink(requestParameters.websiteLinksValidateLinkRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkLinksDelete operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiBulkLinksDeleteRequest
 */
export interface WebsiteLinksApiBulkLinksDeleteRequest {
    /**
     * Action parameters
     * @type {WebsiteLinksBulkLinksDeleteRequestBody}
     * @memberof WebsiteLinksApiBulkLinksDelete
     */
    readonly websiteLinksBulkLinksDeleteRequestBody: WebsiteLinksBulkLinksDeleteRequestBody
}

/**
 * Request parameters for createWeblink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiCreateWeblinkRequest
 */
export interface WebsiteLinksApiCreateWeblinkRequest {
    /**
     * New entity
     * @type {PbxWeblink}
     * @memberof WebsiteLinksApiCreateWeblink
     */
    readonly pbxWeblink: PbxWeblink
}

/**
 * Request parameters for deleteWeblink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiDeleteWeblinkRequest
 */
export interface WebsiteLinksApiDeleteWeblinkRequest {
    /**
     * The unique identifier of Weblink
     * @type {string}
     * @memberof WebsiteLinksApiDeleteWeblink
     */
    readonly link: string

    /**
     * ETag
     * @type {string}
     * @memberof WebsiteLinksApiDeleteWeblink
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getWeblink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiGetWeblinkRequest
 */
export interface WebsiteLinksApiGetWeblinkRequest {
    /**
     * The unique identifier of Weblink
     * @type {string}
     * @memberof WebsiteLinksApiGetWeblink
     */
    readonly link: string

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof WebsiteLinksApiGetWeblink
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof WebsiteLinksApiGetWeblink
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for listWeblink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiListWeblinkRequest
 */
export interface WebsiteLinksApiListWeblinkRequest {
    /**
     * Show only the first n items
     * @type {number}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $top?: number

    /**
     * Skip the first n items
     * @type {number}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $skip?: number

    /**
     * Search items by search phrases
     * @type {string}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $search?: string

    /**
     * Filter items by property values
     * @type {string}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $filter?: string

    /**
     * Include count of items
     * @type {boolean}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $count?: boolean

    /**
     * Order items by property values
     * @type {Set<string>}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $orderby?: Set<string>

    /**
     * Select properties to be returned
     * @type {Set<string>}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $select?: Set<string>

    /**
     * Expand related entities
     * @type {Set<string>}
     * @memberof WebsiteLinksApiListWeblink
     */
    readonly $expand?: Set<string>
}

/**
 * Request parameters for updateWeblink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiUpdateWeblinkRequest
 */
export interface WebsiteLinksApiUpdateWeblinkRequest {
    /**
     * The unique identifier of Weblink
     * @type {string}
     * @memberof WebsiteLinksApiUpdateWeblink
     */
    readonly link: string

    /**
     * New property values
     * @type {PbxWeblink}
     * @memberof WebsiteLinksApiUpdateWeblink
     */
    readonly pbxWeblink: PbxWeblink
}

/**
 * Request parameters for validateLink operation in WebsiteLinksApi.
 * @export
 * @interface WebsiteLinksApiValidateLinkRequest
 */
export interface WebsiteLinksApiValidateLinkRequest {
    /**
     * Action parameters
     * @type {WebsiteLinksValidateLinkRequestBody}
     * @memberof WebsiteLinksApiValidateLink
     */
    readonly websiteLinksValidateLinkRequestBody: WebsiteLinksValidateLinkRequestBody
}

/**
 * WebsiteLinksApi - object-oriented interface
 * @export
 * @class WebsiteLinksApi
 * @extends {BaseAPI}
 */
export class WebsiteLinksApi extends BaseAPI {
    /**
     * 
     * @summary Invoke action BulkLinksDelete
     * @param {WebsiteLinksApiBulkLinksDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public bulkLinksDelete(requestParameters: WebsiteLinksApiBulkLinksDeleteRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).bulkLinksDelete(requestParameters.websiteLinksBulkLinksDeleteRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new entity to WebsiteLinks
     * @param {WebsiteLinksApiCreateWeblinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public createWeblink(requestParameters: WebsiteLinksApiCreateWeblinkRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).createWeblink(requestParameters.pbxWeblink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete entity from WebsiteLinks
     * @param {WebsiteLinksApiDeleteWeblinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public deleteWeblink(requestParameters: WebsiteLinksApiDeleteWeblinkRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).deleteWeblink(requestParameters.link, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entity from WebsiteLinks by key
     * @param {WebsiteLinksApiGetWeblinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public getWeblink(requestParameters: WebsiteLinksApiGetWeblinkRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).getWeblink(requestParameters.link, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get entities from WebsiteLinks
     * @param {WebsiteLinksApiListWeblinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public listWeblink(requestParameters: WebsiteLinksApiListWeblinkRequest = {}, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).listWeblink(requestParameters.$top, requestParameters.$skip, requestParameters.$search, requestParameters.$filter, requestParameters.$count, requestParameters.$orderby, requestParameters.$select, requestParameters.$expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update entity in WebsiteLinks
     * @param {WebsiteLinksApiUpdateWeblinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public updateWeblink(requestParameters: WebsiteLinksApiUpdateWeblinkRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).updateWeblink(requestParameters.link, requestParameters.pbxWeblink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke action ValidateLink
     * @param {WebsiteLinksApiValidateLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteLinksApi
     */
    public validateLink(requestParameters: WebsiteLinksApiValidateLinkRequest, options?: RawAxiosRequestConfig) {
        return WebsiteLinksApiFp(this.configuration).validateLink(requestParameters.websiteLinksValidateLinkRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



